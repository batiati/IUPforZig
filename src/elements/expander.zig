// This code was generated by a tool.
// IUP Metadata Code Generator
// https://github.com/batiati/IUPMetadata
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.

const std = @import("std");

const c = @import("../c.zig");
const iup = @import("../iup.zig");

const Impl = @import("../impl.zig").Impl;
const CallbackHandler = @import("../callback_handler.zig").CallbackHandler;

const debug = std.debug;
const trait = std.meta.trait;

const Element = iup.Element;
const Handle = iup.Handle;
const Error = iup.Error;
const ChildrenIterator = iup.ChildrenIterator;
const Size = iup.Size;
const Margin = iup.Margin;

/// 
/// Creates a void container that can interactively show or hide its child.
/// It does not have a native representation, but it contains also several
/// elements to implement the bar handler.
pub const Expander = opaque {
    pub const CLASS_NAME = "expander";
    const Self = @This();

    /// 
    /// ACTION ACTION Action generated when the element is activated.
    /// Affects each element differently.
    /// Callback int function(Ihandle *ih); [in C] ih:action() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// In some elements, this callback may receive more parameters, apart from ih.
    /// Please refer to each element's documentation.
    /// Affects IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    /// IupToggle
    pub const OnActionFn = fn (self: *Self) anyerror!void;

    /// 
    /// EXTRABUTTON_CB: Action generated when any mouse button is pressed or released.
    /// (since 3.11) int function(Ihandle* ih, int button, int pressed); [in C]
    /// ih:extrabutton_cb(button, pressed: number) -> (ret: number) [in Lua] ih:
    /// identifies the element that activated the event.
    /// button: identifies the extra button.
    /// can be 1, 2 or 3.
    /// (this is not the same as BUTTON_CB)pressed: indicates the state of the
    /// button: 0 - mouse button was released; 1 - mouse button was pressed.
    pub const OnExtraButtonFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    /// 
    /// OPENCLOSE_CB: Action generated before the expander state is interactively changed.
    /// (Since 3.11) int function(Ihandle* ih, int state); [in
    /// C]ih:openclose_cb(state: number) -> (ret: number) [in Lua]
    pub const OnOpenCloseFn = fn (self: *Self, arg0: i32) anyerror!void;

    /// 
    /// MAP_CB MAP_CB Called right after an element is mapped and its attributes
    /// updated in IupMap.
    /// When the element is a dialog, it is called after the layout is updated.
    /// For all other elements is called before the layout is updated, so the
    /// element current size will still be 0x0 during MAP_CB (since 3.14).
    /// Callback int function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub const OnMapFn = fn (self: *Self) anyerror!void;

    /// 
    /// DESTROY_CB DESTROY_CB Called right before an element is destroyed.
    /// Callback int function(Ihandle *ih); [in C] ih:destroy_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Notes If the dialog is visible then it is hidden before it is destroyed.
    /// The callback will be called right after it is hidden.
    /// The callback will be called before all other destroy procedures.
    /// For instance, if the element has children then it is called before the
    /// children are destroyed.
    /// For language binding implementations use the callback name "LDESTROY_CB" to
    /// release memory allocated by the binding for the element.
    /// Also the callback will be called before the language callback.
    /// Affects All.
    pub const OnDestroyFn = fn (self: *Self) anyerror!void;

    /// 
    /// UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    /// Callback int function(Ihandle *ih); [in C] ih:unmap_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub const OnUnmapFn = fn (self: *Self) anyerror!void;

    pub const OnLDestroyFn = fn (self: *Self) anyerror!void;

    pub const OnPostMessageFn = fn (self: *Self, arg0: [:0]const u8, arg1: i32, arg2: f64, arg3: *iup.Unknow) anyerror!void;

    /// 
    /// EXPAND (non inheritable): the default value is "YES".
    pub const Expand = enum {
        Yes,
        Horizontal,
        Vertical,
        HorizontalFree,
        VerticalFree,
        No,
    };

    pub const Floating = enum {
        Yes,
        Ignore,
        No,
    };
    /// 
    /// STATE (non inheritable): Show or hide the container elements.
    /// Possible values: "OPEN" (expanded) or "CLOSE" (collapsed).
    /// Default: OPEN.
    /// Setting this attribute will automatically change the layout of the entire
    /// dialog so the child can be recomposed.
    pub const State = enum {
        Open,
        Closed,
    };
    /// 
    /// ANIMATION (non inheritable): enable animation during open/close.
    /// Works only for BARPOSITION=TOP and does not works for AUTOSHOW.
    /// Also the child must be a native container like IupTabs, IupFrame,
    /// IupBackgroundBox, or IupScrollBox, or it will not work accordantly.
    /// Values can be SLIDE (child controls slide down), CURTAIN (child controls
    /// appears as if a curtain is being pulled) or NO.
    /// Default: NO.
    /// ((since 3.14)
    pub const Animation = enum {
        Slide,
        Curtain,
        No,
    };

    pub const Initializer = struct {
        last_error: ?anyerror = null,
        ref: *Self,

        ///
        /// Returns a pointer to IUP element or an error.
        /// Only top-level or detached elements needs to be unwraped,
        pub fn unwrap(self: Initializer) !*Self {
            if (self.last_error) |e| {
                return e;
            } else {
                return self.ref;
            }
        }

        ///
        /// Captures a reference into a external variable
        /// Allows to capture some references even using full declarative API
        pub fn capture(self: *Initializer, ref: **Self) Initializer {
            ref.* = self.ref;
            return self.*;
        }

        pub fn setStrAttribute(self: *Initializer, attributeName: [:0]const u8, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setStrAttribute(self.ref, attributeName, arg);
            return self.*;
        }

        pub fn setIntAttribute(self: *Initializer, attributeName: [:0]const u8, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setIntAttribute(self.ref, attributeName, arg);
            return self.*;
        }

        pub fn setBoolAttribute(self: *Initializer, attributeName: [:0]const u8, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setBoolAttribute(self.ref, attributeName, bool);
            return self.*;
        }

        pub fn setPtrAttribute(self: *Initializer, comptime T: type, attributeName: [:0]const u8, value: ?*T) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setPtrAttribute(self.ref, T, attributeName, value);
            return self.*;
        }

        pub fn setChildren(self: *Initializer, tuple: anytype) Initializer {
            if (self.last_error) |_| return self.*;

            Self.appendChildren(self.ref, tuple) catch |err| {
                self.last_error = err;
            };

            return self.*;
        }

        pub fn setHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setHandle(self.ref, arg);
            return self.*;
        }

        pub fn setFrameTime(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "FRAMETIME", .{}, arg);
            return self.*;
        }


        /// 
        /// BACKCOLOR (non inheritable): background color of the bar handler.
        /// If not defined it will use the background color of the native parent.
        /// (since 3.9)
        pub fn setBackColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            c.setRgb(self.ref, "BACKCOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setMaxSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "MAXSIZE", .{}, value);
            return self.*;
        }


        /// 
        /// TITLEIMAGE (non inheritable): title image, shown in the bar handler near
        /// the expand/collapse button.
        /// When set it will reset TITLE (image and text title are mutually exclusive).
        /// Shown only when BARPOSITION=TOP.
        /// (since 3.14)
        pub fn setTitleImage(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "TITLEIMAGE", .{}, arg);
            return self.*;
        }

        pub fn setPosition(self: *Initializer, x: i32, y: i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
            c.setStrAttribute(self.ref, "POSITION", .{}, value);
            return self.*;
        }

        pub fn setCanFocus(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "CANFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setVisible(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "VISIBLE", .{}, arg);
            return self.*;
        }


        /// 
        /// IMAGE (non inheritable): image name to replace the arrow image by a custom
        /// image when STATE=CLOSE.
        /// Works only when BARPOSITION=TOP.
        /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
        /// See also IupImage.
        /// (since 3.11)
        pub fn setImage(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "IMAGE", .{}, arg);
            return self.*;
        }


        /// 
        /// HIGHCOLOR (non inheritable): title text color when highlighted.
        /// Works only when TITLEEXPAND=Yes.
        /// Defaults to the FORECOLOR if not defined.
        /// (since 3.14)
        pub fn setHighColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            c.setRgb(self.ref, "HIGHCOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setTheme(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "THEME", .{}, arg);
            return self.*;
        }


        /// 
        /// EXPAND (non inheritable): the default value is "YES".
        pub fn setExpand(self: *Initializer, arg: ?Expand) Initializer {
            if (arg) |value| switch (value) {
                .Yes => c.setStrAttribute(self.ref, "EXPAND", .{}, "YES"),
                .Horizontal => c.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTAL"),
                .Vertical => c.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICAL"),
                .HorizontalFree => c.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTALFREE"),
                .VerticalFree => c.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICALFREE"),
                .No => c.setStrAttribute(self.ref, "EXPAND", .{}, "NO"),
            } else {
                c.clearAttribute(self.ref, "EXPAND", .{});
            }
            return self.*;
        }

        pub fn setSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "SIZE", .{}, value);
            return self.*;
        }

        pub fn setFontSize(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "FONTSIZE", .{}, arg);
            return self.*;
        }

        pub fn setUserSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "USERSIZE", .{}, value);
            return self.*;
        }


        /// 
        /// TITLE (non inheritable): title text, shown in the bar handler near the
        /// expand/collapse button.
        /// When set it will reset TITLEIMAGE.
        /// Shown only when BARPOSITION=TOP.
        /// When the TITLE is defined and BARPOSITION=TOP then the expand/collapse
        /// button is left aligned.
        /// In all other situations the expand/collapse button is centered.
        pub fn setTitle(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "TITLE", .{}, arg);
            return self.*;
        }

        pub fn setPropagateFocus(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "PROPAGATEFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setFloating(self: *Initializer, arg: ?Floating) Initializer {
            if (arg) |value| switch (value) {
                .Yes => c.setStrAttribute(self.ref, "FLOATING", .{}, "YES"),
                .Ignore => c.setStrAttribute(self.ref, "FLOATING", .{}, "IGNORE"),
                .No => c.setStrAttribute(self.ref, "FLOATING", .{}, "NO"),
            } else {
                c.clearAttribute(self.ref, "FLOATING", .{});
            }
            return self.*;
        }

        pub fn setNormalizerGroup(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "NORMALIZERGROUP", .{}, arg);
            return self.*;
        }

        pub fn setRasterSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "RASTERSIZE", .{}, value);
            return self.*;
        }


        /// 
        /// BARSIZE (non inheritable): controls the size of the bar handler.
        /// Default: the height or width that fits all its internal elements according
        /// to BARPOSITION.
        pub fn setBarSize(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "BARSIZE", .{}, arg);
            return self.*;
        }


        /// 
        /// FRAMECOLOR (non inheritable): frame line color.
        /// Default: the global attribute DLGFGCOLOR.
        /// (since 3.23)
        pub fn setFrameColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            c.setRgb(self.ref, "FRAMECOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setFontFace(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "FONTFACE", .{}, arg);
            return self.*;
        }

        pub fn setName(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "NAME", .{}, arg);
            return self.*;
        }


        /// 
        /// STATE (non inheritable): Show or hide the container elements.
        /// Possible values: "OPEN" (expanded) or "CLOSE" (collapsed).
        /// Default: OPEN.
        /// Setting this attribute will automatically change the layout of the entire
        /// dialog so the child can be recomposed.
        pub fn setState(self: *Initializer, arg: ?State) Initializer {
            if (arg) |value| switch (value) {
                .Open => c.setStrAttribute(self.ref, "STATE", .{}, "OPEN"),
                .Closed => c.setStrAttribute(self.ref, "STATE", .{}, "CLOSED"),
            } else {
                c.clearAttribute(self.ref, "STATE", .{});
            }
            return self.*;
        }

        pub fn setActive(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "ACTIVE", .{}, arg);
            return self.*;
        }

        pub fn setImageHighlight(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "IMAGEHIGHLIGHT", .{}, arg);
            return self.*;
        }

        pub fn setExpandWeight(self: *Initializer, arg: f64) Initializer {
            c.setDoubleAttribute(self.ref, "EXPANDWEIGHT", .{}, arg);
            return self.*;
        }

        pub fn setMinSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "MINSIZE", .{}, value);
            return self.*;
        }

        pub fn setNTheme(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "NTHEME", .{}, arg);
            return self.*;
        }


        /// 
        /// EXTRABUTTONS (non inheritable) (creation only): sets the number of extra
        /// image buttons at right when BARPOSITION=TOP.
        /// The maximum number of buttons is 3.
        /// See the EXTRABUTTON_CB callback.
        /// Default: 0.
        /// (since 3.11)
        pub fn setExtraButtons(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "EXTRABUTTONS", .{}, arg);
            return self.*;
        }


        /// 
        /// ANIMATION (non inheritable): enable animation during open/close.
        /// Works only for BARPOSITION=TOP and does not works for AUTOSHOW.
        /// Also the child must be a native container like IupTabs, IupFrame,
        /// IupBackgroundBox, or IupScrollBox, or it will not work accordantly.
        /// Values can be SLIDE (child controls slide down), CURTAIN (child controls
        /// appears as if a curtain is being pulled) or NO.
        /// Default: NO.
        /// ((since 3.14)
        pub fn setAnimation(self: *Initializer, arg: ?Animation) Initializer {
            if (arg) |value| switch (value) {
                .Slide => c.setStrAttribute(self.ref, "ANIMATION", .{}, "SLIDE"),
                .Curtain => c.setStrAttribute(self.ref, "ANIMATION", .{}, "CURTAIN"),
                .No => c.setStrAttribute(self.ref, "ANIMATION", .{}, "NO"),
            } else {
                c.clearAttribute(self.ref, "ANIMATION", .{});
            }
            return self.*;
        }


        /// 
        /// FORECOLOR (non inheritable): title text color.
        /// Default: the global attribute DLGFGCOLOR.
        /// (since 3.9)
        pub fn setForeColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            c.setRgb(self.ref, "FORECOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setFontStyle(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "FONTSTYLE", .{}, arg);
            return self.*;
        }


        /// 
        /// FRAMEWIDTH (non inheritable): frame line width.
        /// Default: 1.
        /// (since 3.23)
        pub fn setFrameWidth(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "FRAMEWIDTH", .{}, arg);
            return self.*;
        }


        /// 
        /// FRAME (non inheritable): enables the frame line around the bar area.
        /// Default: No.
        /// (since 3.23)
        pub fn setFrame(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "FRAME", .{}, arg);
            return self.*;
        }


        /// 
        /// FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE,
        /// MAXSIZE, THEME: also accepted.
        pub fn setFont(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "FONT", .{}, arg);
            return self.*;
        }

        /// 
        /// ACTION ACTION Action generated when the element is activated.
        /// Affects each element differently.
        /// Callback int function(Ihandle *ih); [in C] ih:action() -> (ret: number) [in
        /// Lua] ih: identifier of the element that activated the event.
        /// In some elements, this callback may receive more parameters, apart from ih.
        /// Please refer to each element's documentation.
        /// Affects IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
        /// IupToggle
        pub fn setActionCallback(self: *Initializer, callback: ?OnActionFn) Initializer {
            const Handler = CallbackHandler(Self, OnActionFn, "ACTION");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// EXTRABUTTON_CB: Action generated when any mouse button is pressed or released.
        /// (since 3.11) int function(Ihandle* ih, int button, int pressed); [in C]
        /// ih:extrabutton_cb(button, pressed: number) -> (ret: number) [in Lua] ih:
        /// identifies the element that activated the event.
        /// button: identifies the extra button.
        /// can be 1, 2 or 3.
        /// (this is not the same as BUTTON_CB)pressed: indicates the state of the
        /// button: 0 - mouse button was released; 1 - mouse button was pressed.
        pub fn setExtraButtonCallback(self: *Initializer, callback: ?OnExtraButtonFn) Initializer {
            const Handler = CallbackHandler(Self, OnExtraButtonFn, "EXTRABUTTON_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// OPENCLOSE_CB: Action generated before the expander state is interactively changed.
        /// (Since 3.11) int function(Ihandle* ih, int state); [in
        /// C]ih:openclose_cb(state: number) -> (ret: number) [in Lua]
        pub fn setOpenCloseCallback(self: *Initializer, callback: ?OnOpenCloseFn) Initializer {
            const Handler = CallbackHandler(Self, OnOpenCloseFn, "OPENCLOSE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// MAP_CB MAP_CB Called right after an element is mapped and its attributes
        /// updated in IupMap.
        /// When the element is a dialog, it is called after the layout is updated.
        /// For all other elements is called before the layout is updated, so the
        /// element current size will still be 0x0 during MAP_CB (since 3.14).
        /// Callback int function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
        /// Lua] ih: identifier of the element that activated the event.
        /// Affects All that have a native representation.
        pub fn setMapCallback(self: *Initializer, callback: ?OnMapFn) Initializer {
            const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// DESTROY_CB DESTROY_CB Called right before an element is destroyed.
        /// Callback int function(Ihandle *ih); [in C] ih:destroy_cb() -> (ret: number)
        /// [in Lua] ih: identifier of the element that activated the event.
        /// Notes If the dialog is visible then it is hidden before it is destroyed.
        /// The callback will be called right after it is hidden.
        /// The callback will be called before all other destroy procedures.
        /// For instance, if the element has children then it is called before the
        /// children are destroyed.
        /// For language binding implementations use the callback name "LDESTROY_CB" to
        /// release memory allocated by the binding for the element.
        /// Also the callback will be called before the language callback.
        /// Affects All.
        pub fn setDestroyCallback(self: *Initializer, callback: ?OnDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// UNMAP_CB UNMAP_CB Called right before an element is unmapped.
        /// Callback int function(Ihandle *ih); [in C] ih:unmap_cb() -> (ret: number)
        /// [in Lua] ih: identifier of the element that activated the event.
        /// Affects All that have a native representation.
        pub fn setUnmapCallback(self: *Initializer, callback: ?OnUnmapFn) Initializer {
            const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setLDestroyCallback(self: *Initializer, callback: ?OnLDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setPostMessageCallback(self: *Initializer, callback: ?OnPostMessageFn) Initializer {
            const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }
    };

    pub fn setStrAttribute(self: *Self, attribute: [:0]const u8, arg: [:0]const u8) void {
        c.setStrAttribute(self, attribute, .{}, arg);
    }

    pub fn getStrAttribute(self: *Self, attribute: [:0]const u8) [:0]const u8 {
        return c.getStrAttribute(self, attribute, .{});
    }

    pub fn setIntAttribute(self: *Self, attribute: [:0]const u8, arg: i32) void {
        c.setIntAttribute(self, attribute, .{}, arg);
    }

    pub fn getIntAttribute(self: *Self, attribute: [:0]const u8) i32 {
        return c.getIntAttribute(self, attribute, .{});
    }

    pub fn setBoolAttribute(self: *Self, attribute: [:0]const u8, arg: bool) void {
        c.setBoolAttribute(self, attribute, .{}, arg);
    }

    pub fn getBoolAttribute(self: *Self, attribute: [:0]const u8) bool {
        return c.getBoolAttribute(self, attribute, .{});
    }

    pub fn getPtrAttribute(handle: *Self, comptime T: type, attribute: [:0]const u8) ?*T {
        return c.getPtrAttribute(T, handle, attribute, .{});
    }

    pub fn setPtrAttribute(handle: *Self, comptime T: type, attribute: [:0]const u8, value: ?*T) void {
        c.setPtrAttribute(T, handle, attribute, .{}, value);
    }

    ///
    /// Creates an interface element given its class name and parameters.
    /// After creation the element still needs to be attached to a container and mapped to the native system so it can be visible.
    pub fn init() Initializer {
        var handle = c.create(Self);

        if (handle) |valid| {
            return .{
                .ref = @ptrCast(*Self, valid),
            };
        } else {
            return .{ .ref = undefined, .last_error = Error.NotInitialized };
        }
    }

    /// 
    /// Destroys an interface element and all its children.
    /// Only dialogs, timers, popup menus and images should be normally destroyed, but detached elements can also be destroyed.        
    pub fn deinit(self: *Self) void {
        c.destroy(self);
    }

    ///
    /// Adds a tuple of children
    pub fn appendChildren(self: *Self, tuple: anytype) !void {
        try Impl(Self).appendChildren(self, tuple);
    }

    ///
    /// Appends a child on this container
    /// child must be an Element or
    pub fn appendChild(self: *Self, child: anytype) !void {
        try Impl(Self).appendChild(self, child);
    }

    ///
    /// Returns a iterator for children elements.
    pub fn children(self: *Self) ChildrenIterator {
        return ChildrenIterator.init(self);
    }

    ///
    ///
    pub fn getDialog(self: *Self) ?*iup.Dialog {
        if (c.IupGetDialog(c.getHandle(self))) |handle| {
            return c.fromHandle(iup.Dialog, handle);
        } else {
            return null;
        }
    }

    ///
    /// Returns the the child element that has the NAME attribute equals to the given value on the same dialog hierarchy.
    /// Works also for children of a menu that is associated with a dialog.
    pub fn getDialogChild(self: *Self, byName: [:0]const u8) ?Element {
        var child = c.IupGetDialogChild(c.getHandle(self), c.toCStr(byName)) orelse return null;
        var className = c.fromCStr(c.IupGetClassName(child));

        return Element.fromClassName(className, child);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog.
    /// To be used after changing size attributes, or attributes that affect the size of the control. Can be used for any element inside a dialog, but the layout of the dialog and all controls will be updated. It can change the layout of all the controls inside the dialog because of the dynamic layout positioning.
    pub fn refresh(self: *Self) void {
        try Impl(Self).refresh(self);
    }

    pub fn getHandleName(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "HANDLENAME", .{});
    }

    pub fn setHandleName(self: *Self, arg: [:0]const u8) void {
        c.setHandle(self, arg);
    }

    pub fn getFrameTime(self: *Self) i32 {
        return c.getIntAttribute(self, "FRAMETIME", .{});
    }

    pub fn setFrameTime(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "FRAMETIME", .{}, arg);
    }


    /// 
    /// BACKCOLOR (non inheritable): background color of the bar handler.
    /// If not defined it will use the background color of the native parent.
    /// (since 3.9)
    pub fn getBackColor(self: *Self) ?iup.Rgb {
        return c.getRgb(self, "BACKCOLOR", .{});
    }


    /// 
    /// BACKCOLOR (non inheritable): background color of the bar handler.
    /// If not defined it will use the background color of the native parent.
    /// (since 3.9)
    pub fn setBackColor(self: *Self, rgb: iup.Rgb) void {
        c.setRgb(self, "BACKCOLOR", .{}, rgb);
    }

    pub fn getMaxSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "MAXSIZE", .{});
        return Size.parse(str);
    }

    pub fn setMaxSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "MAXSIZE", .{}, value);
    }


    /// 
    /// TITLEIMAGE (non inheritable): title image, shown in the bar handler near
    /// the expand/collapse button.
    /// When set it will reset TITLE (image and text title are mutually exclusive).
    /// Shown only when BARPOSITION=TOP.
    /// (since 3.14)
    pub fn getTitleImage(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "TITLEIMAGE", .{});
    }


    /// 
    /// TITLEIMAGE (non inheritable): title image, shown in the bar handler near
    /// the expand/collapse button.
    /// When set it will reset TITLE (image and text title are mutually exclusive).
    /// Shown only when BARPOSITION=TOP.
    /// (since 3.14)
    pub fn setTitleImage(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "TITLEIMAGE", .{}, arg);
    }

    pub fn getPosition(self: *Self) iup.XYPos {
        var str = c.getStrAttribute(self, "POSITION", .{});
        return iup.XYPos.parse(str, ',');
    }

    pub fn setPosition(self: *Self, x: i32, y: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
        c.setStrAttribute(self, "POSITION", .{}, value);
    }

    pub fn getCanFocus(self: *Self) bool {
        return c.getBoolAttribute(self, "CANFOCUS", .{});
    }

    pub fn setCanFocus(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "CANFOCUS", .{}, arg);
    }

    pub fn getVisible(self: *Self) bool {
        return c.getBoolAttribute(self, "VISIBLE", .{});
    }

    pub fn setVisible(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "VISIBLE", .{}, arg);
    }


    /// 
    /// IMAGE (non inheritable): image name to replace the arrow image by a custom
    /// image when STATE=CLOSE.
    /// Works only when BARPOSITION=TOP.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// See also IupImage.
    /// (since 3.11)
    pub fn getImage(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "IMAGE", .{});
    }


    /// 
    /// IMAGE (non inheritable): image name to replace the arrow image by a custom
    /// image when STATE=CLOSE.
    /// Works only when BARPOSITION=TOP.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// See also IupImage.
    /// (since 3.11)
    pub fn setImage(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "IMAGE", .{}, arg);
    }


    /// 
    /// HIGHCOLOR (non inheritable): title text color when highlighted.
    /// Works only when TITLEEXPAND=Yes.
    /// Defaults to the FORECOLOR if not defined.
    /// (since 3.14)
    pub fn getHighColor(self: *Self) ?iup.Rgb {
        return c.getRgb(self, "HIGHCOLOR", .{});
    }


    /// 
    /// HIGHCOLOR (non inheritable): title text color when highlighted.
    /// Works only when TITLEEXPAND=Yes.
    /// Defaults to the FORECOLOR if not defined.
    /// (since 3.14)
    pub fn setHighColor(self: *Self, rgb: iup.Rgb) void {
        c.setRgb(self, "HIGHCOLOR", .{}, rgb);
    }

    pub fn getTheme(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "THEME", .{});
    }

    pub fn setTheme(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "THEME", .{}, arg);
    }


    /// 
    /// EXPAND (non inheritable): the default value is "YES".
    pub fn getExpand(self: *Self) ?Expand {
        var ret = c.getStrAttribute(self, "EXPAND", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("HORIZONTAL", ret)) return .Horizontal;
        if (std.ascii.eqlIgnoreCase("VERTICAL", ret)) return .Vertical;
        if (std.ascii.eqlIgnoreCase("HORIZONTALFREE", ret)) return .HorizontalFree;
        if (std.ascii.eqlIgnoreCase("VERTICALFREE", ret)) return .VerticalFree;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }


    /// 
    /// EXPAND (non inheritable): the default value is "YES".
    pub fn setExpand(self: *Self, arg: ?Expand) void {
        if (arg) |value| switch (value) {
            .Yes => c.setStrAttribute(self, "EXPAND", .{}, "YES"),
            .Horizontal => c.setStrAttribute(self, "EXPAND", .{}, "HORIZONTAL"),
            .Vertical => c.setStrAttribute(self, "EXPAND", .{}, "VERTICAL"),
            .HorizontalFree => c.setStrAttribute(self, "EXPAND", .{}, "HORIZONTALFREE"),
            .VerticalFree => c.setStrAttribute(self, "EXPAND", .{}, "VERTICALFREE"),
            .No => c.setStrAttribute(self, "EXPAND", .{}, "NO"),
        } else {
            c.clearAttribute(self, "EXPAND", .{});
        }
    }

    pub fn getSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "SIZE", .{});
        return Size.parse(str);
    }

    pub fn setSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "SIZE", .{}, value);
    }


    /// 
    /// WID (read-only): returns -1 if mapped.
    pub fn getWId(self: *Self) i32 {
        return c.getIntAttribute(self, "WID", .{});
    }

    pub fn getFontSize(self: *Self) i32 {
        return c.getIntAttribute(self, "FONTSIZE", .{});
    }

    pub fn setFontSize(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "FONTSIZE", .{}, arg);
    }

    pub fn getNaturalSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "NATURALSIZE", .{});
        return Size.parse(str);
    }

    pub fn getUserSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "USERSIZE", .{});
        return Size.parse(str);
    }

    pub fn setUserSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "USERSIZE", .{}, value);
    }


    /// 
    /// TITLE (non inheritable): title text, shown in the bar handler near the
    /// expand/collapse button.
    /// When set it will reset TITLEIMAGE.
    /// Shown only when BARPOSITION=TOP.
    /// When the TITLE is defined and BARPOSITION=TOP then the expand/collapse
    /// button is left aligned.
    /// In all other situations the expand/collapse button is centered.
    pub fn getTitle(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "TITLE", .{});
    }


    /// 
    /// TITLE (non inheritable): title text, shown in the bar handler near the
    /// expand/collapse button.
    /// When set it will reset TITLEIMAGE.
    /// Shown only when BARPOSITION=TOP.
    /// When the TITLE is defined and BARPOSITION=TOP then the expand/collapse
    /// button is left aligned.
    /// In all other situations the expand/collapse button is centered.
    pub fn setTitle(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "TITLE", .{}, arg);
    }

    pub fn getPropagateFocus(self: *Self) bool {
        return c.getBoolAttribute(self, "PROPAGATEFOCUS", .{});
    }

    pub fn setPropagateFocus(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "PROPAGATEFOCUS", .{}, arg);
    }

    pub fn getFloating(self: *Self) ?Floating {
        var ret = c.getStrAttribute(self, "FLOATING", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("IGNORE", ret)) return .Ignore;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }

    pub fn setFloating(self: *Self, arg: ?Floating) void {
        if (arg) |value| switch (value) {
            .Yes => c.setStrAttribute(self, "FLOATING", .{}, "YES"),
            .Ignore => c.setStrAttribute(self, "FLOATING", .{}, "IGNORE"),
            .No => c.setStrAttribute(self, "FLOATING", .{}, "NO"),
        } else {
            c.clearAttribute(self, "FLOATING", .{});
        }
    }

    pub fn getNormalizerGroup(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "NORMALIZERGROUP", .{});
    }

    pub fn setNormalizerGroup(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "NORMALIZERGROUP", .{}, arg);
    }

    pub fn getRasterSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "RASTERSIZE", .{});
        return Size.parse(str);
    }

    pub fn setRasterSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "RASTERSIZE", .{}, value);
    }


    /// 
    /// BARSIZE (non inheritable): controls the size of the bar handler.
    /// Default: the height or width that fits all its internal elements according
    /// to BARPOSITION.
    pub fn getBarSize(self: *Self) i32 {
        return c.getIntAttribute(self, "BARSIZE", .{});
    }


    /// 
    /// BARSIZE (non inheritable): controls the size of the bar handler.
    /// Default: the height or width that fits all its internal elements according
    /// to BARPOSITION.
    pub fn setBarSize(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "BARSIZE", .{}, arg);
    }


    /// 
    /// FRAMECOLOR (non inheritable): frame line color.
    /// Default: the global attribute DLGFGCOLOR.
    /// (since 3.23)
    pub fn getFrameColor(self: *Self) ?iup.Rgb {
        return c.getRgb(self, "FRAMECOLOR", .{});
    }


    /// 
    /// FRAMECOLOR (non inheritable): frame line color.
    /// Default: the global attribute DLGFGCOLOR.
    /// (since 3.23)
    pub fn setFrameColor(self: *Self, rgb: iup.Rgb) void {
        c.setRgb(self, "FRAMECOLOR", .{}, rgb);
    }

    pub fn getFontFace(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "FONTFACE", .{});
    }

    pub fn setFontFace(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "FONTFACE", .{}, arg);
    }

    pub fn getName(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "NAME", .{});
    }

    pub fn setName(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "NAME", .{}, arg);
    }


    /// 
    /// STATE (non inheritable): Show or hide the container elements.
    /// Possible values: "OPEN" (expanded) or "CLOSE" (collapsed).
    /// Default: OPEN.
    /// Setting this attribute will automatically change the layout of the entire
    /// dialog so the child can be recomposed.
    pub fn getState(self: *Self) ?State {
        var ret = c.getStrAttribute(self, "STATE", .{});

        if (std.ascii.eqlIgnoreCase("OPEN", ret)) return .Open;
        if (std.ascii.eqlIgnoreCase("CLOSED", ret)) return .Closed;
        return null;
    }


    /// 
    /// STATE (non inheritable): Show or hide the container elements.
    /// Possible values: "OPEN" (expanded) or "CLOSE" (collapsed).
    /// Default: OPEN.
    /// Setting this attribute will automatically change the layout of the entire
    /// dialog so the child can be recomposed.
    pub fn setState(self: *Self, arg: ?State) void {
        if (arg) |value| switch (value) {
            .Open => c.setStrAttribute(self, "STATE", .{}, "OPEN"),
            .Closed => c.setStrAttribute(self, "STATE", .{}, "CLOSED"),
        } else {
            c.clearAttribute(self, "STATE", .{});
        }
    }

    pub fn getActive(self: *Self) bool {
        return c.getBoolAttribute(self, "ACTIVE", .{});
    }

    pub fn setActive(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "ACTIVE", .{}, arg);
    }

    pub fn getImageHighlight(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "IMAGEHIGHLIGHT", .{});
    }

    pub fn setImageHighlight(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "IMAGEHIGHLIGHT", .{}, arg);
    }

    pub fn getExpandWeight(self: *Self) f64 {
        return c.getDoubleAttribute(self, "EXPANDWEIGHT", .{});
    }

    pub fn setExpandWeight(self: *Self, arg: f64) void {
        c.setDoubleAttribute(self, "EXPANDWEIGHT", .{}, arg);
    }

    pub fn getMinSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "MINSIZE", .{});
        return Size.parse(str);
    }

    pub fn setMinSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "MINSIZE", .{}, value);
    }

    pub fn getNTheme(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "NTHEME", .{});
    }

    pub fn setNTheme(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "NTHEME", .{}, arg);
    }


    /// 
    /// ANIMATION (non inheritable): enable animation during open/close.
    /// Works only for BARPOSITION=TOP and does not works for AUTOSHOW.
    /// Also the child must be a native container like IupTabs, IupFrame,
    /// IupBackgroundBox, or IupScrollBox, or it will not work accordantly.
    /// Values can be SLIDE (child controls slide down), CURTAIN (child controls
    /// appears as if a curtain is being pulled) or NO.
    /// Default: NO.
    /// ((since 3.14)
    pub fn getAnimation(self: *Self) ?Animation {
        var ret = c.getStrAttribute(self, "ANIMATION", .{});

        if (std.ascii.eqlIgnoreCase("SLIDE", ret)) return .Slide;
        if (std.ascii.eqlIgnoreCase("CURTAIN", ret)) return .Curtain;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }


    /// 
    /// ANIMATION (non inheritable): enable animation during open/close.
    /// Works only for BARPOSITION=TOP and does not works for AUTOSHOW.
    /// Also the child must be a native container like IupTabs, IupFrame,
    /// IupBackgroundBox, or IupScrollBox, or it will not work accordantly.
    /// Values can be SLIDE (child controls slide down), CURTAIN (child controls
    /// appears as if a curtain is being pulled) or NO.
    /// Default: NO.
    /// ((since 3.14)
    pub fn setAnimation(self: *Self, arg: ?Animation) void {
        if (arg) |value| switch (value) {
            .Slide => c.setStrAttribute(self, "ANIMATION", .{}, "SLIDE"),
            .Curtain => c.setStrAttribute(self, "ANIMATION", .{}, "CURTAIN"),
            .No => c.setStrAttribute(self, "ANIMATION", .{}, "NO"),
        } else {
            c.clearAttribute(self, "ANIMATION", .{});
        }
    }

    pub fn getCharSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "CHARSIZE", .{});
        return Size.parse(str);
    }

    pub fn getClientSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "CLIENTSIZE", .{});
        return Size.parse(str);
    }

    pub fn getClientOffset(self: *Self) Size {
        var str = c.getStrAttribute(self, "CLIENTOFFSET", .{});
        return Size.parse(str);
    }


    /// 
    /// FORECOLOR (non inheritable): title text color.
    /// Default: the global attribute DLGFGCOLOR.
    /// (since 3.9)
    pub fn getForeColor(self: *Self) ?iup.Rgb {
        return c.getRgb(self, "FORECOLOR", .{});
    }


    /// 
    /// FORECOLOR (non inheritable): title text color.
    /// Default: the global attribute DLGFGCOLOR.
    /// (since 3.9)
    pub fn setForeColor(self: *Self, rgb: iup.Rgb) void {
        c.setRgb(self, "FORECOLOR", .{}, rgb);
    }

    pub fn getFontStyle(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "FONTSTYLE", .{});
    }

    pub fn setFontStyle(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "FONTSTYLE", .{}, arg);
    }


    /// 
    /// FRAMEWIDTH (non inheritable): frame line width.
    /// Default: 1.
    /// (since 3.23)
    pub fn getFrameWidth(self: *Self) i32 {
        return c.getIntAttribute(self, "FRAMEWIDTH", .{});
    }


    /// 
    /// FRAMEWIDTH (non inheritable): frame line width.
    /// Default: 1.
    /// (since 3.23)
    pub fn setFrameWidth(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "FRAMEWIDTH", .{}, arg);
    }


    /// 
    /// FRAME (non inheritable): enables the frame line around the bar area.
    /// Default: No.
    /// (since 3.23)
    pub fn getFrame(self: *Self) bool {
        return c.getBoolAttribute(self, "FRAME", .{});
    }


    /// 
    /// FRAME (non inheritable): enables the frame line around the bar area.
    /// Default: No.
    /// (since 3.23)
    pub fn setFrame(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "FRAME", .{}, arg);
    }


    /// 
    /// FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE,
    /// MAXSIZE, THEME: also accepted.
    pub fn getFont(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "FONT", .{});
    }


    /// 
    /// FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE,
    /// MAXSIZE, THEME: also accepted.
    pub fn setFont(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "FONT", .{}, arg);
    }

    /// 
    /// ACTION ACTION Action generated when the element is activated.
    /// Affects each element differently.
    /// Callback int function(Ihandle *ih); [in C] ih:action() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// In some elements, this callback may receive more parameters, apart from ih.
    /// Please refer to each element's documentation.
    /// Affects IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    /// IupToggle
    pub fn setActionCallback(self: *Self, callback: ?OnActionFn) void {
        const Handler = CallbackHandler(Self, OnActionFn, "ACTION");
        Handler.setCallback(self, callback);
    }

    /// 
    /// EXTRABUTTON_CB: Action generated when any mouse button is pressed or released.
    /// (since 3.11) int function(Ihandle* ih, int button, int pressed); [in C]
    /// ih:extrabutton_cb(button, pressed: number) -> (ret: number) [in Lua] ih:
    /// identifies the element that activated the event.
    /// button: identifies the extra button.
    /// can be 1, 2 or 3.
    /// (this is not the same as BUTTON_CB)pressed: indicates the state of the
    /// button: 0 - mouse button was released; 1 - mouse button was pressed.
    pub fn setExtraButtonCallback(self: *Self, callback: ?OnExtraButtonFn) void {
        const Handler = CallbackHandler(Self, OnExtraButtonFn, "EXTRABUTTON_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// OPENCLOSE_CB: Action generated before the expander state is interactively changed.
    /// (Since 3.11) int function(Ihandle* ih, int state); [in
    /// C]ih:openclose_cb(state: number) -> (ret: number) [in Lua]
    pub fn setOpenCloseCallback(self: *Self, callback: ?OnOpenCloseFn) void {
        const Handler = CallbackHandler(Self, OnOpenCloseFn, "OPENCLOSE_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// MAP_CB MAP_CB Called right after an element is mapped and its attributes
    /// updated in IupMap.
    /// When the element is a dialog, it is called after the layout is updated.
    /// For all other elements is called before the layout is updated, so the
    /// element current size will still be 0x0 during MAP_CB (since 3.14).
    /// Callback int function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub fn setMapCallback(self: *Self, callback: ?OnMapFn) void {
        const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// DESTROY_CB DESTROY_CB Called right before an element is destroyed.
    /// Callback int function(Ihandle *ih); [in C] ih:destroy_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Notes If the dialog is visible then it is hidden before it is destroyed.
    /// The callback will be called right after it is hidden.
    /// The callback will be called before all other destroy procedures.
    /// For instance, if the element has children then it is called before the
    /// children are destroyed.
    /// For language binding implementations use the callback name "LDESTROY_CB" to
    /// release memory allocated by the binding for the element.
    /// Also the callback will be called before the language callback.
    /// Affects All.
    pub fn setDestroyCallback(self: *Self, callback: ?OnDestroyFn) void {
        const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    /// Callback int function(Ihandle *ih); [in C] ih:unmap_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub fn setUnmapCallback(self: *Self, callback: ?OnUnmapFn) void {
        const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setLDestroyCallback(self: *Self, callback: ?OnLDestroyFn) void {
        const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setPostMessageCallback(self: *Self, callback: ?OnPostMessageFn) void {
        const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
        Handler.setCallback(self, callback);
    }
};

test "Expander HandleName" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setHandleName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHandleName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander FrameTime" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFrameTime(42).unwrap());
    defer item.deinit();

    var ret = item.getFrameTime();

    try std.testing.expect(ret == 42);
}

test "Expander BackColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setBackColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getBackColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Expander MaxSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setMaxSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMaxSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander TitleImage" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setTitleImage("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTitleImage();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander Position" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setPosition(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getPosition();

    try std.testing.expect(ret.x == 9 and ret.y == 10);
}

test "Expander CanFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setCanFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getCanFocus();

    try std.testing.expect(ret == true);
}

test "Expander Visible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setVisible(true).unwrap());
    defer item.deinit();

    var ret = item.getVisible();

    try std.testing.expect(ret == true);
}

test "Expander Image" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setImage("Hello").unwrap());
    defer item.deinit();

    var ret = item.getImage();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander HighColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setHighColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getHighColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Expander Theme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander Expand" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setExpand(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getExpand();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "Expander Size" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander FontSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFontSize(42).unwrap());
    defer item.deinit();

    var ret = item.getFontSize();

    try std.testing.expect(ret == 42);
}

test "Expander UserSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setUserSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getUserSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander Title" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setTitle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTitle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander PropagateFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setPropagateFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getPropagateFocus();

    try std.testing.expect(ret == true);
}

test "Expander Floating" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFloating(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getFloating();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "Expander NormalizerGroup" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setNormalizerGroup("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNormalizerGroup();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander RasterSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setRasterSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getRasterSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander BarSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setBarSize(42).unwrap());
    defer item.deinit();

    var ret = item.getBarSize();

    try std.testing.expect(ret == 42);
}

test "Expander FrameColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFrameColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getFrameColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Expander FontFace" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFontFace("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontFace();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander Name" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander State" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setState(.Open).unwrap());
    defer item.deinit();

    var ret = item.getState();

    try std.testing.expect(ret != null and ret.? == .Open);
}

test "Expander Active" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setActive(true).unwrap());
    defer item.deinit();

    var ret = item.getActive();

    try std.testing.expect(ret == true);
}

test "Expander ImageHighlight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setImageHighlight("Hello").unwrap());
    defer item.deinit();

    var ret = item.getImageHighlight();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander ExpandWeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setExpandWeight(3.14).unwrap());
    defer item.deinit();

    var ret = item.getExpandWeight();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Expander MinSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setMinSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMinSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander NTheme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setNTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander Animation" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setAnimation(.Slide).unwrap());
    defer item.deinit();

    var ret = item.getAnimation();

    try std.testing.expect(ret != null and ret.? == .Slide);
}

test "Expander ForeColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setForeColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getForeColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Expander FontStyle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFontStyle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontStyle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander FrameWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFrameWidth(42).unwrap());
    defer item.deinit();

    var ret = item.getFrameWidth();

    try std.testing.expect(ret == 42);
}

test "Expander Frame" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFrame(true).unwrap());
    defer item.deinit();

    var ret = item.getFrame();

    try std.testing.expect(ret == true);
}

test "Expander Font" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFont("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFont();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}
