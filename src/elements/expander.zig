// This code was generated by a tool.
// IUP Metadata Code Generator
// https://github.com/batiati/IUPMetadata
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.

const std = @import("std");

const interop = @import("../interop.zig");
const iup = @import("../iup.zig");

const Impl = @import("../impl.zig").Impl;
const CallbackHandler = @import("../callback_handler.zig").CallbackHandler;

const debug = std.debug;
const trait = std.meta.trait;

const Element = iup.Element;
const Handle = iup.Handle;
const Error = iup.Error;
const ChildrenIterator = iup.ChildrenIterator;
const Size = iup.Size;
const Margin = iup.Margin;

///
/// Creates a void container that can interactively show or hide its child.
/// It does not have a native representation, but it contains also several
/// elements to implement the bar handler.
pub const Expander = opaque {
    pub const CLASS_NAME = "expander";
    pub const NATIVE_TYPE = iup.NativeType.Void;
    const Self = @This();

    ///
    /// ACTION ACTION Action generated when the element is activated.
    /// Affects each element differently.
    /// Callback int function(Ihandle *ih); [in C] ih:action() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// In some elements, this callback may receive more parameters, apart from ih.
    /// Please refer to each element's documentation.
    /// Affects IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    /// IupToggle
    pub const OnActionFn = fn (self: *Self) anyerror!void;

    ///
    /// EXTRABUTTON_CB: Action generated when any mouse button is pressed or released.
    /// (since 3.11) int function(Ihandle* ih, int button, int pressed); [in C]
    /// ih:extrabutton_cb(button, pressed: number) -> (ret: number) [in Lua] ih:
    /// identifies the element that activated the event.
    /// button: identifies the extra button.
    /// can be 1, 2 or 3.
    /// (this is not the same as BUTTON_CB)pressed: indicates the state of the
    /// button: 0 - mouse button was released; 1 - mouse button was pressed.
    pub const OnExtraButtonFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    ///
    /// OPENCLOSE_CB: Action generated before the expander state is interactively changed.
    /// (Since 3.11) int function(Ihandle* ih, int state); [in
    /// C]ih:openclose_cb(state: number) -> (ret: number) [in Lua]
    pub const OnOpenCloseFn = fn (self: *Self, arg0: i32) anyerror!void;

    ///
    /// MAP_CB MAP_CB Called right after an element is mapped and its attributes
    /// updated in IupMap.
    /// When the element is a dialog, it is called after the layout is updated.
    /// For all other elements is called before the layout is updated, so the
    /// element current size will still be 0x0 during MAP_CB (since 3.14).
    /// Callback int function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub const OnMapFn = fn (self: *Self) anyerror!void;

    ///
    /// DESTROY_CB DESTROY_CB Called right before an element is destroyed.
    /// Callback int function(Ihandle *ih); [in C] ih:destroy_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Notes If the dialog is visible then it is hidden before it is destroyed.
    /// The callback will be called right after it is hidden.
    /// The callback will be called before all other destroy procedures.
    /// For instance, if the element has children then it is called before the
    /// children are destroyed.
    /// For language binding implementations use the callback name "LDESTROY_CB" to
    /// release memory allocated by the binding for the element.
    /// Also the callback will be called before the language callback.
    /// Affects All.
    pub const OnDestroyFn = fn (self: *Self) anyerror!void;

    ///
    /// UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    /// Callback int function(Ihandle *ih); [in C] ih:unmap_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub const OnUnmapFn = fn (self: *Self) anyerror!void;

    pub const OnLDestroyFn = fn (self: *Self) anyerror!void;

    pub const OnPostMessageFn = fn (self: *Self, arg0: [:0]const u8, arg1: i32, arg2: f64, arg3: ?*anyopaque) anyerror!void;

    ///
    /// EXPAND (non inheritable): the default value is "YES".
    pub const Expand = enum {
        Yes,
        Horizontal,
        Vertical,
        HorizontalFree,
        VerticalFree,
        No,
    };

    pub const Floating = enum {
        Yes,
        Ignore,
        No,
    };
    ///
    /// STATE (non inheritable): Show or hide the container elements.
    /// Possible values: "OPEN" (expanded) or "CLOSE" (collapsed).
    /// Default: OPEN.
    /// Setting this attribute will automatically change the layout of the entire
    /// dialog so the child can be recomposed.
    pub const State = enum {
        Open,
        Closed,
    };
    ///
    /// ANIMATION (non inheritable): enable animation during open/close.
    /// Works only for BARPOSITION=TOP and does not works for AUTOSHOW.
    /// Also the child must be a native container like IupTabs, IupFrame,
    /// IupBackgroundBox, or IupScrollBox, or it will not work accordantly.
    /// Values can be SLIDE (child controls slide down), CURTAIN (child controls
    /// appears as if a curtain is being pulled) or NO.
    /// Default: NO.
    /// ((since 3.14)
    pub const Animation = enum {
        Slide,
        Curtain,
        No,
    };

    pub const Initializer = struct {
        last_error: ?anyerror = null,
        ref: *Self,

        ///
        /// Returns a pointer to IUP element or an error.
        /// Only top-level or detached elements needs to be unwraped,
        pub fn unwrap(self: Initializer) !*Self {
            if (self.last_error) |e| {
                return e;
            } else {
                return self.ref;
            }
        }

        ///
        /// Captures a reference into a external variable
        /// Allows to capture some references even using full declarative API
        pub fn capture(self: Initializer, ref: **Self) Initializer {
            ref.* = self.ref;
            return self;
        }

        pub fn setStrAttribute(self: Initializer, attributeName: [:0]const u8, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            Self.setStrAttribute(self.ref, attributeName, arg);
            return self;
        }

        pub fn setIntAttribute(self: Initializer, attributeName: [:0]const u8, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            Self.setIntAttribute(self.ref, attributeName, arg);
            return self;
        }

        pub fn setBoolAttribute(self: Initializer, attributeName: [:0]const u8, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            Self.setBoolAttribute(self.ref, attributeName, arg);
            return self;
        }

        pub fn setPtrAttribute(self: Initializer, comptime T: type, attributeName: [:0]const u8, value: ?*T) Initializer {
            if (self.last_error) |_| return self;
            Self.setPtrAttribute(self.ref, T, attributeName, value);
            return self;
        }

        pub fn setHandle(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setHandle(self.ref, arg);
            return self;
        }

        pub fn setChildren(self: Initializer, tuple: anytype) Initializer {
            if (self.last_error) |_| return self;

            Self.appendChildren(self.ref, tuple) catch |err| {
                return .{
                    .ref = self.ref,
                    .last_error = err,
                };
            };

            return self;
        }

        pub fn setHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "HANDLENAME", .{}, arg);
            return self;
        }

        pub fn setFrameTime(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "FRAMETIME", .{}, arg);
            return self;
        }

        pub fn setImageOpenHighlight(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEOPENHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageOpenHighlightHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEOPENHIGHLIGHT", .{}, arg);
            return self;
        }

        pub fn setImageExtraPress1(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEEXTRAPRESS1", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageExtraPress1HandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEEXTRAPRESS1", .{}, arg);
            return self;
        }

        pub fn setImageExtraPress2(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEEXTRAPRESS2", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageExtraPress2HandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEEXTRAPRESS2", .{}, arg);
            return self;
        }

        pub fn setImageExtraPress3(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEEXTRAPRESS3", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageExtraPress3HandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEEXTRAPRESS3", .{}, arg);
            return self;
        }

        ///
        /// BACKCOLOR (non inheritable): background color of the bar handler.
        /// If not defined it will use the background color of the native parent.
        /// (since 3.9)
        pub fn setBackColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "BACKCOLOR", .{}, rgb);
            return self;
        }

        pub fn setMaxSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "MAXSIZE", .{}, value);
            return self;
        }

        ///
        /// TITLEIMAGE (non inheritable): title image, shown in the bar handler near
        /// the expand/collapse button.
        /// When set it will reset TITLE (image and text title are mutually exclusive).
        /// Shown only when BARPOSITION=TOP.
        /// (since 3.14)
        pub fn setTitleImage(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "TITLEIMAGE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setTitleImageHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TITLEIMAGE", .{}, arg);
            return self;
        }

        pub fn setPosition(self: Initializer, x: i32, y: i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
            interop.setStrAttribute(self.ref, "POSITION", .{}, value);
            return self;
        }

        pub fn setImageExtra1(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEEXTRA1", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageExtra1HandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEEXTRA1", .{}, arg);
            return self;
        }

        pub fn setImageExtra2(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEEXTRA2", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageExtra2HandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEEXTRA2", .{}, arg);
            return self;
        }

        pub fn setImageExtra3(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEEXTRA3", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageExtra3HandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEEXTRA3", .{}, arg);
            return self;
        }

        pub fn setCanFocus(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "CANFOCUS", .{}, arg);
            return self;
        }

        pub fn setVisible(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "VISIBLE", .{}, arg);
            return self;
        }

        ///
        /// IMAGE (non inheritable): image name to replace the arrow image by a custom
        /// image when STATE=CLOSE.
        /// Works only when BARPOSITION=TOP.
        /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
        /// See also IupImage.
        /// (since 3.11)
        pub fn setImage(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGE", .{}, arg);
            return self;
        }

        ///
        /// HIGHCOLOR (non inheritable): title text color when highlighted.
        /// Works only when TITLEEXPAND=Yes.
        /// Defaults to the FORECOLOR if not defined.
        /// (since 3.14)
        pub fn setHighColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "HIGHCOLOR", .{}, rgb);
            return self;
        }

        pub fn setTheme(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "THEME", .{}, arg);
            return self;
        }

        ///
        /// EXPAND (non inheritable): the default value is "YES".
        pub fn setExpand(self: Initializer, arg: ?Expand) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .Yes => interop.setStrAttribute(self.ref, "EXPAND", .{}, "YES"),
                .Horizontal => interop.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTAL"),
                .Vertical => interop.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICAL"),
                .HorizontalFree => interop.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTALFREE"),
                .VerticalFree => interop.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICALFREE"),
                .No => interop.setStrAttribute(self.ref, "EXPAND", .{}, "NO"),
            } else {
                interop.clearAttribute(self.ref, "EXPAND", .{});
            }
            return self;
        }

        pub fn setSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "SIZE", .{}, value);
            return self;
        }

        pub fn setFontSize(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "FONTSIZE", .{}, arg);
            return self;
        }

        pub fn setUserSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "USERSIZE", .{}, value);
            return self;
        }

        pub fn setTitleImageOpenHighlight(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "TITLEIMAGEOPENHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setTitleImageOpenHighlightHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TITLEIMAGEOPENHIGHLIGHT", .{}, arg);
            return self;
        }

        ///
        /// TITLE (non inheritable): title text, shown in the bar handler near the
        /// expand/collapse button.
        /// When set it will reset TITLEIMAGE.
        /// Shown only when BARPOSITION=TOP.
        /// When the TITLE is defined and BARPOSITION=TOP then the expand/collapse
        /// button is left aligned.
        /// In all other situations the expand/collapse button is centered.
        pub fn setTitle(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TITLE", .{}, arg);
            return self;
        }

        pub fn setPropagateFocus(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "PROPAGATEFOCUS", .{}, arg);
            return self;
        }

        pub fn setFloating(self: Initializer, arg: ?Floating) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .Yes => interop.setStrAttribute(self.ref, "FLOATING", .{}, "YES"),
                .Ignore => interop.setStrAttribute(self.ref, "FLOATING", .{}, "IGNORE"),
                .No => interop.setStrAttribute(self.ref, "FLOATING", .{}, "NO"),
            } else {
                interop.clearAttribute(self.ref, "FLOATING", .{});
            }
            return self;
        }

        pub fn setNormalizerGroup(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NORMALIZERGROUP", .{}, arg);
            return self;
        }

        pub fn setRasterSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "RASTERSIZE", .{}, value);
            return self;
        }

        pub fn setImageExtraHighlight1(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEEXTRAHIGHLIGHT1", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageExtraHighlight1HandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEEXTRAHIGHLIGHT1", .{}, arg);
            return self;
        }

        pub fn setImageExtraHighlight2(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEEXTRAHIGHLIGHT2", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageExtraHighlight2HandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEEXTRAHIGHLIGHT2", .{}, arg);
            return self;
        }

        pub fn setImageExtraHighlight3(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEEXTRAHIGHLIGHT3", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageExtraHighlight3HandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEEXTRAHIGHLIGHT3", .{}, arg);
            return self;
        }

        ///
        /// BARSIZE (non inheritable): controls the size of the bar handler.
        /// Default: the height or width that fits all its internal elements according
        /// to BARPOSITION.
        pub fn setBarSize(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "BARSIZE", .{}, arg);
            return self;
        }

        ///
        /// FRAMECOLOR (non inheritable): frame line color.
        /// Default: the global attribute DLGFGCOLOR.
        /// (since 3.23)
        pub fn setFrameColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "FRAMECOLOR", .{}, rgb);
            return self;
        }

        pub fn setFontFace(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FONTFACE", .{}, arg);
            return self;
        }

        ///
        /// TITLEIMAGEOPEN: image name used when STATE=OPEN.
        /// TITLEIMAGEHIGHLIGHT: image name used when mouse is over the title image and
        /// STATE=CLOSE.TITLEIMAGEOPENHIGHLIGHT: image name used when mouse is over the
        /// title image and STATE=OPEN.
        pub fn setTitleImageOpen(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "TITLEIMAGEOPEN", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setTitleImageOpenHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TITLEIMAGEOPEN", .{}, arg);
            return self;
        }

        pub fn setName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NAME", .{}, arg);
            return self;
        }

        ///
        /// STATE (non inheritable): Show or hide the container elements.
        /// Possible values: "OPEN" (expanded) or "CLOSE" (collapsed).
        /// Default: OPEN.
        /// Setting this attribute will automatically change the layout of the entire
        /// dialog so the child can be recomposed.
        pub fn setState(self: Initializer, arg: ?State) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .Open => interop.setStrAttribute(self.ref, "STATE", .{}, "OPEN"),
                .Closed => interop.setStrAttribute(self.ref, "STATE", .{}, "CLOSED"),
            } else {
                interop.clearAttribute(self.ref, "STATE", .{});
            }
            return self;
        }

        pub fn setActive(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "ACTIVE", .{}, arg);
            return self;
        }

        pub fn setImageHighlight(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageHighlightHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEHIGHLIGHT", .{}, arg);
            return self;
        }

        pub fn setExpandWeight(self: Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self;
            interop.setDoubleAttribute(self.ref, "EXPANDWEIGHT", .{}, arg);
            return self;
        }

        pub fn setMinSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "MINSIZE", .{}, value);
            return self;
        }

        pub fn setTitleImageHighlight(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "TITLEIMAGEHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setTitleImageHighlightHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TITLEIMAGEHIGHLIGHT", .{}, arg);
            return self;
        }

        pub fn setNTheme(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NTHEME", .{}, arg);
            return self;
        }

        ///
        /// EXTRABUTTONS (non inheritable) (creation only): sets the number of extra
        /// image buttons at right when BARPOSITION=TOP.
        /// The maximum number of buttons is 3.
        /// See the EXTRABUTTON_CB callback.
        /// Default: 0.
        /// (since 3.11)
        pub fn setExtraButtons(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "EXTRABUTTONS", .{}, arg);
            return self;
        }

        ///
        /// ANIMATION (non inheritable): enable animation during open/close.
        /// Works only for BARPOSITION=TOP and does not works for AUTOSHOW.
        /// Also the child must be a native container like IupTabs, IupFrame,
        /// IupBackgroundBox, or IupScrollBox, or it will not work accordantly.
        /// Values can be SLIDE (child controls slide down), CURTAIN (child controls
        /// appears as if a curtain is being pulled) or NO.
        /// Default: NO.
        /// ((since 3.14)
        pub fn setAnimation(self: Initializer, arg: ?Animation) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .Slide => interop.setStrAttribute(self.ref, "ANIMATION", .{}, "SLIDE"),
                .Curtain => interop.setStrAttribute(self.ref, "ANIMATION", .{}, "CURTAIN"),
                .No => interop.setStrAttribute(self.ref, "ANIMATION", .{}, "NO"),
            } else {
                interop.clearAttribute(self.ref, "ANIMATION", .{});
            }
            return self;
        }

        ///
        /// FORECOLOR (non inheritable): title text color.
        /// Default: the global attribute DLGFGCOLOR.
        /// (since 3.9)
        pub fn setForeColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "FORECOLOR", .{}, rgb);
            return self;
        }

        pub fn setFontStyle(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FONTSTYLE", .{}, arg);
            return self;
        }

        ///
        /// IMAGEOPEN: image name used when STATE=OPEN.
        /// IMAGEHIGHLIGHT: image name used when mouse is over the bar handler and
        /// STATE=CLOSE.IMAGEOPENHIGHLIGHT: image name used when mouse is over the bar
        /// handler and STATE=OPEN.
        pub fn setImageOpen(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "IMAGEOPEN", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setImageOpenHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IMAGEOPEN", .{}, arg);
            return self;
        }

        ///
        /// FRAMEWIDTH (non inheritable): frame line width.
        /// Default: 1.
        /// (since 3.23)
        pub fn setFrameWidth(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "FRAMEWIDTH", .{}, arg);
            return self;
        }

        ///
        /// FRAME (non inheritable): enables the frame line around the bar area.
        /// Default: No.
        /// (since 3.23)
        pub fn setFrame(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "FRAME", .{}, arg);
            return self;
        }

        ///
        /// FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE,
        /// MAXSIZE, THEME: also accepted.
        pub fn setFont(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FONT", .{}, arg);
            return self;
        }

        ///
        /// TABIMAGEn (non inheritable): image name to be used in the respective tab.
        /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
        /// n starts at 0.
        /// See also IupImage.
        /// In Motif, the image is shown only if TABTITLEn is NULL.
        /// In Windows and Motif set the BGCOLOR attribute before setting the image.
        /// When set after map will update the TABIMAGE attribute on the respective
        /// child (since 3.10).
        /// (since 3.0).
        /// TABIMAGE (non inheritable) (at children only): Same as TABIMAGEn but set in
        /// each child.
        /// Works only if set before the child is added to the tabs.
        pub fn setTabImage(self: Initializer, index: i32, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "TABIMAGE", .{index}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setTabImageHandleName(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TABIMAGE", .{index}, arg);
            return self;
        }

        ///
        /// TABTITLEn (non inheritable): Contains the text to be shown in the
        /// respective tab title.
        /// n starts at 0.
        /// If this value is NULL, it will remain empty.
        /// The "&" character can be used to define a mnemonic, the next character will
        /// be used as key.
        /// Use "&&" to show the "&" character instead on defining a mnemonic.
        /// The button can be activated from any control in the dialog using the
        /// "Alt+key" combination.
        /// (mnemonic support since 3.3).
        /// When set after map will update the TABTITLE attribute on the respective
        /// child (since 3.10).
        /// (since 3.0).
        /// TABTITLE (non inheritable) (at children only): Same as TABTITLEn but set in
        /// each child.
        /// Works only if set before the child is added to the tabs.
        pub fn setTabTitle(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TABTITLE", .{index}, arg);
            return self;
        }

        ///
        /// ACTION ACTION Action generated when the element is activated.
        /// Affects each element differently.
        /// Callback int function(Ihandle *ih); [in C] ih:action() -> (ret: number) [in
        /// Lua] ih: identifier of the element that activated the event.
        /// In some elements, this callback may receive more parameters, apart from ih.
        /// Please refer to each element's documentation.
        /// Affects IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
        /// IupToggle
        pub fn setActionCallback(self: Initializer, callback: ?*const OnActionFn) Initializer {
            const Handler = CallbackHandler(Self, OnActionFn, "ACTION");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        ///
        /// EXTRABUTTON_CB: Action generated when any mouse button is pressed or released.
        /// (since 3.11) int function(Ihandle* ih, int button, int pressed); [in C]
        /// ih:extrabutton_cb(button, pressed: number) -> (ret: number) [in Lua] ih:
        /// identifies the element that activated the event.
        /// button: identifies the extra button.
        /// can be 1, 2 or 3.
        /// (this is not the same as BUTTON_CB)pressed: indicates the state of the
        /// button: 0 - mouse button was released; 1 - mouse button was pressed.
        pub fn setExtraButtonCallback(self: Initializer, callback: ?*const OnExtraButtonFn) Initializer {
            const Handler = CallbackHandler(Self, OnExtraButtonFn, "EXTRABUTTON_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        ///
        /// OPENCLOSE_CB: Action generated before the expander state is interactively changed.
        /// (Since 3.11) int function(Ihandle* ih, int state); [in
        /// C]ih:openclose_cb(state: number) -> (ret: number) [in Lua]
        pub fn setOpenCloseCallback(self: Initializer, callback: ?*const OnOpenCloseFn) Initializer {
            const Handler = CallbackHandler(Self, OnOpenCloseFn, "OPENCLOSE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        ///
        /// MAP_CB MAP_CB Called right after an element is mapped and its attributes
        /// updated in IupMap.
        /// When the element is a dialog, it is called after the layout is updated.
        /// For all other elements is called before the layout is updated, so the
        /// element current size will still be 0x0 during MAP_CB (since 3.14).
        /// Callback int function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
        /// Lua] ih: identifier of the element that activated the event.
        /// Affects All that have a native representation.
        pub fn setMapCallback(self: Initializer, callback: ?*const OnMapFn) Initializer {
            const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        ///
        /// DESTROY_CB DESTROY_CB Called right before an element is destroyed.
        /// Callback int function(Ihandle *ih); [in C] ih:destroy_cb() -> (ret: number)
        /// [in Lua] ih: identifier of the element that activated the event.
        /// Notes If the dialog is visible then it is hidden before it is destroyed.
        /// The callback will be called right after it is hidden.
        /// The callback will be called before all other destroy procedures.
        /// For instance, if the element has children then it is called before the
        /// children are destroyed.
        /// For language binding implementations use the callback name "LDESTROY_CB" to
        /// release memory allocated by the binding for the element.
        /// Also the callback will be called before the language callback.
        /// Affects All.
        pub fn setDestroyCallback(self: Initializer, callback: ?*const OnDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        ///
        /// UNMAP_CB UNMAP_CB Called right before an element is unmapped.
        /// Callback int function(Ihandle *ih); [in C] ih:unmap_cb() -> (ret: number)
        /// [in Lua] ih: identifier of the element that activated the event.
        /// Affects All that have a native representation.
        pub fn setUnmapCallback(self: Initializer, callback: ?*const OnUnmapFn) Initializer {
            const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setLDestroyCallback(self: Initializer, callback: ?*const OnLDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setPostMessageCallback(self: Initializer, callback: ?*const OnPostMessageFn) Initializer {
            const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }
    };

    pub fn setStrAttribute(self: *Self, attribute: [:0]const u8, arg: [:0]const u8) void {
        interop.setStrAttribute(self, attribute, .{}, arg);
    }

    pub fn getStrAttribute(self: *Self, attribute: [:0]const u8) [:0]const u8 {
        return interop.getStrAttribute(self, attribute, .{});
    }

    pub fn setIntAttribute(self: *Self, attribute: [:0]const u8, arg: i32) void {
        interop.setIntAttribute(self, attribute, .{}, arg);
    }

    pub fn getIntAttribute(self: *Self, attribute: [:0]const u8) i32 {
        return interop.getIntAttribute(self, attribute, .{});
    }

    pub fn setBoolAttribute(self: *Self, attribute: [:0]const u8, arg: bool) void {
        interop.setBoolAttribute(self, attribute, .{}, arg);
    }

    pub fn getBoolAttribute(self: *Self, attribute: [:0]const u8) bool {
        return interop.getBoolAttribute(self, attribute, .{});
    }

    pub fn getPtrAttribute(self: *Self, comptime T: type, attribute: [:0]const u8) ?*T {
        return interop.getPtrAttribute(T, self, attribute, .{});
    }

    pub fn setPtrAttribute(self: *Self, comptime T: type, attribute: [:0]const u8, value: ?*T) void {
        interop.setPtrAttribute(T, self, attribute, .{}, value);
    }

    pub fn setHandle(self: *Self, arg: [:0]const u8) void {
        interop.setHandle(self, arg);
    }

    pub fn fromHandleName(handle_name: [:0]const u8) ?*Self {
        return interop.fromHandleName(Self, handle_name);
    }

    pub fn postMessage(self: *Self, s: [:0]const u8, i: i32, f: f64, p: ?*anyopaque) void {
        return interop.postMessage(self, s, i, f, p);
    }

    ///
    /// Creates an interface element given its class name and parameters.
    /// After creation the element still needs to be attached to a container and mapped to the native system so it can be visible.
    pub fn init() Initializer {
        var handle = interop.create(Self);

        if (handle) |valid| {
            return .{
                .ref = @as(*Self, @ptrCast(valid)),
            };
        } else {
            return .{ .ref = undefined, .last_error = Error.NotInitialized };
        }
    }

    ///
    /// Destroys an interface element and all its children.
    /// Only dialogs, timers, popup menus and images should be normally destroyed, but detached elements can also be destroyed.
    pub fn deinit(self: *Self) void {
        interop.destroy(self);
    }

    ///
    /// Creates (maps) the native interface objects corresponding to the given IUP interface elements.
    /// It will also called recursively to create the native element of all the children in the element's tree.
    /// The element must be already attached to a mapped container, except the dialog. A child can only be mapped if its parent is already mapped.
    /// This function is automatically called before the dialog is shown in IupShow, IupShowXY or IupPopup.
    /// If the element is a dialog then the abstract layout will be updated even if the dialog is already mapped. If the dialog is visible the elements will be immediately repositioned. Calling IupMap for an already mapped dialog is the same as only calling IupRefresh for the dialog.
    /// Calling IupMap for an already mapped element that is not a dialog does nothing.
    /// If you add new elements to an already mapped dialog you must call IupMap for that elements. And then call IupRefresh to update the dialog layout.
    /// If the WID attribute of an element is NULL, it means the element was not already mapped. Some containers do not have a native element associated, like VBOX and HBOX. In this case their WID is a fake value (void*)(-1).
    /// It is useful for the application to call IupMap when the value of the WID attribute must be known, i.e. the native element must exist, before a dialog is made visible.
    /// The MAP_CB callback is called at the end of the IupMap function, after all processing, so it can also be used to create other things that depend on the WID attribute. But notice that for non dialog elements it will be called before the dialog layout has been updated, so the element current size will still be 0x0 (since 3.14).
    pub fn map(self: *Self) !void {
        try interop.map(self);
    }

    ///
    /// Adds a tuple of children
    pub fn appendChildren(self: *Self, tuple: anytype) !void {
        try Impl(Self).appendChildren(self, tuple);
    }

    ///
    /// Appends a child on this container
    /// child must be an Element or
    pub fn appendChild(self: *Self, child: anytype) !void {
        try Impl(Self).appendChild(self, child);
    }

    ///
    /// Returns a iterator for children elements.
    pub fn children(self: *Self) ChildrenIterator {
        return ChildrenIterator.init(self);
    }

    ///
    ///
    pub fn getDialog(self: *Self) ?*iup.Dialog {
        return interop.getDialog(self);
    }

    ///
    /// Returns the the child element that has the NAME attribute equals to the given value on the same dialog hierarchy.
    /// Works also for children of a menu that is associated with a dialog.
    pub fn getDialogChild(self: *Self, byName: [:0]const u8) ?Element {
        return interop.getDialogChild(self, byName);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog.
    /// To be used after changing size attributes, or attributes that affect the size of the control. Can be used for any element inside a dialog, but the layout of the dialog and all controls will be updated. It can change the layout of all the controls inside the dialog because of the dynamic layout positioning.
    pub fn refresh(self: *Self) void {
        Impl(Self).refresh(self);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog.
    pub fn update(self: *Self) void {
        Impl(Self).update(self);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog.
    pub fn updateChildren(self: *Self) void {
        Impl(Self).updateChildren(self);
    }

    ///
    /// Force the element and its children to be redrawn immediately.
    pub fn redraw(self: *Self, redraw_children: bool) void {
        Impl(Self).redraw(self, redraw_children);
    }

    pub fn getHandleName(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HANDLENAME", .{});
    }

    pub fn setHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HANDLENAME", .{}, arg);
    }

    pub fn getFrameTime(self: *Self) i32 {
        return interop.getIntAttribute(self, "FRAMETIME", .{});
    }

    pub fn setFrameTime(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "FRAMETIME", .{}, arg);
    }

    pub fn getImageOpenHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEOPENHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageOpenHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEOPENHIGHLIGHT", .{}, arg);
    }

    pub fn setImageOpenHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEOPENHIGHLIGHT", .{}, arg);
    }

    pub fn getImageExtraPress1(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEEXTRAPRESS1", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageExtraPress1(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEEXTRAPRESS1", .{}, arg);
    }

    pub fn setImageExtraPress1HandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEEXTRAPRESS1", .{}, arg);
    }

    pub fn getImageExtraPress2(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEEXTRAPRESS2", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageExtraPress2(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEEXTRAPRESS2", .{}, arg);
    }

    pub fn setImageExtraPress2HandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEEXTRAPRESS2", .{}, arg);
    }

    pub fn getImageExtraPress3(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEEXTRAPRESS3", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageExtraPress3(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEEXTRAPRESS3", .{}, arg);
    }

    pub fn setImageExtraPress3HandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEEXTRAPRESS3", .{}, arg);
    }

    ///
    /// BACKCOLOR (non inheritable): background color of the bar handler.
    /// If not defined it will use the background color of the native parent.
    /// (since 3.9)
    pub fn getBackColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "BACKCOLOR", .{});
    }

    ///
    /// BACKCOLOR (non inheritable): background color of the bar handler.
    /// If not defined it will use the background color of the native parent.
    /// (since 3.9)
    pub fn setBackColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "BACKCOLOR", .{}, rgb);
    }

    pub fn getMaxSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "MAXSIZE", .{});
        return Size.parse(str);
    }

    pub fn setMaxSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "MAXSIZE", .{}, value);
    }

    ///
    /// TITLEIMAGE (non inheritable): title image, shown in the bar handler near
    /// the expand/collapse button.
    /// When set it will reset TITLE (image and text title are mutually exclusive).
    /// Shown only when BARPOSITION=TOP.
    /// (since 3.14)
    pub fn getTitleImage(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "TITLEIMAGE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    ///
    /// TITLEIMAGE (non inheritable): title image, shown in the bar handler near
    /// the expand/collapse button.
    /// When set it will reset TITLE (image and text title are mutually exclusive).
    /// Shown only when BARPOSITION=TOP.
    /// (since 3.14)
    pub fn setTitleImage(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "TITLEIMAGE", .{}, arg);
    }

    pub fn setTitleImageHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TITLEIMAGE", .{}, arg);
    }

    pub fn getPosition(self: *Self) iup.XYPos {
        var str = interop.getStrAttribute(self, "POSITION", .{});
        return iup.XYPos.parse(str, ',');
    }

    pub fn setPosition(self: *Self, x: i32, y: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
        interop.setStrAttribute(self, "POSITION", .{}, value);
    }

    pub fn getImageExtra1(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEEXTRA1", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageExtra1(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEEXTRA1", .{}, arg);
    }

    pub fn setImageExtra1HandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEEXTRA1", .{}, arg);
    }

    pub fn getImageExtra2(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEEXTRA2", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageExtra2(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEEXTRA2", .{}, arg);
    }

    pub fn setImageExtra2HandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEEXTRA2", .{}, arg);
    }

    pub fn getImageExtra3(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEEXTRA3", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageExtra3(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEEXTRA3", .{}, arg);
    }

    pub fn setImageExtra3HandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEEXTRA3", .{}, arg);
    }

    pub fn getCanFocus(self: *Self) bool {
        return interop.getBoolAttribute(self, "CANFOCUS", .{});
    }

    pub fn setCanFocus(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "CANFOCUS", .{}, arg);
    }

    pub fn getVisible(self: *Self) bool {
        return interop.getBoolAttribute(self, "VISIBLE", .{});
    }

    pub fn setVisible(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "VISIBLE", .{}, arg);
    }

    ///
    /// IMAGE (non inheritable): image name to replace the arrow image by a custom
    /// image when STATE=CLOSE.
    /// Works only when BARPOSITION=TOP.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// See also IupImage.
    /// (since 3.11)
    pub fn getImage(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    ///
    /// IMAGE (non inheritable): image name to replace the arrow image by a custom
    /// image when STATE=CLOSE.
    /// Works only when BARPOSITION=TOP.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// See also IupImage.
    /// (since 3.11)
    pub fn setImage(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGE", .{}, arg);
    }

    pub fn setImageHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGE", .{}, arg);
    }

    ///
    /// HIGHCOLOR (non inheritable): title text color when highlighted.
    /// Works only when TITLEEXPAND=Yes.
    /// Defaults to the FORECOLOR if not defined.
    /// (since 3.14)
    pub fn getHighColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "HIGHCOLOR", .{});
    }

    ///
    /// HIGHCOLOR (non inheritable): title text color when highlighted.
    /// Works only when TITLEEXPAND=Yes.
    /// Defaults to the FORECOLOR if not defined.
    /// (since 3.14)
    pub fn setHighColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "HIGHCOLOR", .{}, rgb);
    }

    pub fn getTheme(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "THEME", .{});
    }

    pub fn setTheme(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "THEME", .{}, arg);
    }

    ///
    /// EXPAND (non inheritable): the default value is "YES".
    pub fn getExpand(self: *Self) ?Expand {
        var ret = interop.getStrAttribute(self, "EXPAND", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("HORIZONTAL", ret)) return .Horizontal;
        if (std.ascii.eqlIgnoreCase("VERTICAL", ret)) return .Vertical;
        if (std.ascii.eqlIgnoreCase("HORIZONTALFREE", ret)) return .HorizontalFree;
        if (std.ascii.eqlIgnoreCase("VERTICALFREE", ret)) return .VerticalFree;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }

    ///
    /// EXPAND (non inheritable): the default value is "YES".
    pub fn setExpand(self: *Self, arg: ?Expand) void {
        if (arg) |value| switch (value) {
            .Yes => interop.setStrAttribute(self, "EXPAND", .{}, "YES"),
            .Horizontal => interop.setStrAttribute(self, "EXPAND", .{}, "HORIZONTAL"),
            .Vertical => interop.setStrAttribute(self, "EXPAND", .{}, "VERTICAL"),
            .HorizontalFree => interop.setStrAttribute(self, "EXPAND", .{}, "HORIZONTALFREE"),
            .VerticalFree => interop.setStrAttribute(self, "EXPAND", .{}, "VERTICALFREE"),
            .No => interop.setStrAttribute(self, "EXPAND", .{}, "NO"),
        } else {
            interop.clearAttribute(self, "EXPAND", .{});
        }
    }

    pub fn getSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "SIZE", .{});
        return Size.parse(str);
    }

    pub fn setSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "SIZE", .{}, value);
    }

    ///
    /// WID (read-only): returns -1 if mapped.
    pub fn getWId(self: *Self) i32 {
        return interop.getIntAttribute(self, "WID", .{});
    }

    pub fn getFontSize(self: *Self) i32 {
        return interop.getIntAttribute(self, "FONTSIZE", .{});
    }

    pub fn setFontSize(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "FONTSIZE", .{}, arg);
    }

    pub fn getNaturalSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "NATURALSIZE", .{});
        return Size.parse(str);
    }

    pub fn getUserSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "USERSIZE", .{});
        return Size.parse(str);
    }

    pub fn setUserSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "USERSIZE", .{}, value);
    }

    pub fn getTitleImageOpenHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "TITLEIMAGEOPENHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setTitleImageOpenHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "TITLEIMAGEOPENHIGHLIGHT", .{}, arg);
    }

    pub fn setTitleImageOpenHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TITLEIMAGEOPENHIGHLIGHT", .{}, arg);
    }

    ///
    /// TITLE (non inheritable): title text, shown in the bar handler near the
    /// expand/collapse button.
    /// When set it will reset TITLEIMAGE.
    /// Shown only when BARPOSITION=TOP.
    /// When the TITLE is defined and BARPOSITION=TOP then the expand/collapse
    /// button is left aligned.
    /// In all other situations the expand/collapse button is centered.
    pub fn getTitle(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TITLE", .{});
    }

    ///
    /// TITLE (non inheritable): title text, shown in the bar handler near the
    /// expand/collapse button.
    /// When set it will reset TITLEIMAGE.
    /// Shown only when BARPOSITION=TOP.
    /// When the TITLE is defined and BARPOSITION=TOP then the expand/collapse
    /// button is left aligned.
    /// In all other situations the expand/collapse button is centered.
    pub fn setTitle(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TITLE", .{}, arg);
    }

    pub fn getPropagateFocus(self: *Self) bool {
        return interop.getBoolAttribute(self, "PROPAGATEFOCUS", .{});
    }

    pub fn setPropagateFocus(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "PROPAGATEFOCUS", .{}, arg);
    }

    pub fn getFloating(self: *Self) ?Floating {
        var ret = interop.getStrAttribute(self, "FLOATING", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("IGNORE", ret)) return .Ignore;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }

    pub fn setFloating(self: *Self, arg: ?Floating) void {
        if (arg) |value| switch (value) {
            .Yes => interop.setStrAttribute(self, "FLOATING", .{}, "YES"),
            .Ignore => interop.setStrAttribute(self, "FLOATING", .{}, "IGNORE"),
            .No => interop.setStrAttribute(self, "FLOATING", .{}, "NO"),
        } else {
            interop.clearAttribute(self, "FLOATING", .{});
        }
    }

    pub fn getNormalizerGroup(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NORMALIZERGROUP", .{});
    }

    pub fn setNormalizerGroup(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NORMALIZERGROUP", .{}, arg);
    }

    pub fn getRasterSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "RASTERSIZE", .{});
        return Size.parse(str);
    }

    pub fn setRasterSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "RASTERSIZE", .{}, value);
    }

    pub fn getImageExtraHighlight1(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEEXTRAHIGHLIGHT1", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageExtraHighlight1(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEEXTRAHIGHLIGHT1", .{}, arg);
    }

    pub fn setImageExtraHighlight1HandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEEXTRAHIGHLIGHT1", .{}, arg);
    }

    pub fn getImageExtraHighlight2(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEEXTRAHIGHLIGHT2", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageExtraHighlight2(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEEXTRAHIGHLIGHT2", .{}, arg);
    }

    pub fn setImageExtraHighlight2HandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEEXTRAHIGHLIGHT2", .{}, arg);
    }

    pub fn getImageExtraHighlight3(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEEXTRAHIGHLIGHT3", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageExtraHighlight3(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEEXTRAHIGHLIGHT3", .{}, arg);
    }

    pub fn setImageExtraHighlight3HandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEEXTRAHIGHLIGHT3", .{}, arg);
    }

    ///
    /// BARSIZE (non inheritable): controls the size of the bar handler.
    /// Default: the height or width that fits all its internal elements according
    /// to BARPOSITION.
    pub fn getBarSize(self: *Self) i32 {
        return interop.getIntAttribute(self, "BARSIZE", .{});
    }

    ///
    /// BARSIZE (non inheritable): controls the size of the bar handler.
    /// Default: the height or width that fits all its internal elements according
    /// to BARPOSITION.
    pub fn setBarSize(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "BARSIZE", .{}, arg);
    }

    ///
    /// FRAMECOLOR (non inheritable): frame line color.
    /// Default: the global attribute DLGFGCOLOR.
    /// (since 3.23)
    pub fn getFrameColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "FRAMECOLOR", .{});
    }

    ///
    /// FRAMECOLOR (non inheritable): frame line color.
    /// Default: the global attribute DLGFGCOLOR.
    /// (since 3.23)
    pub fn setFrameColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "FRAMECOLOR", .{}, rgb);
    }

    pub fn getFontFace(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FONTFACE", .{});
    }

    pub fn setFontFace(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FONTFACE", .{}, arg);
    }

    ///
    /// TITLEIMAGEOPEN: image name used when STATE=OPEN.
    /// TITLEIMAGEHIGHLIGHT: image name used when mouse is over the title image and
    /// STATE=CLOSE.TITLEIMAGEOPENHIGHLIGHT: image name used when mouse is over the
    /// title image and STATE=OPEN.
    pub fn getTitleImageOpen(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "TITLEIMAGEOPEN", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    ///
    /// TITLEIMAGEOPEN: image name used when STATE=OPEN.
    /// TITLEIMAGEHIGHLIGHT: image name used when mouse is over the title image and
    /// STATE=CLOSE.TITLEIMAGEOPENHIGHLIGHT: image name used when mouse is over the
    /// title image and STATE=OPEN.
    pub fn setTitleImageOpen(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "TITLEIMAGEOPEN", .{}, arg);
    }

    pub fn setTitleImageOpenHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TITLEIMAGEOPEN", .{}, arg);
    }

    pub fn getName(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NAME", .{});
    }

    pub fn setName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NAME", .{}, arg);
    }

    ///
    /// STATE (non inheritable): Show or hide the container elements.
    /// Possible values: "OPEN" (expanded) or "CLOSE" (collapsed).
    /// Default: OPEN.
    /// Setting this attribute will automatically change the layout of the entire
    /// dialog so the child can be recomposed.
    pub fn getState(self: *Self) ?State {
        var ret = interop.getStrAttribute(self, "STATE", .{});

        if (std.ascii.eqlIgnoreCase("OPEN", ret)) return .Open;
        if (std.ascii.eqlIgnoreCase("CLOSED", ret)) return .Closed;
        return null;
    }

    ///
    /// STATE (non inheritable): Show or hide the container elements.
    /// Possible values: "OPEN" (expanded) or "CLOSE" (collapsed).
    /// Default: OPEN.
    /// Setting this attribute will automatically change the layout of the entire
    /// dialog so the child can be recomposed.
    pub fn setState(self: *Self, arg: ?State) void {
        if (arg) |value| switch (value) {
            .Open => interop.setStrAttribute(self, "STATE", .{}, "OPEN"),
            .Closed => interop.setStrAttribute(self, "STATE", .{}, "CLOSED"),
        } else {
            interop.clearAttribute(self, "STATE", .{});
        }
    }

    pub fn getActive(self: *Self) bool {
        return interop.getBoolAttribute(self, "ACTIVE", .{});
    }

    pub fn setActive(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "ACTIVE", .{}, arg);
    }

    pub fn getImageHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setImageHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEHIGHLIGHT", .{}, arg);
    }

    pub fn setImageHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEHIGHLIGHT", .{}, arg);
    }

    pub fn getExpandWeight(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "EXPANDWEIGHT", .{});
    }

    pub fn setExpandWeight(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "EXPANDWEIGHT", .{}, arg);
    }

    pub fn getMinSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "MINSIZE", .{});
        return Size.parse(str);
    }

    pub fn setMinSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "MINSIZE", .{}, value);
    }

    pub fn getTitleImageHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "TITLEIMAGEHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setTitleImageHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "TITLEIMAGEHIGHLIGHT", .{}, arg);
    }

    pub fn setTitleImageHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TITLEIMAGEHIGHLIGHT", .{}, arg);
    }

    pub fn getNTheme(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NTHEME", .{});
    }

    pub fn setNTheme(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NTHEME", .{}, arg);
    }

    ///
    /// ANIMATION (non inheritable): enable animation during open/close.
    /// Works only for BARPOSITION=TOP and does not works for AUTOSHOW.
    /// Also the child must be a native container like IupTabs, IupFrame,
    /// IupBackgroundBox, or IupScrollBox, or it will not work accordantly.
    /// Values can be SLIDE (child controls slide down), CURTAIN (child controls
    /// appears as if a curtain is being pulled) or NO.
    /// Default: NO.
    /// ((since 3.14)
    pub fn getAnimation(self: *Self) ?Animation {
        var ret = interop.getStrAttribute(self, "ANIMATION", .{});

        if (std.ascii.eqlIgnoreCase("SLIDE", ret)) return .Slide;
        if (std.ascii.eqlIgnoreCase("CURTAIN", ret)) return .Curtain;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }

    ///
    /// ANIMATION (non inheritable): enable animation during open/close.
    /// Works only for BARPOSITION=TOP and does not works for AUTOSHOW.
    /// Also the child must be a native container like IupTabs, IupFrame,
    /// IupBackgroundBox, or IupScrollBox, or it will not work accordantly.
    /// Values can be SLIDE (child controls slide down), CURTAIN (child controls
    /// appears as if a curtain is being pulled) or NO.
    /// Default: NO.
    /// ((since 3.14)
    pub fn setAnimation(self: *Self, arg: ?Animation) void {
        if (arg) |value| switch (value) {
            .Slide => interop.setStrAttribute(self, "ANIMATION", .{}, "SLIDE"),
            .Curtain => interop.setStrAttribute(self, "ANIMATION", .{}, "CURTAIN"),
            .No => interop.setStrAttribute(self, "ANIMATION", .{}, "NO"),
        } else {
            interop.clearAttribute(self, "ANIMATION", .{});
        }
    }

    pub fn getCharSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "CHARSIZE", .{});
        return Size.parse(str);
    }

    pub fn getClientSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "CLIENTSIZE", .{});
        return Size.parse(str);
    }

    pub fn getClientOffset(self: *Self) Size {
        var str = interop.getStrAttribute(self, "CLIENTOFFSET", .{});
        return Size.parse(str);
    }

    ///
    /// FORECOLOR (non inheritable): title text color.
    /// Default: the global attribute DLGFGCOLOR.
    /// (since 3.9)
    pub fn getForeColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "FORECOLOR", .{});
    }

    ///
    /// FORECOLOR (non inheritable): title text color.
    /// Default: the global attribute DLGFGCOLOR.
    /// (since 3.9)
    pub fn setForeColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "FORECOLOR", .{}, rgb);
    }

    pub fn getFontStyle(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FONTSTYLE", .{});
    }

    pub fn setFontStyle(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FONTSTYLE", .{}, arg);
    }

    ///
    /// IMAGEOPEN: image name used when STATE=OPEN.
    /// IMAGEHIGHLIGHT: image name used when mouse is over the bar handler and
    /// STATE=CLOSE.IMAGEOPENHIGHLIGHT: image name used when mouse is over the bar
    /// handler and STATE=OPEN.
    pub fn getImageOpen(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "IMAGEOPEN", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    ///
    /// IMAGEOPEN: image name used when STATE=OPEN.
    /// IMAGEHIGHLIGHT: image name used when mouse is over the bar handler and
    /// STATE=CLOSE.IMAGEOPENHIGHLIGHT: image name used when mouse is over the bar
    /// handler and STATE=OPEN.
    pub fn setImageOpen(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "IMAGEOPEN", .{}, arg);
    }

    pub fn setImageOpenHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IMAGEOPEN", .{}, arg);
    }

    ///
    /// FRAMEWIDTH (non inheritable): frame line width.
    /// Default: 1.
    /// (since 3.23)
    pub fn getFrameWidth(self: *Self) i32 {
        return interop.getIntAttribute(self, "FRAMEWIDTH", .{});
    }

    ///
    /// FRAMEWIDTH (non inheritable): frame line width.
    /// Default: 1.
    /// (since 3.23)
    pub fn setFrameWidth(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "FRAMEWIDTH", .{}, arg);
    }

    ///
    /// FRAME (non inheritable): enables the frame line around the bar area.
    /// Default: No.
    /// (since 3.23)
    pub fn getFrame(self: *Self) bool {
        return interop.getBoolAttribute(self, "FRAME", .{});
    }

    ///
    /// FRAME (non inheritable): enables the frame line around the bar area.
    /// Default: No.
    /// (since 3.23)
    pub fn setFrame(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "FRAME", .{}, arg);
    }

    ///
    /// FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE,
    /// MAXSIZE, THEME: also accepted.
    pub fn getFont(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FONT", .{});
    }

    ///
    /// FONT, SIZE, RASTERSIZE, CLIENTSIZE, CLIENTOFFSET, POSITION, MINSIZE,
    /// MAXSIZE, THEME: also accepted.
    pub fn setFont(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FONT", .{}, arg);
    }

    ///
    /// TABIMAGEn (non inheritable): image name to be used in the respective tab.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// n starts at 0.
    /// See also IupImage.
    /// In Motif, the image is shown only if TABTITLEn is NULL.
    /// In Windows and Motif set the BGCOLOR attribute before setting the image.
    /// When set after map will update the TABIMAGE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABIMAGE (non inheritable) (at children only): Same as TABIMAGEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn getTabImage(self: *Self, index: i32) ?iup.Element {
        if (interop.getHandleAttribute(self, "TABIMAGE", .{index})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    ///
    /// TABIMAGEn (non inheritable): image name to be used in the respective tab.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// n starts at 0.
    /// See also IupImage.
    /// In Motif, the image is shown only if TABTITLEn is NULL.
    /// In Windows and Motif set the BGCOLOR attribute before setting the image.
    /// When set after map will update the TABIMAGE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABIMAGE (non inheritable) (at children only): Same as TABIMAGEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn setTabImage(self: *Self, index: i32, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "TABIMAGE", .{index}, arg);
    }

    pub fn setTabImageHandleName(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TABIMAGE", .{index}, arg);
    }

    ///
    /// TABTITLEn (non inheritable): Contains the text to be shown in the
    /// respective tab title.
    /// n starts at 0.
    /// If this value is NULL, it will remain empty.
    /// The "&" character can be used to define a mnemonic, the next character will
    /// be used as key.
    /// Use "&&" to show the "&" character instead on defining a mnemonic.
    /// The button can be activated from any control in the dialog using the
    /// "Alt+key" combination.
    /// (mnemonic support since 3.3).
    /// When set after map will update the TABTITLE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABTITLE (non inheritable) (at children only): Same as TABTITLEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn getTabTitle(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "TABTITLE", .{index});
    }

    ///
    /// TABTITLEn (non inheritable): Contains the text to be shown in the
    /// respective tab title.
    /// n starts at 0.
    /// If this value is NULL, it will remain empty.
    /// The "&" character can be used to define a mnemonic, the next character will
    /// be used as key.
    /// Use "&&" to show the "&" character instead on defining a mnemonic.
    /// The button can be activated from any control in the dialog using the
    /// "Alt+key" combination.
    /// (mnemonic support since 3.3).
    /// When set after map will update the TABTITLE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABTITLE (non inheritable) (at children only): Same as TABTITLEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn setTabTitle(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TABTITLE", .{index}, arg);
    }

    ///
    /// ACTION ACTION Action generated when the element is activated.
    /// Affects each element differently.
    /// Callback int function(Ihandle *ih); [in C] ih:action() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// In some elements, this callback may receive more parameters, apart from ih.
    /// Please refer to each element's documentation.
    /// Affects IupButton, IupItem, IupList, IupText, IupCanvas, IupMultiline,
    /// IupToggle
    pub fn setActionCallback(self: *Self, callback: ?*const OnActionFn) void {
        const Handler = CallbackHandler(Self, OnActionFn, "ACTION");
        Handler.setCallback(self, callback);
    }

    ///
    /// EXTRABUTTON_CB: Action generated when any mouse button is pressed or released.
    /// (since 3.11) int function(Ihandle* ih, int button, int pressed); [in C]
    /// ih:extrabutton_cb(button, pressed: number) -> (ret: number) [in Lua] ih:
    /// identifies the element that activated the event.
    /// button: identifies the extra button.
    /// can be 1, 2 or 3.
    /// (this is not the same as BUTTON_CB)pressed: indicates the state of the
    /// button: 0 - mouse button was released; 1 - mouse button was pressed.
    pub fn setExtraButtonCallback(self: *Self, callback: ?*const OnExtraButtonFn) void {
        const Handler = CallbackHandler(Self, OnExtraButtonFn, "EXTRABUTTON_CB");
        Handler.setCallback(self, callback);
    }

    ///
    /// OPENCLOSE_CB: Action generated before the expander state is interactively changed.
    /// (Since 3.11) int function(Ihandle* ih, int state); [in
    /// C]ih:openclose_cb(state: number) -> (ret: number) [in Lua]
    pub fn setOpenCloseCallback(self: *Self, callback: ?*const OnOpenCloseFn) void {
        const Handler = CallbackHandler(Self, OnOpenCloseFn, "OPENCLOSE_CB");
        Handler.setCallback(self, callback);
    }

    ///
    /// MAP_CB MAP_CB Called right after an element is mapped and its attributes
    /// updated in IupMap.
    /// When the element is a dialog, it is called after the layout is updated.
    /// For all other elements is called before the layout is updated, so the
    /// element current size will still be 0x0 during MAP_CB (since 3.14).
    /// Callback int function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub fn setMapCallback(self: *Self, callback: ?*const OnMapFn) void {
        const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
        Handler.setCallback(self, callback);
    }

    ///
    /// DESTROY_CB DESTROY_CB Called right before an element is destroyed.
    /// Callback int function(Ihandle *ih); [in C] ih:destroy_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Notes If the dialog is visible then it is hidden before it is destroyed.
    /// The callback will be called right after it is hidden.
    /// The callback will be called before all other destroy procedures.
    /// For instance, if the element has children then it is called before the
    /// children are destroyed.
    /// For language binding implementations use the callback name "LDESTROY_CB" to
    /// release memory allocated by the binding for the element.
    /// Also the callback will be called before the language callback.
    /// Affects All.
    pub fn setDestroyCallback(self: *Self, callback: ?*const OnDestroyFn) void {
        const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
        Handler.setCallback(self, callback);
    }

    ///
    /// UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    /// Callback int function(Ihandle *ih); [in C] ih:unmap_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub fn setUnmapCallback(self: *Self, callback: ?*const OnUnmapFn) void {
        const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setLDestroyCallback(self: *Self, callback: ?*const OnLDestroyFn) void {
        const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setPostMessageCallback(self: *Self, callback: ?*const OnPostMessageFn) void {
        const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
        Handler.setCallback(self, callback);
    }
};

test "Expander HandleName" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setHandleName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHandleName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander FrameTime" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFrameTime(42).unwrap());
    defer item.deinit();

    var ret = item.getFrameTime();

    try std.testing.expect(ret == 42);
}

test "Expander BackColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setBackColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getBackColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Expander MaxSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setMaxSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMaxSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander Position" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setPosition(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getPosition();

    try std.testing.expect(ret.x == 9 and ret.y == 10);
}

test "Expander CanFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setCanFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getCanFocus();

    try std.testing.expect(ret == true);
}

test "Expander Visible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setVisible(true).unwrap());
    defer item.deinit();

    var ret = item.getVisible();

    try std.testing.expect(ret == true);
}

test "Expander HighColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setHighColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getHighColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Expander Theme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander Expand" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setExpand(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getExpand();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "Expander Size" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander FontSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFontSize(42).unwrap());
    defer item.deinit();

    var ret = item.getFontSize();

    try std.testing.expect(ret == 42);
}

test "Expander UserSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setUserSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getUserSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander Title" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setTitle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTitle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander PropagateFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setPropagateFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getPropagateFocus();

    try std.testing.expect(ret == true);
}

test "Expander Floating" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFloating(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getFloating();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "Expander NormalizerGroup" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setNormalizerGroup("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNormalizerGroup();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander RasterSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setRasterSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getRasterSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander BarSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setBarSize(42).unwrap());
    defer item.deinit();

    var ret = item.getBarSize();

    try std.testing.expect(ret == 42);
}

test "Expander FrameColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFrameColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getFrameColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Expander FontFace" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFontFace("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontFace();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander Name" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander State" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setState(.Open).unwrap());
    defer item.deinit();

    var ret = item.getState();

    try std.testing.expect(ret != null and ret.? == .Open);
}

test "Expander Active" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setActive(true).unwrap());
    defer item.deinit();

    var ret = item.getActive();

    try std.testing.expect(ret == true);
}

test "Expander ExpandWeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setExpandWeight(3.14).unwrap());
    defer item.deinit();

    var ret = item.getExpandWeight();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Expander MinSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setMinSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMinSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Expander NTheme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setNTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander Animation" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setAnimation(.Slide).unwrap());
    defer item.deinit();

    var ret = item.getAnimation();

    try std.testing.expect(ret != null and ret.? == .Slide);
}

test "Expander ForeColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setForeColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getForeColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Expander FontStyle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFontStyle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontStyle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Expander FrameWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFrameWidth(42).unwrap());
    defer item.deinit();

    var ret = item.getFrameWidth();

    try std.testing.expect(ret == 42);
}

test "Expander Frame" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFrame(true).unwrap());
    defer item.deinit();

    var ret = item.getFrame();

    try std.testing.expect(ret == true);
}

test "Expander Font" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Expander.init().setFont("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFont();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}
