// This code was generated by a tool.
// IUP Metadata Code Generator
// https://github.com/batiati/IUPMetadata
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.

const std = @import("std");

const c = @import("../c.zig");
const iup = @import("../iup.zig");

const Impl = @import("../impl.zig").Impl;
const CallbackHandler = @import("../callback_handler.zig").CallbackHandler;

const debug = std.debug;
const trait = std.meta.trait;

const Element = iup.Element;
const Handle = iup.Handle;
const Error = iup.Error;
const ChildrenIterator = iup.ChildrenIterator;
const Size = iup.Size;
const Margin = iup.Margin;

/// 
/// Creates a dialog element.
/// It manages user interaction with the interface elements.
/// For any interface element to be shown, it must be encapsulated in a dialog.
pub const Dialog = opaque {
    pub const CLASS_NAME = "dialog";
    const Self = @This();

    pub const OnTouchFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32, arg3: [:0]const u8) anyerror!void;

    /// 
    /// FOCUS_CB: Called when the dialog or any of its children gets the focus, or
    /// when another dialog or any control in another dialog gets the focus.
    /// It is called after the common callbacks GETFOCUS_CB and KILL_FOCUS_CB.
    /// (since 3.21) int function(Ihandle *ih, int focus); [in C]ih:focus_cb(focus:
    /// number) -> (ret: number) [in Lua]
    pub const OnFocusFn = fn (self: *Self, arg0: i32) anyerror!void;

    /// 
    /// K_ANY K_ANY Action generated when a keyboard event occurs.
    /// Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c: number) ->
    /// (ret: number) [in Lua] ih: identifier of the element that activated the event.
    /// c: identifier of typed key.
    /// Please refer to the Keyboard Codes table for a list of possible values.
    /// Returns: If IUP_IGNORE is returned the key is ignored and not processed by
    /// the control and not propagated.
    /// If returns IUP_CONTINUE, the key will be processed and the event will be
    /// propagated to the parent of the element receiving it, this is the default behavior.
    /// If returns IUP_DEFAULT the key is processed but it is not propagated.
    /// IUP_CLOSE will be processed.
    /// Notes Keyboard callbacks depend on the keyboard usage of the control with
    /// the focus.
    /// So if you return IUP_IGNORE the control will usually not process the key.
    /// But be aware that sometimes the control process the key in another event so
    /// even returning IUP_IGNORE the key can get processed.
    /// Although it will not be propagated.
    /// IMPORTANT: The callbacks "K_*" of the dialog or native containers depend on
    /// the IUP_CONTINUE return value to work while the control is in focus.
    /// If the callback does not exists it is automatically propagated to the
    /// parent of the element.
    /// K_* callbacks All defined keys are also callbacks of any element, called
    /// when the respective key is activated.
    /// For example: "K_cC" is also a callback activated when the user press
    /// Ctrl+C, when the focus is at the element or at a children with focus.
    /// This is the way an application can create shortcut keys, also called hot keys.
    /// These callbacks are not available in IupLua.
    /// Affects All elements with keyboard interaction.
    pub const OnKAnyFn = fn (self: *Self, arg0: i32) anyerror!void;

    /// 
    /// HELP_CB HELP_CB Action generated when the user press F1 at a control.
    /// In Motif is also activated by the Help button in some workstations keyboard.
    /// Callback void function(Ihandle *ih); [in C] ih:help_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Returns: IUP_CLOSE will be processed.
    /// Affects All elements with user interaction.
    pub const OnHelpFn = fn (self: *Self) anyerror!void;

    /// 
    /// CLOSE_CB CLOSE_CB Called just before a dialog is closed when the user
    /// clicks the close button of the title bar or an equivalent action.
    /// Callback int function(Ihandle *ih); [in C] ih:close_cb() -> (ret: number)
    /// [in Lua] ih: identifies the element that activated the event.
    /// Returns: if IUP_IGNORE, it prevents the dialog from being closed.
    /// If you destroy the dialog in this callback, you must return IUP_IGNORE.
    /// IUP_CLOSE will be processed.
    /// Affects IupDialog
    pub const OnCloseFn = fn (self: *Self) anyerror!void;

    pub const OnDropMotionFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnDragEndFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnDragBeginFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnMultiTouchFn = fn (self: *Self, arg0: i32, arg1: *i32, arg2: *i32, arg3: *i32) anyerror!void;

    /// 
    /// MDIACTIVATE_CB [Windows Only]: Called when a MDI child window is activated.
    /// Only the MDI child receive this message.
    /// It is not called when the child is shown for the first time.
    /// int function(Ihandle *ih); [in C]elem:mdiactivate_cb() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    pub const OnMdiActivateFn = fn (self: *Self) anyerror!void;

    /// 
    /// MAP_CB MAP_CB Called right after an element is mapped and its attributes
    /// updated in IupMap.
    /// When the element is a dialog, it is called after the layout is updated.
    /// For all other elements is called before the layout is updated, so the
    /// element current size will still be 0x0 during MAP_CB (since 3.14).
    /// Callback int function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub const OnMapFn = fn (self: *Self) anyerror!void;

    /// 
    /// ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse enters the
    /// native element.
    /// Callback int function(Ihandle *ih); [in C] ih:enterwindow_cb() -> (ret:
    /// number) [in Lua] ih: identifier of the element that activated the event.
    /// Notes When the cursor is moved from one element to another, the call order
    /// in all platforms will be first the LEAVEWINDOW_CB callback of the old
    /// control followed by the ENTERWINDOW_CB callback of the new control.
    /// (since 3.14) If the mouse button is hold pressed and the cursor moves
    /// outside the element the behavior is system dependent.
    /// In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB callbacks are NOT called, in
    /// GTK the callbacks are called.
    /// Affects All controls with user interaction.
    /// See Also LEAVEWINDOW_CB
    pub const OnEnterWindowFn = fn (self: *Self) anyerror!void;

    /// 
    /// DESTROY_CB DESTROY_CB Called right before an element is destroyed.
    /// Callback int function(Ihandle *ih); [in C] ih:destroy_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Notes If the dialog is visible then it is hidden before it is destroyed.
    /// The callback will be called right after it is hidden.
    /// The callback will be called before all other destroy procedures.
    /// For instance, if the element has children then it is called before the
    /// children are destroyed.
    /// For language binding implementations use the callback name "LDESTROY_CB" to
    /// release memory allocated by the binding for the element.
    /// Also the callback will be called before the language callback.
    /// Affects All.
    pub const OnDestroyFn = fn (self: *Self) anyerror!void;

    pub const OnDropDataFn = fn (self: *Self, arg0: [:0]const u8, arg1: *iup.Unknow, arg2: i32, arg3: i32, arg4: i32) anyerror!void;

    /// 
    /// KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses keyboard focus.
    /// This callback is called before the GETFOCUS_CB of the element that gets the focus.
    /// Callback int function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret:
    /// number) [in Lua] ih: identifier of the element that activated the event.
    /// Affects All elements with user interaction, except menus.
    /// In Windows, there are restrictions when using this callback.
    /// From MSDN on WM_KILLFOCUS: "While processing this message, do not make any
    /// function calls that display or activate a window.
    /// This causes the thread to yield control and can cause the application to
    /// stop responding to messages.
    /// See Also GETFOCUS_CB, IupGetFocus, IupSetFocus
    pub const OnKillFocusFn = fn (self: *Self) anyerror!void;

    /// 
    /// CUSTOMFRAMEACTIVATE_CB [Windows Only]: Called when the dialog active state
    /// is changed (for instance the user Alt+Tab to another application, or
    /// clicked in another window).
    /// Works only when CUSTOMFRAME or CUSTOMFRAMEEX is defined.
    /// (since 3.23) int function(Ihandle *ih, int active); [in
    /// C]ih:customframeactivate_cb(active: number) -> (ret: number) [in Lua]
    pub const OnCustomFrameActivateFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnDragDataFn = fn (self: *Self, arg0: [:0]const u8, arg1: *iup.Unknow, arg2: i32) anyerror!void;

    pub const OnDragDataSizeFn = fn (self: *Self, arg0: [:0]const u8) anyerror!void;

    pub const OnCustomFrameDrawFn = fn (self: *Self) anyerror!void;

    /// 
    /// SHOW_CB SHOW_CB Called right after the dialog is showed, hidden, maximized,
    /// minimized or restored from minimized/maximized.
    /// This callback is called when those actions were performed by the user or
    /// programmatically by the application.
    /// Callback int function(Ihandle *ih, int state); [in C] ih:show_cb(state:
    /// number) -> (ret: number) [in Lua] ih: identifier of the element that
    /// activated the event.
    /// state: indicates which of the following situations generated the event:
    /// IUP_HIDE (since 3.0) IUP_SHOW IUP_RESTORE (was minimized or maximized)
    /// IUP_MINIMIZE IUP_MAXIMIZE (since 3.0) (not received in Motif when activated
    /// from the maximize button) Returns: IUP_CLOSE will be processed.
    /// Affects IupDialog
    pub const OnShowFn = fn (self: *Self, arg0: i32) anyerror!void;

    /// 
    /// DROPFILES_CB DROPFILES_CB Action called when a file is "dropped" into the control.
    /// When several files are dropped at once, the callback is called several
    /// times, once for each file.
    /// If defined after the element is mapped then the attribute DROPFILESTARGET
    /// must be set to YES.
    /// [Windows and GTK Only] (GTK 2.6) Callback int function(Ihandle *ih, const
    /// char* filename, int num, int x, int y); [in C] ih:dropfiles_cb(filename:
    /// string; num, x, y: number) -> (ret: number) [in Lua] ih: identifier of the
    /// element that activated the event.
    /// filename: Name of the dropped file.
    /// num: Number index of the dropped file.
    /// If several files are dropped, num is the index of the dropped file starting
    /// from "total-1" to "0".
    /// x: X coordinate of the point where the user released the mouse button.
    /// y: Y coordinate of the point where the user released the mouse button.
    /// Returns: If IUP_IGNORE is returned the callback will NOT be called for the
    /// next dropped files, and the processing of dropped files will be interrupted.
    /// Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    pub const OnDropFilesFn = fn (self: *Self, arg0: [:0]const u8, arg1: i32, arg2: i32, arg3: i32) anyerror!void;

    /// 
    /// RESIZE_CB RESIZE_CB Action generated when the canvas or dialog size is changed.
    /// Callback int function(Ihandle *ih, int width, int height); [in C]
    /// ih:resize_cb(width, height: number) -> (ret: number) [in Lua] ih:
    /// identifier of the element that activated the event.
    /// width: the width of the internal element size in pixels not considering the
    /// decorations (client size) height: the height of the internal element size
    /// in pixels not considering the decorations (client size) Notes For the
    /// dialog, this action is also generated when the dialog is mapped, after the
    /// map and before the show.
    /// When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the canvas scrollbar is
    /// hidden/shown after changing the DX or DY attributes from inside the
    /// callback, the size of the drawing area will immediately change, so the
    /// parameters with and height will be invalid.
    /// To update the parameters consult the DRAWSIZE attribute.
    /// Also activate the drawing toolkit only after updating the DX or DY attributes.
    /// Affects IupCanvas, IupGLCanvas, IupDialog
    pub const OnResizeFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    /// 
    /// UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    /// Callback int function(Ihandle *ih); [in C] ih:unmap_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub const OnUnmapFn = fn (self: *Self) anyerror!void;

    /// 
    /// TRAYCLICK_CB [Windows and GTK Only]: Called right after the mouse button is
    /// pressed or released over the tray icon.
    /// (GTK 2.10) int function(Ihandle *ih, int but, int pressed, int dclick); [in
    /// C]elem:trayclick_cb(but, pressed, dclick: number) -> (ret: number) [in Lua]
    pub const OnTrayClickFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32) anyerror!void;

    /// 
    /// GETFOCUS_CB GETFOCUS_CB Action generated when an element is given keyboard focus.
    /// This callback is called after the KILLFOCUS_CB of the element that loosed
    /// the focus.
    /// The IupGetFocus function during the callback returns the element that
    /// loosed the focus.
    /// Callback int function(Ihandle *ih); [in C] ih:getfocus_cb() -> (ret:
    /// number) [in Lua] ih: identifier of the element that received keyboard focus.
    /// Affects All elements with user interaction, except menus.
    /// See Also KILLFOCUS_CB, IupGetFocus, IupSetFocus
    pub const OnGetFocusFn = fn (self: *Self) anyerror!void;

    pub const OnLDestroyFn = fn (self: *Self) anyerror!void;

    /// 
    /// LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse leaves the
    /// native element.
    /// Callback int function(Ihandle *ih); [in C] ih:leavewindow_cb() -> (ret:
    /// number) [in Lua] ih: identifier of the element that activated the event.
    /// Notes When the cursor is moved from one element to another, the call order
    /// in all platforms will be first the LEAVEWINDOW_CB callback of the old
    /// control followed by the ENTERWINDOW_CB callback of the new control.
    /// (since 3.14) If the mouse button is hold pressed and the cursor moves
    /// outside the element the behavior is system dependent.
    /// In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB callbacks are NOT called, in
    /// GTK the callbacks are called.
    /// Affects All controls with user interaction.
    /// See Also ENTERWINDOW_CB
    pub const OnLeaveWindowFn = fn (self: *Self) anyerror!void;

    pub const OnPostMessageFn = fn (self: *Self, arg0: [:0]const u8, arg1: i32, arg2: f64, arg3: *iup.Unknow) anyerror!void;

    pub const ZOrder = enum {
        Top,
        Bottom,
    };
    /// 
    /// EXPAND (non inheritable): The default value is "YES".
    pub const Expand = enum {
        Yes,
        Horizontal,
        Vertical,
        HorizontalFree,
        VerticalFree,
        No,
    };
    /// 
    /// PLACEMENT: Changes how the dialog will be shown.
    /// Values: "FULL", "MAXIMIZED", "MINIMIZED" and "NORMAL".
    /// Default: NORMAL.
    /// After IupShow/IupPopup the attribute is set back to "NORMAL".
    /// FULL is similar to FULLSCREEN but only the dialog client area covers the
    /// screen area, menu and decorations will be there but out of the screen.
    /// In UNIX there is a chance that the placement won't work correctly, that
    /// depends on the Window Manager.
    /// In Windows, the SHOWNOACTIVATE attribute can be set to Yes to prevent the
    /// window from being activated (since 3.15).
    /// In Windows, the SHOWMINIMIZENEXT attribute can be set to Yes to activate
    /// the next top-level window in the Z order when minimizing (since 3.15).
    pub const Placement = enum {
        Maximized,
        Minimized,
        Full,
    };
    /// 
    /// MDIARRANGE [Windows Only] (write-only): Action to arrange MDI child windows.
    /// Possible values: TILEHORIZONTAL, TILEVERTICAL, CASCADE and ICON (arrange
    /// the minimized icons).
    pub const MdiArrange = enum {
        TileHorizontal,
        TileVertical,
        Cascade,
        Icon,
    };

    pub const Floating = enum {
        Yes,
        Ignore,
        No,
    };
    /// 
    /// TASKBARBUTTON [Windows Only]: If set to SHOW force the application button
    /// to be shown on the taskbar even if the dialog does not have decorations.
    /// If set to HIDE force the application button to be hidden from the taskbar,
    /// but also in this case the system menu, the maximize and minimize buttons
    /// will be hidden.
    /// (since 3.28)
    pub const TaskbarButton = enum {
        Show,
        Hide,
    };
    /// 
    /// TASKBARPROGRESSSTATE [Windows Only] (write-only): sets the type and state
    /// of the progress indicator displayed on a taskbar button.
    /// Possible values: NORMAL (a green bar), PAUSED (a yellow bar), ERROR (a red
    /// bar), INDETERMINATE (a green marquee) and NOPROGRESS (no bar).
    /// Default: NORMAL (since 3.10).
    pub const TaskbarProgressState = enum {
        NoProgress,
        Indeterminate,
        Error,
        Paused,
        Normal,
    };

    pub const Initializer = struct {
        last_error: ?anyerror = null,
        ref: *Self,

        ///
        /// Returns a pointer to IUP element or an error.
        /// Only top-level or detached elements needs to be unwraped,
        pub fn unwrap(self: Initializer) !*Self {
            if (self.last_error) |e| {
                return e;
            } else {
                return self.ref;
            }
        }

        ///
        /// Captures a reference into a external variable
        /// Allows to capture some references even using full declarative API
        pub fn capture(self: *Initializer, ref: **Self) Initializer {
            ref.* = self.ref;
            return self.*;
        }

        pub fn setStrAttribute(self: *Initializer, attributeName: [:0]const u8, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setStrAttribute(self.ref, attributeName, arg);
            return self.*;
        }

        pub fn setIntAttribute(self: *Initializer, attributeName: [:0]const u8, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setIntAttribute(self.ref, attributeName, arg);
            return self.*;
        }

        pub fn setBoolAttribute(self: *Initializer, attributeName: [:0]const u8, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setBoolAttribute(self.ref, attributeName, bool);
            return self.*;
        }

        pub fn setPtrAttribute(self: *Initializer, comptime T: type, attributeName: [:0]const u8, value: ?*T) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setPtrAttribute(self.ref, T, attributeName, value);
            return self.*;
        }

        pub fn setChildren(self: *Initializer, tuple: anytype) Initializer {
            if (self.last_error) |_| return self.*;

            Self.appendChildren(self.ref, tuple) catch |err| {
                self.last_error = err;
            };

            return self.*;
        }

        pub fn setTipBalloon(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "TIPBALLOON", .{}, arg);
            return self.*;
        }

        pub fn setHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setHandle(self.ref, arg);
            return self.*;
        }

        pub fn setTipBgColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            c.setRgb(self.ref, "TIPBGCOLOR", .{}, rgb);
            return self.*;
        }


        /// 
        /// MDICLIENT (creation only) [Windows Only] (non inheritable): Configure the
        /// canvas as a MDI client.
        /// Can be YES or NO.
        /// No callbacks will be called.
        /// This canvas will be used internally only by the MDI Frame and its MDI Children.
        /// The MDI frame must have one and only one MDI client.
        /// Default: NO.
        pub fn setMdiClient(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "MDICLIENT", .{}, arg);
            return self.*;
        }


        /// 
        /// CONTROL [Windows Only] (creation only): Embeds the dialog inside another window.
        pub fn setControl(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "CONTROL", .{}, arg);
            return self.*;
        }


        /// 
        /// MENU: Name of a menu.
        /// Associates a menu to the dialog as a menu bar.
        /// The previous menu, if any, is unmapped.
        /// Use IupSetHandle or IupSetAttributeHandle to associate a menu to a name.
        /// See also IupMenu.
        pub fn setMenu(self: *Initializer, arg: *iup.Menu) Initializer {
            c.setHandleAttribute(self.ref, "MENU", .{}, arg);
            return self.*;
        }

        pub fn setNoFlush(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "NOFLUSH", .{}, arg);
            return self.*;
        }


        /// 
        /// MAXSIZE: Maximum size for the dialog in raster units (pixels).
        /// The windowing system will not be able to change the size beyond this limit.
        /// Default: 65535x65535.
        /// (since 3.0)
        pub fn setMaxSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "MAXSIZE", .{}, value);
            return self.*;
        }


        /// 
        /// TRAYTIPBALLOONTITLEICON [Windows Only]: When using the balloon format, the
        /// tip can also has a pre-defined icon in the title area.
        /// Must be set before setting the TRAYTIP attribute.
        /// (since 3.6)
        pub fn setTrayTipBalloonTitleIcon(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "TRAYTIPBALLOONTITLEICON", .{}, arg);
            return self.*;
        }


        /// 
        /// OPACITYIMAGE [Windows Only]: sets an RGBA image as the dialog background so
        /// it is possible to create a non rectangle window with transparency, but it
        /// can not have children.
        /// Used usually for splash screens.
        /// It must be set before map so the native window would be properly
        /// initialized when mapped.
        /// Works also for GTK but as the SHAPEIMAGE attribute.
        /// (since 3.16)
        pub fn setOpacityImage(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "OPACITYIMAGE", .{}, arg);
            return self.*;
        }


        /// 
        /// HELPBUTTON [Windows Only] (creation only): Inserts a help button in the
        /// same place of the maximize button.
        /// It can only be used for dialogs without the minimize and maximize buttons,
        /// and with the menu box.
        /// For the next interaction of the user with a control in the dialog, the
        /// callback HELP_CB will be called instead of the control defined ACTION callback.
        /// Possible values: YES, NO.
        /// Default: NO.
        pub fn setHelpButton(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "HELPBUTTON", .{}, arg);
            return self.*;
        }


        /// 
        /// SHOWNOFOCUS: do not set focus after show.
        /// (since 3.30)
        pub fn setShowNoFocus(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "SHOWNOFOCUS", .{}, arg);
            return self.*;
        }


        /// 
        /// MAXIMIZEATPARENT [Windows Only]: when using multiple monitors, maximize the
        /// dialog in the same monitor that the parent dialog is.
        /// (since 3.28)
        pub fn setMaximizeAtParent(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "MAXIMIZEATPARENT", .{}, arg);
            return self.*;
        }


        /// 
        /// OPACITY [Windows and GTK Only]: sets the dialog transparency alpha value.
        /// Valid values range from 0 (completely transparent) to 255 (opaque).
        /// In Windows must be set before map so the native window would be properly
        /// initialized when mapped (since 3.16).
        /// (GTK 2.12)
        pub fn setOpacity(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "OPACITY", .{}, arg);
            return self.*;
        }

        pub fn setPosition(self: *Initializer, x: i32, y: i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
            c.setStrAttribute(self.ref, "POSITION", .{}, value);
            return self.*;
        }


        /// 
        /// COMPOSITED [Windows Only] (creation only): controls if the window will have
        /// an automatic double buffer for all children.
        /// Default is "NO".
        /// In Windows Vista it is NOT working as expected.
        /// It is NOT compatible with IupCanvas and all derived IUP controls such as
        /// IupFlat*, IupGL*, IupPlot and IupMatrix, because IupCanvas uses CS_OWNDC in
        /// the window class.
        pub fn setComposited(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "COMPOSITED", .{}, arg);
            return self.*;
        }


        /// 
        /// DROPFILESTARGET [Windows and GTK Only] (non inheritable): Enable or disable
        /// the drop of files.
        /// Default: NO, but if DROPFILES_CB is defined when the element is mapped then
        /// it will be automatically enabled.
        pub fn setDropFilesTarget(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "DROPFILESTARGET", .{}, arg);
            return self.*;
        }

        pub fn setTip(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "TIP", .{}, arg);
            return self.*;
        }

        pub fn setCanFocus(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "CANFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setDragSourceMove(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "DRAGSOURCEMOVE", .{}, arg);
            return self.*;
        }


        /// 
        /// ICON: Dialogs icon.
        /// The Windows SDK recommends that cursors and icons should be implemented as
        /// resources rather than created at run time.
        pub fn setIcon(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "ICON", .{}, arg);
            return self.*;
        }


        /// 
        /// VISIBLE: Simply call IupShow or IupHide for the dialog.
        pub fn setVisible(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "VISIBLE", .{}, arg);
            return self.*;
        }


        /// 
        /// CUSTOMFRAMEDRAW [Windows Only] (non inheritable): allows the application to
        /// customize the dialog frame elements (the title and its buttons) by drawing
        /// them with the CUSTOMFRAMEDRAW_CB callback.
        /// Can be Yes or No.
        /// The Window client area is expanded to include the whole window.
        /// Notice that the dialog attributes like BORDER, RESIZE, MAXBOX, MINBOX and
        /// TITLE must still be defined.
        /// But maximize, minimize and close buttons must be manually implemented in
        /// the BUTTON_CB callback.
        /// One drawback is that menu bars will not work.
        /// (since 3.18) (renamed in 3.22)
        pub fn setCustomFrameDraw(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "CUSTOMFRAMEDRAW", .{}, arg);
            return self.*;
        }


        /// 
        /// CURSOR (non inheritable): Defines a cursor for the dialog.
        pub fn setCursor(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "CURSOR", .{}, arg);
            return self.*;
        }


        /// 
        /// MENUBOX (creation only): Requires a system menu box from the window manager.
        /// If hidden will also remove the Close button.
        /// Default: YES.
        /// In Motif the decorations are controlled by the Window Manager and may not
        /// be possible to be changed from IUP.
        /// In Windows if hidden will hide also MAXBOX and MINBOX.
        pub fn setMenuBox(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "MENUBOX", .{}, arg);
            return self.*;
        }

        pub fn zOrder(self: *Initializer, arg: ?ZOrder) Initializer {
            if (arg) |value| switch (value) {
                .Top => c.setStrAttribute(self.ref, "ZORDER", .{}, "TOP"),
                .Bottom => c.setStrAttribute(self.ref, "ZORDER", .{}, "BOTTOM"),
            } else {
                c.clearAttribute(self.ref, "ZORDER", .{});
            }
            return self.*;
        }


        /// 
        /// MAXBOX (creation only): Requires a maximize button from the window manager.
        /// If RESIZE=NO then MAXBOX will be set to NO.
        /// Default: YES.
        /// In Motif the decorations are controlled by the Window Manager and may not
        /// be possible to be changed from IUP.
        /// In Windows MAXBOX is hidden only if MINBOX is hidden as well, or else it
        /// will be just disabled.
        pub fn setMaxBox(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "MAXBOX", .{}, arg);
            return self.*;
        }

        pub fn setDragDrop(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "DRAGDROP", .{}, arg);
            return self.*;
        }


        /// 
        /// DIALOGHINT [GTK Only] (creation-only): if enabled sets the window type hint
        /// to a dialog hint.
        pub fn setDialogHint(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "DIALOGHINT", .{}, arg);
            return self.*;
        }

        pub fn setShowMinimizeNext(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "SHOWMINIMIZENEXT", .{}, arg);
            return self.*;
        }


        /// 
        /// DIALOGFRAME: Set the common decorations for modal dialogs.
        /// This means RESIZE=NO, MINBOX=NO and MAXBOX=NO.
        /// In Windows, if the PARENTDIALOG is defined then the MENUBOX is also
        /// removed, but the Close button remains.
        pub fn setDialogFrame(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "DIALOGFRAME", .{}, arg);
            return self.*;
        }


        /// 
        /// NACTIVE (non inheritable): same as ACTIVE but does not affects the controls
        /// inside the dialog.
        /// (since 3.13)
        pub fn setNActive(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "NACTIVE", .{}, arg);
            return self.*;
        }


        /// 
        /// TRAYTIPBALLOONTITLE [Windows Only]: When using the balloon format, the tip
        /// can also has a title in a separate area.
        /// Must be set before setting the TRAYTIP attribute.
        /// (since 3.6)
        pub fn setTrayTipBalloonTitle(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "TRAYTIPBALLOONTITLE", .{}, arg);
            return self.*;
        }

        pub fn setTheme(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "THEME", .{}, arg);
            return self.*;
        }


        /// 
        /// SAVEUNDER [Windows and Motif Only] (creation only): When this attribute is
        /// true (YES), the dialog stores the original image of the desktop region it
        /// occupies (if the system has enough memory to store the image).
        /// In this case, when the dialog is closed or moved, a redrawing event is not
        /// generated for the windows that were shadowed by it.
        /// Its default value is YES if the dialog has a parent dialog (since 3.24).
        /// To save memory disable it for your main dialog.
        /// Not available in GTK.
        pub fn setSaveUnder(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "SAVEUNDER", .{}, arg);
            return self.*;
        }


        /// 
        /// TRAY [Windows and GTK Only]: When set to "YES", displays an icon on the
        /// system tray.
        /// (GTK 2.10 and GTK < 3.14)
        pub fn setTray(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "TRAY", .{}, arg);
            return self.*;
        }

        pub fn setDragCursorCopy(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "DRAGCURSORCOPY", .{}, arg);
            return self.*;
        }


        /// 
        /// TASKBARPROGRESS [Windows Only] (write-only): this functionality enables the
        /// use of progress bar on a taskbar button (Windows 7 or earlier version)
        /// (Available only for Visual C++ 10 and above).
        /// Default: NO (since 3.10).
        pub fn setTaskbarProgress(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "TASKBARPROGRESS", .{}, arg);
            return self.*;
        }


        /// 
        /// CHILDOFFSET: Allow to specify a position offset for the child.
        /// Available for native containers only.
        /// It will not affect the natural size, and allows to position controls
        /// outside the client area.
        /// Format "dxxdy", where dx and dy are integer values corresponding to the
        /// horizontal and vertical offsets, respectively, in pixels.
        /// Default: 0x0.
        /// (since 3.14)
        pub fn setChildOffset(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "CHILDOFFSET", .{}, value);
            return self.*;
        }


        /// 
        /// EXPAND (non inheritable): The default value is "YES".
        pub fn setExpand(self: *Initializer, arg: ?Expand) Initializer {
            if (arg) |value| switch (value) {
                .Yes => c.setStrAttribute(self.ref, "EXPAND", .{}, "YES"),
                .Horizontal => c.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTAL"),
                .Vertical => c.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICAL"),
                .HorizontalFree => c.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTALFREE"),
                .VerticalFree => c.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICALFREE"),
                .No => c.setStrAttribute(self.ref, "EXPAND", .{}, "NO"),
            } else {
                c.clearAttribute(self.ref, "EXPAND", .{});
            }
            return self.*;
        }


        /// 
        /// SIZE (non inheritable): Dialogs size.
        /// Additionally the following values can also be defined for width and/or
        /// height: "FULL": Defines the dialogs width (or height) equal to the screen's
        /// width (or height) "HALF": Defines the dialogs width (or height) equal to
        /// half the screen's width (or height) "THIRD": Defines the dialogs width (or
        /// height) equal to 1/3 the screen's width (or height) "QUARTER": Defines the
        /// dialogs width (or height) equal to 1/4 of the screen's width (or height)
        /// "EIGHTH": Defines the dialogs width (or height) equal to 1/8 of the
        /// screen's width (or height).
        /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
        /// accepted, regardless of the minimum size required by its children.
        /// For a dialog to have the minimum necessary size to fit all elements
        /// contained in it, simply define SIZE or RASTERSIZE to NULL.
        /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
        /// dialog, its contents will be limited to this size as the minimum size, if
        /// you do not want that, then after showing the dialog reset this size to NULL
        /// so the dialog can be resized to smaller values.
        /// But notice that its contents will still be limited by the Natural size, to
        /// also remove that limitation set SHRINK=YES.
        /// To only change the User size in pixels, without resetting the Current size,
        /// set the USERSIZE attribute (since 3.12).
        /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
        /// accepted, regardless of the minimum size required by its children.
        /// For a dialog to have the minimum necessary size to fit all elements
        /// contained in it, simply define SIZE or RASTERSIZE to NULL.
        /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
        /// dialog, its contents will be limited to this size as the minimum size, if
        /// you do not want that, then after showing the dialog reset this size to NULL
        /// so the dialog can be resized to smaller values.
        /// But notice that its contents will still be limited by the Natural size, to
        /// also remove that limitation set SHRINK=YES.
        /// To only change the User size in pixels, without resetting the Current size,
        /// set the USERSIZE attribute (since 3.12).
        /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
        /// accepted, regardless of the minimum size required by its children.
        /// For a dialog to have the minimum necessary size to fit all elements
        /// contained in it, simply define SIZE or RASTERSIZE to NULL.
        /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
        /// dialog, its contents will be limited to this size as the minimum size, if
        /// you do not want that, then after showing the dialog reset this size to NULL
        /// so the dialog can be resized to smaller values.
        /// But notice that its contents will still be limited by the Natural size, to
        /// also remove that limitation set SHRINK=YES.
        /// To only change the User size in pixels, without resetting the Current size,
        /// set the USERSIZE attribute (since 3.12).
        pub fn setSize(self: *Initializer, width: ?iup.ScreenSize, height: ?iup.ScreenSize) Initializer {
            var buffer: [128]u8 = undefined;
            var str = iup.DialogSize.screenSizeToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "SIZE", .{}, str);
            return self.*;
        }


        /// 
        /// MDIMENU (creation only) [Windows Only]: Name of a IupMenu to be used as the
        /// Window list of a MDI frame.
        /// The system will automatically add the list of MDI child windows there.
        pub fn setMdiMenu(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "MDIMENU", .{}, arg);
            return self.*;
        }


        /// 
        /// STARTFOCUS: Name of the element that must receive the focus right after the
        /// dialog is shown using IupShow or IupPopup.
        /// If not defined then the first control than can receive the focus is
        /// selected (same effect of calling IupNextField for the dialog).
        /// Updated after SHOW_CB is called and only if the focus was not changed
        /// during the callback.
        pub fn setStartFocus(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "STARTFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setFontSize(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "FONTSIZE", .{}, arg);
            return self.*;
        }

        pub fn setTrayTipDelay(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "TRAYTIPDELAY", .{}, arg);
            return self.*;
        }

        pub fn setDropTypes(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "DROPTYPES", .{}, arg);
            return self.*;
        }

        pub fn setUserSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "USERSIZE", .{}, value);
            return self.*;
        }

        pub fn setTipDelay(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "TIPDELAY", .{}, arg);
            return self.*;
        }


        /// 
        /// CUSTOMFRAMECAPTIONLIMITS [Windows Only] (non inheritable): limits of the
        /// caption area at left and at right.
        /// The caption area is always expanded inside the limits when the dialog is resized.
        /// Format is "left:right" or in C "%d:%d".
        /// Default: "0:0".
        /// This will allow the dialog to be moved by the system when the user click
        /// and drag the caption area.
        /// If not defined but CUSTOMFRAMECAPTION is defined, then it will use the
        /// caption element horizontal position and size for the limits (since 3.22).
        /// (since 3.18)
        pub fn setCustomFrameCaptionLimits(self: *Initializer, begin: i32, end: i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = iup.Range.intIntToString(&buffer, begin, end, ',');
            c.setStrAttribute(self.ref, "CUSTOMFRAMECAPTIONLIMITS", .{}, value);
            return self.*;
        }

        pub fn setDragStart(self: *Initializer, x: i32, y: i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
            c.setStrAttribute(self.ref, "DRAGSTART", .{}, value);
            return self.*;
        }


        /// 
        /// CUSTOMFRAME [Windows and GTK Only] (non inheritable): allows the
        /// application to customize the dialog frame elements (the title and its
        /// buttons) by using IUP controls for its elements like caption, minimize
        /// button, maximize button, and close buttons.
        /// The custom frame support uses the native system support for custom frames.
        /// The application is responsible for leaving space for the borders.
        /// One drawback is that menu bars will not work.
        /// For the dialog to be able to be moved an IupLabel or an IupCanvas must be
        /// at the top of the dialog and must have the NAME attribute set to
        /// CUSTOMFRAMECAPTION (since 3.22).
        /// Native custom frames are supported only in Windows and in GTK version 3.10,
        /// so for older GTK versions we have to simulate the support using CUSTOMFRAMESIMULATE.
        /// (since 3.18) (renamed in 3.22) (GTK support since 3.22) See the Custom
        /// Frame notes bellow.
        pub fn setCustomFrame(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "CUSTOMFRAME", .{}, arg);
            return self.*;
        }


        /// 
        /// TITLE (non inheritable): Dialogs title.
        /// Default: NULL.
        /// If you want to remove the title bar you must also set MENUBOX=NO, MAXBOX=NO
        /// and MINBOX=NO, before map.
        /// But in Motif and GTK it will hide it only if RESIZE=NO also.
        pub fn setTitle(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "TITLE", .{}, arg);
            return self.*;
        }


        /// 
        /// DEFAULTESC: Name of the button activated when the user press Esc when focus
        /// is in another control of the dialog.
        /// Use IupSetHandle or IupSetAttributeHandle to associate a button to a name.
        pub fn setDefaultEsc(self: *Initializer, arg: *iup.Button) Initializer {
            c.setHandleAttribute(self.ref, "DEFAULTESC", .{}, arg);
            return self.*;
        }


        /// 
        /// PLACEMENT: Changes how the dialog will be shown.
        /// Values: "FULL", "MAXIMIZED", "MINIMIZED" and "NORMAL".
        /// Default: NORMAL.
        /// After IupShow/IupPopup the attribute is set back to "NORMAL".
        /// FULL is similar to FULLSCREEN but only the dialog client area covers the
        /// screen area, menu and decorations will be there but out of the screen.
        /// In UNIX there is a chance that the placement won't work correctly, that
        /// depends on the Window Manager.
        /// In Windows, the SHOWNOACTIVATE attribute can be set to Yes to prevent the
        /// window from being activated (since 3.15).
        /// In Windows, the SHOWMINIMIZENEXT attribute can be set to Yes to activate
        /// the next top-level window in the Z order when minimizing (since 3.15).
        pub fn setPlacement(self: *Initializer, arg: ?Placement) Initializer {
            if (arg) |value| switch (value) {
                .Maximized => c.setStrAttribute(self.ref, "PLACEMENT", .{}, "MAXIMIZED"),
                .Minimized => c.setStrAttribute(self.ref, "PLACEMENT", .{}, "MINIMIZED"),
                .Full => c.setStrAttribute(self.ref, "PLACEMENT", .{}, "FULL"),
            } else {
                c.clearAttribute(self.ref, "PLACEMENT", .{});
            }
            return self.*;
        }

        pub fn setLayerAlpha(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "LAYERALPHA", .{}, arg);
            return self.*;
        }

        pub fn setPropagateFocus(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "PROPAGATEFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setBgColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            c.setRgb(self.ref, "BGCOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setTipBalloonTitle(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "TIPBALLOONTITLE", .{}, arg);
            return self.*;
        }

        pub fn setDropTarget(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "DROPTARGET", .{}, arg);
            return self.*;
        }


        /// 
        /// TRAYTIPBALLOON [Windows Only]: The tip window will have the appearance of a
        /// cartoon "balloon" with rounded corners and a stem pointing to the item.
        /// Default: NO.
        /// Must be set before setting the TRAYTIP attribute.
        /// (since 3.6)
        pub fn setTrayTipBalloon(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "TRAYTIPBALLOON", .{}, arg);
            return self.*;
        }

        pub fn setDragSource(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "DRAGSOURCE", .{}, arg);
            return self.*;
        }


        /// 
        /// RESIZE (creation only): Allows interactively changing the dialogs size.
        /// Default: YES.
        /// If RESIZE=NO then MAXBOX will be set to NO.
        /// In Motif the decorations are controlled by the Window Manager and may not
        /// be possible to be changed from IUP.
        pub fn setResize(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "RESIZE", .{}, arg);
            return self.*;
        }


        /// 
        /// MDIARRANGE [Windows Only] (write-only): Action to arrange MDI child windows.
        /// Possible values: TILEHORIZONTAL, TILEVERTICAL, CASCADE and ICON (arrange
        /// the minimized icons).
        pub fn mdiArrange(self: *Initializer, arg: ?MdiArrange) Initializer {
            if (arg) |value| switch (value) {
                .TileHorizontal => c.setStrAttribute(self.ref, "MDIARRANGE", .{}, "TILEHORIZONTAL"),
                .TileVertical => c.setStrAttribute(self.ref, "MDIARRANGE", .{}, "TILEVERTICAL"),
                .Cascade => c.setStrAttribute(self.ref, "MDIARRANGE", .{}, "CASCADE"),
                .Icon => c.setStrAttribute(self.ref, "MDIARRANGE", .{}, "ICON"),
            } else {
                c.clearAttribute(self.ref, "MDIARRANGE", .{});
            }
            return self.*;
        }

        pub fn setFloating(self: *Initializer, arg: ?Floating) Initializer {
            if (arg) |value| switch (value) {
                .Yes => c.setStrAttribute(self.ref, "FLOATING", .{}, "YES"),
                .Ignore => c.setStrAttribute(self.ref, "FLOATING", .{}, "IGNORE"),
                .No => c.setStrAttribute(self.ref, "FLOATING", .{}, "NO"),
            } else {
                c.clearAttribute(self.ref, "FLOATING", .{});
            }
            return self.*;
        }

        pub fn setNormalizerGroup(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "NORMALIZERGROUP", .{}, arg);
            return self.*;
        }


        /// 
        /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
        /// accepted, regardless of the minimum size required by its children.
        /// For a dialog to have the minimum necessary size to fit all elements
        /// contained in it, simply define SIZE or RASTERSIZE to NULL.
        /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
        /// dialog, its contents will be limited to this size as the minimum size, if
        /// you do not want that, then after showing the dialog reset this size to NULL
        /// so the dialog can be resized to smaller values.
        /// But notice that its contents will still be limited by the Natural size, to
        /// also remove that limitation set SHRINK=YES.
        /// To only change the User size in pixels, without resetting the Current size,
        /// set the USERSIZE attribute (since 3.12).
        /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
        /// accepted, regardless of the minimum size required by its children.
        /// For a dialog to have the minimum necessary size to fit all elements
        /// contained in it, simply define SIZE or RASTERSIZE to NULL.
        /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
        /// dialog, its contents will be limited to this size as the minimum size, if
        /// you do not want that, then after showing the dialog reset this size to NULL
        /// so the dialog can be resized to smaller values.
        /// But notice that its contents will still be limited by the Natural size, to
        /// also remove that limitation set SHRINK=YES.
        /// To only change the User size in pixels, without resetting the Current size,
        /// set the USERSIZE attribute (since 3.12).
        /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
        /// accepted, regardless of the minimum size required by its children.
        /// For a dialog to have the minimum necessary size to fit all elements
        /// contained in it, simply define SIZE or RASTERSIZE to NULL.
        /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
        /// dialog, its contents will be limited to this size as the minimum size, if
        /// you do not want that, then after showing the dialog reset this size to NULL
        /// so the dialog can be resized to smaller values.
        /// But notice that its contents will still be limited by the Natural size, to
        /// also remove that limitation set SHRINK=YES.
        /// To only change the User size in pixels, without resetting the Current size,
        /// set the USERSIZE attribute (since 3.12).
        pub fn setRasterSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "RASTERSIZE", .{}, value);
            return self.*;
        }


        /// 
        /// SHAPEIMAGE [Windows and GTK Only]: sets a RGBA image as the dialog shape so
        /// it is possible to create a non rectangle window with children.
        /// (GTK 2.12) Only the fully transparent pixels will be transparent.
        /// The pixels colors will be ignored, only the alpha channel is used.
        /// (since 3.26)
        pub fn setShapeImage(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "SHAPEIMAGE", .{}, arg);
            return self.*;
        }

        pub fn setTipFgColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            c.setRgb(self.ref, "TIPFGCOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setControlId(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "CONTROLID", .{}, arg);
            return self.*;
        }

        pub fn setShowNoActivate(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "SHOWNOACTIVATE", .{}, arg);
            return self.*;
        }

        pub fn setFontFace(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "FONTFACE", .{}, arg);
            return self.*;
        }

        pub fn setMaximizeAtDialog(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "MAXIMIZEATDIALOG", .{}, arg);
            return self.*;
        }


        /// 
        /// TOPMOST [Windows and GTK Only]: puts the dialog always in front of all
        /// other dialogs in all applications.
        /// Default: NO.
        pub fn topMost(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "TOPMOST", .{}, arg);
            return self.*;
        }


        /// 
        /// TASKBARBUTTON [Windows Only]: If set to SHOW force the application button
        /// to be shown on the taskbar even if the dialog does not have decorations.
        /// If set to HIDE force the application button to be hidden from the taskbar,
        /// but also in this case the system menu, the maximize and minimize buttons
        /// will be hidden.
        /// (since 3.28)
        pub fn setTaskbarButton(self: *Initializer, arg: ?TaskbarButton) Initializer {
            if (arg) |value| switch (value) {
                .Show => c.setStrAttribute(self.ref, "TASKBARBUTTON", .{}, "SHOW"),
                .Hide => c.setStrAttribute(self.ref, "TASKBARBUTTON", .{}, "HIDE"),
            } else {
                c.clearAttribute(self.ref, "TASKBARBUTTON", .{});
            }
            return self.*;
        }

        pub fn setName(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "NAME", .{}, arg);
            return self.*;
        }


        /// 
        /// MINBOX (creation only): Requires a minimize button from the window manager.
        /// Default: YES.
        /// In Motif the decorations are controlled by the Window Manager and may not
        /// be possible to be changed from IUP.
        /// In Windows MINBOX is hidden only if MAXBOX is hidden as well, or else it
        /// will be just disabled.
        pub fn setMinBox(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "MINBOX", .{}, arg);
            return self.*;
        }


        /// 
        /// DEFAULTENTER: Name of the button activated when the user press Enter when
        /// focus is in another control of the dialog.
        /// Use IupSetHandle or IupSetAttributeHandle to associate a button to a name.
        pub fn setDefaultEnter(self: *Initializer, arg: *iup.Button) Initializer {
            c.setHandleAttribute(self.ref, "DEFAULTENTER", .{}, arg);
            return self.*;
        }

        pub fn setTipBalloonTitleIcon(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "TIPBALLOONTITLEICON", .{}, arg);
            return self.*;
        }


        /// 
        /// PARENTDIALOG (creation only): Name of a dialog to be used as parent.
        pub fn setParentDialog(self: *Initializer, arg: *iup.Dialog) Initializer {
            c.setHandleAttribute(self.ref, "PARENTDIALOG", .{}, arg);
            return self.*;
        }


        /// 
        /// BACKGROUND (non inheritable): Dialog background color or image.
        /// Can be a non inheritable alternative to BGCOLOR or can be the name of an
        /// image to be tiled on the background.
        /// See also the screenshots of the sample.c results with normal background,
        /// changing the dialog BACKGROUND, the dialog BGCOLOR and the children BGCOLOR.
        /// Not working in GTK 3.
        /// (since 3.0)
        pub fn setBackground(self: *Initializer, rgb: iup.Rgb) Initializer {
            c.setRgb(self.ref, "BACKGROUND", .{}, rgb);
            return self.*;
        }


        /// 
        /// HIDETASKBAR [Windows and GTK Only] (write-only): Action attribute that when
        /// set to "YES", hides the dialog, but does not decrement the visible dialog
        /// count, does not call SHOW_CB and does not mark the dialog as hidden inside IUP.
        /// It is usually used to hide the dialog and keep the tray icon working
        /// without closing the main loop.
        /// It has the same effect as setting LOCKLOOP=Yes and normally hiding the dialog.
        /// IMPORTANT: when you hide using HIDETASKBAR, you must show using HIDETASKBAR also.
        /// Possible values: YES, NO.
        pub fn setHideTaskbar(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "HIDETASKBAR", .{}, arg);
            return self.*;
        }


        /// 
        /// BRINGFRONT [Windows Only] (write-only): makes the dialog the foreground window.
        /// Use "YES" to activate it.
        /// Useful for multithreaded applications.
        pub fn setBringFront(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "BRINGFRONT", .{}, arg);
            return self.*;
        }


        /// 
        /// TRAYIMAGE [Windows and GTK Only]: Name of a IUP image to be used as the
        /// tray icon.
        /// The Windows SDK recommends that cursors and icons should be implemented as
        /// resources rather than created at run time.
        /// (GTK 2.10 and GTK < 3.14)
        pub fn setTrayImage(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "TRAYIMAGE", .{}, arg);
            return self.*;
        }


        /// 
        /// ACTIVE, BGCOLOR, FONT, EXPAND, SCREENPOSITION, WID, TIP, CLIENTOFFSET,
        /// CLIENTSIZE, RASTERSIZE, ZORDER: also accepted.
        /// Note that ACTIVE, BGCOLOR and FONT will also affect all the controls inside
        /// the dialog.
        pub fn setActive(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "ACTIVE", .{}, arg);
            return self.*;
        }

        pub fn setTipVisible(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "TIPVISIBLE", .{}, arg);
            return self.*;
        }

        pub fn setExpandWeight(self: *Initializer, arg: f64) Initializer {
            c.setDoubleAttribute(self.ref, "EXPANDWEIGHT", .{}, arg);
            return self.*;
        }


        /// 
        /// MINSIZE: Minimum size for the dialog in raster units (pixels).
        /// The windowing system will not be able to change the size beyond this limit.
        /// Default: 1x1.
        /// Some systems define a very minimum size greater than this, for instance in
        /// Windows the horizontal minimum size includes the window decoration buttons.
        /// (since 3.0)
        pub fn setMinSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "MINSIZE", .{}, value);
            return self.*;
        }


        /// 
        /// CUSTOMFRAMECAPTIONHEIGHT [Windows Only] (non inheritable): height of the
        /// caption area.
        /// If not defined it will use the system size.
        /// (since 3.18) (renamed in 3.22)
        pub fn setCustomFrameCaptionHeight(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "CUSTOMFRAMECAPTIONHEIGHT", .{}, arg);
            return self.*;
        }

        pub fn setNTheme(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "NTHEME", .{}, arg);
            return self.*;
        }


        /// 
        /// BORDER (non inheritable) (creation only): Shows a resize border around the dialog.
        /// Default: "YES".
        /// BORDER=NO is useful only when RESIZE=NO, MAXBOX=NO, MINBOX=NO, MENUBOX=NO
        /// and TITLE=NULL, if any of these are defined there will be always some border.
        pub fn setBorder(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "BORDER", .{}, arg);
            return self.*;
        }


        /// 
        /// CUSTOMFRAMESIMULATE: allows the application to customize the dialog frame
        /// elements (the title and its buttons) by using IUP controls for its elements
        /// like caption, minimize button, maximize button, and close buttons.
        /// The custom frame support is entirely simulated by IUP, no native support
        /// for custom frame is used (this seems to have less drawbacks on the
        /// application behavior).
        /// The application is responsible for leaving space for the borders.
        /// One drawback is that menu bars will not work.
        /// For the dialog to be able to be moved an IupLabel, or a IupFlatLabel or an
        /// IupCanvas must be at the top of the dialog and must have the NAME attribute
        /// set to CUSTOMFRAMECAPTION.
        /// See the Custom Frame notes bellow.
        /// (since 3.28)
        pub fn setCustomFramesImulate(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "CUSTOMFRAMESIMULATE", .{}, arg);
            return self.*;
        }


        /// 
        /// MDICLOSEALL [Windows Only] (write-only): Action to close and destroy all
        /// MDI child windows.
        /// The CLOSE_CB callback will be called for each child.
        pub fn mdiCloseAll(self: *Initializer) Initializer {
            c.setStrAttribute(self.ref, "MDICLOSEALL", .{}, null);
            return self.*;
        }


        /// 
        /// SHRINK: Allows changing the elements distribution when the dialog is
        /// smaller than the minimum size.
        /// Default: NO.
        pub fn setShrink(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "SHRINK", .{}, arg);
            return self.*;
        }

        pub fn setClientSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            c.setStrAttribute(self.ref, "CLIENTSIZE", .{}, value);
            return self.*;
        }


        /// 
        /// TRAYTIP [Windows and GTK Only]: Tray icon's tooltip text.
        /// (GTK 2.10 and GTK < 3.14)
        pub fn setTrayTip(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "TRAYTIP", .{}, arg);
            return self.*;
        }

        pub fn setDragTypes(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "DRAGTYPES", .{}, arg);
            return self.*;
        }


        /// 
        /// TOOLBOX [Windows Only] (creation only): makes the dialog look like a
        /// toolbox with a smaller title bar.
        /// It is only valid if the PARENTDIALOG or NATIVEPARENT attribute is also defined.
        /// Default: NO.
        pub fn setToolBox(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "TOOLBOX", .{}, arg);
            return self.*;
        }


        /// 
        /// MDIFRAME (creation only) [Windows Only] (non inheritable): Configure this
        /// dialog as a MDI frame.
        /// Can be YES or NO.
        /// Default: NO.
        pub fn setMdiFrame(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "MDIFRAME", .{}, arg);
            return self.*;
        }

        pub fn setFontStyle(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "FONTSTYLE", .{}, arg);
            return self.*;
        }

        pub fn setTouch(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "TOUCH", .{}, arg);
            return self.*;
        }


        /// 
        /// MDICHILD (creation only) [Windows Only]: Configure this dialog to be a MDI child.
        /// Can be YES or NO.
        /// The PARENTDIALOG attribute must also be defined.
        /// Each MDI child is automatically named if it does not have one.
        /// Default: NO.
        pub fn setMdiChild(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "MDICHILD", .{}, arg);
            return self.*;
        }


        /// 
        /// TASKBARPROGRESSSTATE [Windows Only] (write-only): sets the type and state
        /// of the progress indicator displayed on a taskbar button.
        /// Possible values: NORMAL (a green bar), PAUSED (a yellow bar), ERROR (a red
        /// bar), INDETERMINATE (a green marquee) and NOPROGRESS (no bar).
        /// Default: NORMAL (since 3.10).
        pub fn taskbarProgressState(self: *Initializer, arg: ?TaskbarProgressState) Initializer {
            if (arg) |value| switch (value) {
                .NoProgress => c.setStrAttribute(self.ref, "TASKBARPROGRESSSTATE", .{}, "NOPROGRESS"),
                .Indeterminate => c.setStrAttribute(self.ref, "TASKBARPROGRESSSTATE", .{}, "INDETERMINATE"),
                .Error => c.setStrAttribute(self.ref, "TASKBARPROGRESSSTATE", .{}, "ERROR"),
                .Paused => c.setStrAttribute(self.ref, "TASKBARPROGRESSSTATE", .{}, "PAUSED"),
                .Normal => c.setStrAttribute(self.ref, "TASKBARPROGRESSSTATE", .{}, "NORMAL"),
            } else {
                c.clearAttribute(self.ref, "TASKBARPROGRESSSTATE", .{});
            }
            return self.*;
        }


        /// 
        /// TASKBARPROGRESSVALUE [Windows Only] (write-only): updates a progress bar
        /// hosted in a taskbar button to show the specific percentage completed of the
        /// full operation.
        /// The value must be between 0 and 100 (since 3.10).
        pub fn taskbarProgressValue(self: *Initializer, arg: i32) Initializer {
            c.setIntAttribute(self.ref, "TASKBARPROGRESSVALUE", .{}, arg);
            return self.*;
        }


        /// 
        /// FULLSCREEN: Makes the dialog occupy the whole screen over any system bars
        /// in the main monitor.
        /// All dialog details, such as title bar, borders, maximize button, etc, are removed.
        /// Possible values: YES, NO.
        /// In Motif you may have to click in the dialog to set its focus.
        /// In Motif if set to YES when the dialog is hidden, then it can not be
        /// changed after it is visible.
        pub fn fullScreen(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "FULLSCREEN", .{}, arg);
            return self.*;
        }

        pub fn setMaximizedIalog(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "MAXIMIZEDIALOG", .{}, arg);
            return self.*;
        }

        pub fn setDragCursor(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "DRAGCURSOR", .{}, arg);
            return self.*;
        }

        pub fn setFont(self: *Initializer, arg: [:0]const u8) Initializer {
            c.setStrAttribute(self.ref, "FONT", .{}, arg);
            return self.*;
        }


        /// 
        /// SIMULATEMODAL (write-only): disable all other visible dialogs, just like
        /// when the dialog is made modal.
        /// (since 3.21)
        pub fn simulateModal(self: *Initializer, arg: bool) Initializer {
            c.setBoolAttribute(self.ref, "SIMULATEMODAL", .{}, arg);
            return self.*;
        }

        pub fn setTouchCallback(self: *Initializer, callback: ?OnTouchFn) Initializer {
            const Handler = CallbackHandler(Self, OnTouchFn, "TOUCH_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// FOCUS_CB: Called when the dialog or any of its children gets the focus, or
        /// when another dialog or any control in another dialog gets the focus.
        /// It is called after the common callbacks GETFOCUS_CB and KILL_FOCUS_CB.
        /// (since 3.21) int function(Ihandle *ih, int focus); [in C]ih:focus_cb(focus:
        /// number) -> (ret: number) [in Lua]
        pub fn setFocusCallback(self: *Initializer, callback: ?OnFocusFn) Initializer {
            const Handler = CallbackHandler(Self, OnFocusFn, "FOCUS_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// K_ANY K_ANY Action generated when a keyboard event occurs.
        /// Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c: number) ->
        /// (ret: number) [in Lua] ih: identifier of the element that activated the event.
        /// c: identifier of typed key.
        /// Please refer to the Keyboard Codes table for a list of possible values.
        /// Returns: If IUP_IGNORE is returned the key is ignored and not processed by
        /// the control and not propagated.
        /// If returns IUP_CONTINUE, the key will be processed and the event will be
        /// propagated to the parent of the element receiving it, this is the default behavior.
        /// If returns IUP_DEFAULT the key is processed but it is not propagated.
        /// IUP_CLOSE will be processed.
        /// Notes Keyboard callbacks depend on the keyboard usage of the control with
        /// the focus.
        /// So if you return IUP_IGNORE the control will usually not process the key.
        /// But be aware that sometimes the control process the key in another event so
        /// even returning IUP_IGNORE the key can get processed.
        /// Although it will not be propagated.
        /// IMPORTANT: The callbacks "K_*" of the dialog or native containers depend on
        /// the IUP_CONTINUE return value to work while the control is in focus.
        /// If the callback does not exists it is automatically propagated to the
        /// parent of the element.
        /// K_* callbacks All defined keys are also callbacks of any element, called
        /// when the respective key is activated.
        /// For example: "K_cC" is also a callback activated when the user press
        /// Ctrl+C, when the focus is at the element or at a children with focus.
        /// This is the way an application can create shortcut keys, also called hot keys.
        /// These callbacks are not available in IupLua.
        /// Affects All elements with keyboard interaction.
        pub fn setKAnyCallback(self: *Initializer, callback: ?OnKAnyFn) Initializer {
            const Handler = CallbackHandler(Self, OnKAnyFn, "K_ANY");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// HELP_CB HELP_CB Action generated when the user press F1 at a control.
        /// In Motif is also activated by the Help button in some workstations keyboard.
        /// Callback void function(Ihandle *ih); [in C] ih:help_cb() -> (ret: number)
        /// [in Lua] ih: identifier of the element that activated the event.
        /// Returns: IUP_CLOSE will be processed.
        /// Affects All elements with user interaction.
        pub fn setHelpCallback(self: *Initializer, callback: ?OnHelpFn) Initializer {
            const Handler = CallbackHandler(Self, OnHelpFn, "HELP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// CLOSE_CB CLOSE_CB Called just before a dialog is closed when the user
        /// clicks the close button of the title bar or an equivalent action.
        /// Callback int function(Ihandle *ih); [in C] ih:close_cb() -> (ret: number)
        /// [in Lua] ih: identifies the element that activated the event.
        /// Returns: if IUP_IGNORE, it prevents the dialog from being closed.
        /// If you destroy the dialog in this callback, you must return IUP_IGNORE.
        /// IUP_CLOSE will be processed.
        /// Affects IupDialog
        pub fn setCloseCallback(self: *Initializer, callback: ?OnCloseFn) Initializer {
            const Handler = CallbackHandler(Self, OnCloseFn, "CLOSE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDropMotionCallback(self: *Initializer, callback: ?OnDropMotionFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropMotionFn, "DROPMOTION_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDragEndCallback(self: *Initializer, callback: ?OnDragEndFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragEndFn, "DRAGEND_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDragBeginCallback(self: *Initializer, callback: ?OnDragBeginFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragBeginFn, "DRAGBEGIN_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setMultiTouchCallback(self: *Initializer, callback: ?OnMultiTouchFn) Initializer {
            const Handler = CallbackHandler(Self, OnMultiTouchFn, "MULTITOUCH_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// MDIACTIVATE_CB [Windows Only]: Called when a MDI child window is activated.
        /// Only the MDI child receive this message.
        /// It is not called when the child is shown for the first time.
        /// int function(Ihandle *ih); [in C]elem:mdiactivate_cb() -> (ret: number) [in
        /// Lua] ih: identifier of the element that activated the event.
        pub fn setMdiActivateCallback(self: *Initializer, callback: ?OnMdiActivateFn) Initializer {
            const Handler = CallbackHandler(Self, OnMdiActivateFn, "MDIACTIVATE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// MAP_CB MAP_CB Called right after an element is mapped and its attributes
        /// updated in IupMap.
        /// When the element is a dialog, it is called after the layout is updated.
        /// For all other elements is called before the layout is updated, so the
        /// element current size will still be 0x0 during MAP_CB (since 3.14).
        /// Callback int function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
        /// Lua] ih: identifier of the element that activated the event.
        /// Affects All that have a native representation.
        pub fn setMapCallback(self: *Initializer, callback: ?OnMapFn) Initializer {
            const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse enters the
        /// native element.
        /// Callback int function(Ihandle *ih); [in C] ih:enterwindow_cb() -> (ret:
        /// number) [in Lua] ih: identifier of the element that activated the event.
        /// Notes When the cursor is moved from one element to another, the call order
        /// in all platforms will be first the LEAVEWINDOW_CB callback of the old
        /// control followed by the ENTERWINDOW_CB callback of the new control.
        /// (since 3.14) If the mouse button is hold pressed and the cursor moves
        /// outside the element the behavior is system dependent.
        /// In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB callbacks are NOT called, in
        /// GTK the callbacks are called.
        /// Affects All controls with user interaction.
        /// See Also LEAVEWINDOW_CB
        pub fn setEnterWindowCallback(self: *Initializer, callback: ?OnEnterWindowFn) Initializer {
            const Handler = CallbackHandler(Self, OnEnterWindowFn, "ENTERWINDOW_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// DESTROY_CB DESTROY_CB Called right before an element is destroyed.
        /// Callback int function(Ihandle *ih); [in C] ih:destroy_cb() -> (ret: number)
        /// [in Lua] ih: identifier of the element that activated the event.
        /// Notes If the dialog is visible then it is hidden before it is destroyed.
        /// The callback will be called right after it is hidden.
        /// The callback will be called before all other destroy procedures.
        /// For instance, if the element has children then it is called before the
        /// children are destroyed.
        /// For language binding implementations use the callback name "LDESTROY_CB" to
        /// release memory allocated by the binding for the element.
        /// Also the callback will be called before the language callback.
        /// Affects All.
        pub fn setDestroyCallback(self: *Initializer, callback: ?OnDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDropDataCallback(self: *Initializer, callback: ?OnDropDataFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropDataFn, "DROPDATA_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses keyboard focus.
        /// This callback is called before the GETFOCUS_CB of the element that gets the focus.
        /// Callback int function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret:
        /// number) [in Lua] ih: identifier of the element that activated the event.
        /// Affects All elements with user interaction, except menus.
        /// In Windows, there are restrictions when using this callback.
        /// From MSDN on WM_KILLFOCUS: "While processing this message, do not make any
        /// function calls that display or activate a window.
        /// This causes the thread to yield control and can cause the application to
        /// stop responding to messages.
        /// See Also GETFOCUS_CB, IupGetFocus, IupSetFocus
        pub fn setKillFocusCallback(self: *Initializer, callback: ?OnKillFocusFn) Initializer {
            const Handler = CallbackHandler(Self, OnKillFocusFn, "KILLFOCUS_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// CUSTOMFRAMEACTIVATE_CB [Windows Only]: Called when the dialog active state
        /// is changed (for instance the user Alt+Tab to another application, or
        /// clicked in another window).
        /// Works only when CUSTOMFRAME or CUSTOMFRAMEEX is defined.
        /// (since 3.23) int function(Ihandle *ih, int active); [in
        /// C]ih:customframeactivate_cb(active: number) -> (ret: number) [in Lua]
        pub fn setCustomFrameActivateCallback(self: *Initializer, callback: ?OnCustomFrameActivateFn) Initializer {
            const Handler = CallbackHandler(Self, OnCustomFrameActivateFn, "CUSTOMFRAMEACTIVATE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDragDataCallback(self: *Initializer, callback: ?OnDragDataFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragDataFn, "DRAGDATA_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDragDataSizeCallback(self: *Initializer, callback: ?OnDragDataSizeFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragDataSizeFn, "DRAGDATASIZE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setCustomFrameDrawCallback(self: *Initializer, callback: ?OnCustomFrameDrawFn) Initializer {
            const Handler = CallbackHandler(Self, OnCustomFrameDrawFn, "CUSTOMFRAMEDRAW_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// SHOW_CB SHOW_CB Called right after the dialog is showed, hidden, maximized,
        /// minimized or restored from minimized/maximized.
        /// This callback is called when those actions were performed by the user or
        /// programmatically by the application.
        /// Callback int function(Ihandle *ih, int state); [in C] ih:show_cb(state:
        /// number) -> (ret: number) [in Lua] ih: identifier of the element that
        /// activated the event.
        /// state: indicates which of the following situations generated the event:
        /// IUP_HIDE (since 3.0) IUP_SHOW IUP_RESTORE (was minimized or maximized)
        /// IUP_MINIMIZE IUP_MAXIMIZE (since 3.0) (not received in Motif when activated
        /// from the maximize button) Returns: IUP_CLOSE will be processed.
        /// Affects IupDialog
        pub fn setShowCallback(self: *Initializer, callback: ?OnShowFn) Initializer {
            const Handler = CallbackHandler(Self, OnShowFn, "SHOW_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// DROPFILES_CB DROPFILES_CB Action called when a file is "dropped" into the control.
        /// When several files are dropped at once, the callback is called several
        /// times, once for each file.
        /// If defined after the element is mapped then the attribute DROPFILESTARGET
        /// must be set to YES.
        /// [Windows and GTK Only] (GTK 2.6) Callback int function(Ihandle *ih, const
        /// char* filename, int num, int x, int y); [in C] ih:dropfiles_cb(filename:
        /// string; num, x, y: number) -> (ret: number) [in Lua] ih: identifier of the
        /// element that activated the event.
        /// filename: Name of the dropped file.
        /// num: Number index of the dropped file.
        /// If several files are dropped, num is the index of the dropped file starting
        /// from "total-1" to "0".
        /// x: X coordinate of the point where the user released the mouse button.
        /// y: Y coordinate of the point where the user released the mouse button.
        /// Returns: If IUP_IGNORE is returned the callback will NOT be called for the
        /// next dropped files, and the processing of dropped files will be interrupted.
        /// Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
        pub fn setDropFilesCallback(self: *Initializer, callback: ?OnDropFilesFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropFilesFn, "DROPFILES_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// RESIZE_CB RESIZE_CB Action generated when the canvas or dialog size is changed.
        /// Callback int function(Ihandle *ih, int width, int height); [in C]
        /// ih:resize_cb(width, height: number) -> (ret: number) [in Lua] ih:
        /// identifier of the element that activated the event.
        /// width: the width of the internal element size in pixels not considering the
        /// decorations (client size) height: the height of the internal element size
        /// in pixels not considering the decorations (client size) Notes For the
        /// dialog, this action is also generated when the dialog is mapped, after the
        /// map and before the show.
        /// When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the canvas scrollbar is
        /// hidden/shown after changing the DX or DY attributes from inside the
        /// callback, the size of the drawing area will immediately change, so the
        /// parameters with and height will be invalid.
        /// To update the parameters consult the DRAWSIZE attribute.
        /// Also activate the drawing toolkit only after updating the DX or DY attributes.
        /// Affects IupCanvas, IupGLCanvas, IupDialog
        pub fn setResizeCallback(self: *Initializer, callback: ?OnResizeFn) Initializer {
            const Handler = CallbackHandler(Self, OnResizeFn, "RESIZE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// UNMAP_CB UNMAP_CB Called right before an element is unmapped.
        /// Callback int function(Ihandle *ih); [in C] ih:unmap_cb() -> (ret: number)
        /// [in Lua] ih: identifier of the element that activated the event.
        /// Affects All that have a native representation.
        pub fn setUnmapCallback(self: *Initializer, callback: ?OnUnmapFn) Initializer {
            const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// TRAYCLICK_CB [Windows and GTK Only]: Called right after the mouse button is
        /// pressed or released over the tray icon.
        /// (GTK 2.10) int function(Ihandle *ih, int but, int pressed, int dclick); [in
        /// C]elem:trayclick_cb(but, pressed, dclick: number) -> (ret: number) [in Lua]
        pub fn setTrayClickCallback(self: *Initializer, callback: ?OnTrayClickFn) Initializer {
            const Handler = CallbackHandler(Self, OnTrayClickFn, "TRAYCLICK_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// GETFOCUS_CB GETFOCUS_CB Action generated when an element is given keyboard focus.
        /// This callback is called after the KILLFOCUS_CB of the element that loosed
        /// the focus.
        /// The IupGetFocus function during the callback returns the element that
        /// loosed the focus.
        /// Callback int function(Ihandle *ih); [in C] ih:getfocus_cb() -> (ret:
        /// number) [in Lua] ih: identifier of the element that received keyboard focus.
        /// Affects All elements with user interaction, except menus.
        /// See Also KILLFOCUS_CB, IupGetFocus, IupSetFocus
        pub fn setGetFocusCallback(self: *Initializer, callback: ?OnGetFocusFn) Initializer {
            const Handler = CallbackHandler(Self, OnGetFocusFn, "GETFOCUS_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setLDestroyCallback(self: *Initializer, callback: ?OnLDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        /// 
        /// LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse leaves the
        /// native element.
        /// Callback int function(Ihandle *ih); [in C] ih:leavewindow_cb() -> (ret:
        /// number) [in Lua] ih: identifier of the element that activated the event.
        /// Notes When the cursor is moved from one element to another, the call order
        /// in all platforms will be first the LEAVEWINDOW_CB callback of the old
        /// control followed by the ENTERWINDOW_CB callback of the new control.
        /// (since 3.14) If the mouse button is hold pressed and the cursor moves
        /// outside the element the behavior is system dependent.
        /// In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB callbacks are NOT called, in
        /// GTK the callbacks are called.
        /// Affects All controls with user interaction.
        /// See Also ENTERWINDOW_CB
        pub fn setLeaveWindowCallback(self: *Initializer, callback: ?OnLeaveWindowFn) Initializer {
            const Handler = CallbackHandler(Self, OnLeaveWindowFn, "LEAVEWINDOW_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setPostMessageCallback(self: *Initializer, callback: ?OnPostMessageFn) Initializer {
            const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }
    };

    pub fn setStrAttribute(self: *Self, attribute: [:0]const u8, arg: [:0]const u8) void {
        c.setStrAttribute(self, attribute, .{}, arg);
    }

    pub fn getStrAttribute(self: *Self, attribute: [:0]const u8) [:0]const u8 {
        return c.getStrAttribute(self, attribute, .{});
    }

    pub fn setIntAttribute(self: *Self, attribute: [:0]const u8, arg: i32) void {
        c.setIntAttribute(self, attribute, .{}, arg);
    }

    pub fn getIntAttribute(self: *Self, attribute: [:0]const u8) i32 {
        return c.getIntAttribute(self, attribute, .{});
    }

    pub fn setBoolAttribute(self: *Self, attribute: [:0]const u8, arg: bool) void {
        c.setBoolAttribute(self, attribute, .{}, arg);
    }

    pub fn getBoolAttribute(self: *Self, attribute: [:0]const u8) bool {
        return c.getBoolAttribute(self, attribute, .{});
    }

    pub fn getPtrAttribute(handle: *Self, comptime T: type, attribute: [:0]const u8) ?*T {
        return c.getPtrAttribute(T, handle, attribute, .{});
    }

    pub fn setPtrAttribute(handle: *Self, comptime T: type, attribute: [:0]const u8, value: ?*T) void {
        c.setPtrAttribute(T, handle, attribute, .{}, value);
    }

    ///
    /// Creates an interface element given its class name and parameters.
    /// After creation the element still needs to be attached to a container and mapped to the native system so it can be visible.
    pub fn init() Initializer {
        var handle = c.create(Self);

        if (handle) |valid| {
            return .{
                .ref = @ptrCast(*Self, valid),
            };
        } else {
            return .{ .ref = undefined, .last_error = Error.NotInitialized };
        }
    }

    /// 
    /// Destroys an interface element and all its children.
    /// Only dialogs, timers, popup menus and images should be normally destroyed, but detached elements can also be destroyed.        
    pub fn deinit(self: *Self) void {
        c.destroy(self);
    }

    ///
    /// Adds a tuple of children
    pub fn appendChildren(self: *Self, tuple: anytype) !void {
        try Impl(Self).appendChildren(self, tuple);
    }

    ///
    /// Appends a child on this container
    /// child must be an Element or
    pub fn appendChild(self: *Self, child: anytype) !void {
        try Impl(Self).appendChild(self, child);
    }

    ///
    /// Returns a iterator for children elements.
    pub fn children(self: *Self) ChildrenIterator {
        return ChildrenIterator.init(self);
    }

    pub fn showXY(self: *Self, x: iup.DialogPosX, y: iup.DialogPosY) !void {
        const ret = c.IupShowXY(@ptrCast(*Handle, self), @enumToInt(x), @enumToInt(y));
        if (ret == c.IUP_ERROR) {
            debug.print("{} ret={}\n", .{ Error.OpenFailed, ret });
            return Error.OpenFailed;
        }
    }

    pub fn popup(self: *Self, x: iup.DialogPosX, y: iup.DialogPosY) void {
        _ = c.IupPopup(c.getHandle(self), @enumToInt(x), @enumToInt(y));
    }

    pub fn hide(self: *Self) !void {
        _ = c.IupHide(c.getHandle(self));
    }

    ///
    /// Returns the the child element that has the NAME attribute equals to the given value on the same dialog hierarchy.
    /// Works also for children of a menu that is associated with a dialog.
    pub fn getDialogChild(self: *Self, byName: [:0]const u8) ?Element {
        var child = c.IupGetDialogChild(c.getHandle(self), c.toCStr(byName)) orelse return null;
        var className = c.fromCStr(c.IupGetClassName(child));

        return Element.fromClassName(className, child);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog.
    /// To be used after changing size attributes, or attributes that affect the size of the control. Can be used for any element inside a dialog, but the layout of the dialog and all controls will be updated. It can change the layout of all the controls inside the dialog because of the dynamic layout positioning.
    pub fn refresh(self: *Self) void {
        try Impl(Self).refresh(self);
    }

    pub fn getTipBalloon(self: *Self) bool {
        return c.getBoolAttribute(self, "TIPBALLOON", .{});
    }

    pub fn setTipBalloon(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "TIPBALLOON", .{}, arg);
    }

    pub fn getHandleName(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "HANDLENAME", .{});
    }

    pub fn setHandleName(self: *Self, arg: [:0]const u8) void {
        c.setHandle(self, arg);
    }

    pub fn getTipBgColor(self: *Self) ?iup.Rgb {
        return c.getRgb(self, "TIPBGCOLOR", .{});
    }

    pub fn setTipBgColor(self: *Self, rgb: iup.Rgb) void {
        c.setRgb(self, "TIPBGCOLOR", .{}, rgb);
    }


    /// 
    /// MENU: Name of a menu.
    /// Associates a menu to the dialog as a menu bar.
    /// The previous menu, if any, is unmapped.
    /// Use IupSetHandle or IupSetAttributeHandle to associate a menu to a name.
    /// See also IupMenu.
    pub fn getMenu(self: *Self) ?*iup.Menu {
        if (c.getHandleAttribute(self, "MENU", .{})) |handle| {
            return @ptrCast(*iup.Menu, handle);
        } else {
            return null;
        }
    }


    /// 
    /// MENU: Name of a menu.
    /// Associates a menu to the dialog as a menu bar.
    /// The previous menu, if any, is unmapped.
    /// Use IupSetHandle or IupSetAttributeHandle to associate a menu to a name.
    /// See also IupMenu.
    pub fn setMenu(self: *Self, arg: *iup.Menu) void {
        c.setHandleAttribute(self, "MENU", .{}, arg);
    }

    pub fn getNoFlush(self: *Self) bool {
        return c.getBoolAttribute(self, "NOFLUSH", .{});
    }

    pub fn setNoFlush(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "NOFLUSH", .{}, arg);
    }


    /// 
    /// MAXSIZE: Maximum size for the dialog in raster units (pixels).
    /// The windowing system will not be able to change the size beyond this limit.
    /// Default: 65535x65535.
    /// (since 3.0)
    pub fn getMaxSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "MAXSIZE", .{});
        return Size.parse(str);
    }


    /// 
    /// MAXSIZE: Maximum size for the dialog in raster units (pixels).
    /// The windowing system will not be able to change the size beyond this limit.
    /// Default: 65535x65535.
    /// (since 3.0)
    pub fn setMaxSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "MAXSIZE", .{}, value);
    }


    /// 
    /// TRAYTIPBALLOONTITLEICON [Windows Only]: When using the balloon format, the
    /// tip can also has a pre-defined icon in the title area.
    /// Must be set before setting the TRAYTIP attribute.
    /// (since 3.6)
    pub fn getTrayTipBalloonTitleIcon(self: *Self) i32 {
        return c.getIntAttribute(self, "TRAYTIPBALLOONTITLEICON", .{});
    }


    /// 
    /// TRAYTIPBALLOONTITLEICON [Windows Only]: When using the balloon format, the
    /// tip can also has a pre-defined icon in the title area.
    /// Must be set before setting the TRAYTIP attribute.
    /// (since 3.6)
    pub fn setTrayTipBalloonTitleIcon(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "TRAYTIPBALLOONTITLEICON", .{}, arg);
    }


    /// 
    /// OPACITYIMAGE [Windows Only]: sets an RGBA image as the dialog background so
    /// it is possible to create a non rectangle window with transparency, but it
    /// can not have children.
    /// Used usually for splash screens.
    /// It must be set before map so the native window would be properly
    /// initialized when mapped.
    /// Works also for GTK but as the SHAPEIMAGE attribute.
    /// (since 3.16)
    pub fn getOpacityImage(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "OPACITYIMAGE", .{});
    }


    /// 
    /// OPACITYIMAGE [Windows Only]: sets an RGBA image as the dialog background so
    /// it is possible to create a non rectangle window with transparency, but it
    /// can not have children.
    /// Used usually for splash screens.
    /// It must be set before map so the native window would be properly
    /// initialized when mapped.
    /// Works also for GTK but as the SHAPEIMAGE attribute.
    /// (since 3.16)
    pub fn setOpacityImage(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "OPACITYIMAGE", .{}, arg);
    }


    /// 
    /// SHOWNOFOCUS: do not set focus after show.
    /// (since 3.30)
    pub fn getShowNoFocus(self: *Self) bool {
        return c.getBoolAttribute(self, "SHOWNOFOCUS", .{});
    }


    /// 
    /// SHOWNOFOCUS: do not set focus after show.
    /// (since 3.30)
    pub fn setShowNoFocus(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "SHOWNOFOCUS", .{}, arg);
    }

    pub fn getScreenPosition(self: *Self) iup.XYPos {
        var str = c.getStrAttribute(self, "SCREENPOSITION", .{});
        return iup.XYPos.parse(str, ',');
    }


    /// 
    /// MAXIMIZEATPARENT [Windows Only]: when using multiple monitors, maximize the
    /// dialog in the same monitor that the parent dialog is.
    /// (since 3.28)
    pub fn getMaximizeAtParent(self: *Self) bool {
        return c.getBoolAttribute(self, "MAXIMIZEATPARENT", .{});
    }


    /// 
    /// MAXIMIZEATPARENT [Windows Only]: when using multiple monitors, maximize the
    /// dialog in the same monitor that the parent dialog is.
    /// (since 3.28)
    pub fn setMaximizeAtParent(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "MAXIMIZEATPARENT", .{}, arg);
    }


    /// 
    /// OPACITY [Windows and GTK Only]: sets the dialog transparency alpha value.
    /// Valid values range from 0 (completely transparent) to 255 (opaque).
    /// In Windows must be set before map so the native window would be properly
    /// initialized when mapped (since 3.16).
    /// (GTK 2.12)
    pub fn getOpacity(self: *Self) i32 {
        return c.getIntAttribute(self, "OPACITY", .{});
    }


    /// 
    /// OPACITY [Windows and GTK Only]: sets the dialog transparency alpha value.
    /// Valid values range from 0 (completely transparent) to 255 (opaque).
    /// In Windows must be set before map so the native window would be properly
    /// initialized when mapped (since 3.16).
    /// (GTK 2.12)
    pub fn setOpacity(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "OPACITY", .{}, arg);
    }

    pub fn getPosition(self: *Self) iup.XYPos {
        var str = c.getStrAttribute(self, "POSITION", .{});
        return iup.XYPos.parse(str, ',');
    }

    pub fn setPosition(self: *Self, x: i32, y: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
        c.setStrAttribute(self, "POSITION", .{}, value);
    }


    /// 
    /// DROPFILESTARGET [Windows and GTK Only] (non inheritable): Enable or disable
    /// the drop of files.
    /// Default: NO, but if DROPFILES_CB is defined when the element is mapped then
    /// it will be automatically enabled.
    pub fn getDropFilesTarget(self: *Self) bool {
        return c.getBoolAttribute(self, "DROPFILESTARGET", .{});
    }


    /// 
    /// DROPFILESTARGET [Windows and GTK Only] (non inheritable): Enable or disable
    /// the drop of files.
    /// Default: NO, but if DROPFILES_CB is defined when the element is mapped then
    /// it will be automatically enabled.
    pub fn setDropFilesTarget(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "DROPFILESTARGET", .{}, arg);
    }


    /// 
    /// BORDERSIZE (non inheritable) (read only): returns the border size.
    /// (since 3.18)
    pub fn getBorderSize(self: *Self) i32 {
        return c.getIntAttribute(self, "BORDERSIZE", .{});
    }

    pub fn getTip(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "TIP", .{});
    }

    pub fn setTip(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "TIP", .{}, arg);
    }

    pub fn getCanFocus(self: *Self) bool {
        return c.getBoolAttribute(self, "CANFOCUS", .{});
    }

    pub fn setCanFocus(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "CANFOCUS", .{}, arg);
    }

    pub fn getDragSourceMove(self: *Self) bool {
        return c.getBoolAttribute(self, "DRAGSOURCEMOVE", .{});
    }

    pub fn setDragSourceMove(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "DRAGSOURCEMOVE", .{}, arg);
    }


    /// 
    /// ICON: Dialogs icon.
    /// The Windows SDK recommends that cursors and icons should be implemented as
    /// resources rather than created at run time.
    pub fn getIcon(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "ICON", .{});
    }


    /// 
    /// ICON: Dialogs icon.
    /// The Windows SDK recommends that cursors and icons should be implemented as
    /// resources rather than created at run time.
    pub fn setIcon(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "ICON", .{}, arg);
    }


    /// 
    /// VISIBLE: Simply call IupShow or IupHide for the dialog.
    pub fn getVisible(self: *Self) bool {
        return c.getBoolAttribute(self, "VISIBLE", .{});
    }


    /// 
    /// VISIBLE: Simply call IupShow or IupHide for the dialog.
    pub fn setVisible(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "VISIBLE", .{}, arg);
    }


    /// 
    /// CUSTOMFRAMEDRAW [Windows Only] (non inheritable): allows the application to
    /// customize the dialog frame elements (the title and its buttons) by drawing
    /// them with the CUSTOMFRAMEDRAW_CB callback.
    /// Can be Yes or No.
    /// The Window client area is expanded to include the whole window.
    /// Notice that the dialog attributes like BORDER, RESIZE, MAXBOX, MINBOX and
    /// TITLE must still be defined.
    /// But maximize, minimize and close buttons must be manually implemented in
    /// the BUTTON_CB callback.
    /// One drawback is that menu bars will not work.
    /// (since 3.18) (renamed in 3.22)
    pub fn getCustomFrameDraw(self: *Self) bool {
        return c.getBoolAttribute(self, "CUSTOMFRAMEDRAW", .{});
    }


    /// 
    /// CUSTOMFRAMEDRAW [Windows Only] (non inheritable): allows the application to
    /// customize the dialog frame elements (the title and its buttons) by drawing
    /// them with the CUSTOMFRAMEDRAW_CB callback.
    /// Can be Yes or No.
    /// The Window client area is expanded to include the whole window.
    /// Notice that the dialog attributes like BORDER, RESIZE, MAXBOX, MINBOX and
    /// TITLE must still be defined.
    /// But maximize, minimize and close buttons must be manually implemented in
    /// the BUTTON_CB callback.
    /// One drawback is that menu bars will not work.
    /// (since 3.18) (renamed in 3.22)
    pub fn setCustomFrameDraw(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "CUSTOMFRAMEDRAW", .{}, arg);
    }


    /// 
    /// CURSOR (non inheritable): Defines a cursor for the dialog.
    pub fn getCursor(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "CURSOR", .{});
    }


    /// 
    /// CURSOR (non inheritable): Defines a cursor for the dialog.
    pub fn setCursor(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "CURSOR", .{}, arg);
    }

    pub fn zOrder(self: *Self, arg: ?ZOrder) void {
        if (arg) |value| switch (value) {
            .Top => c.setStrAttribute(self, "ZORDER", .{}, "TOP"),
            .Bottom => c.setStrAttribute(self, "ZORDER", .{}, "BOTTOM"),
        } else {
            c.clearAttribute(self, "ZORDER", .{});
        }
    }

    pub fn getX(self: *Self) i32 {
        return c.getIntAttribute(self, "X", .{});
    }

    pub fn getY(self: *Self) i32 {
        return c.getIntAttribute(self, "Y", .{});
    }


    /// 
    /// MDIACTIVE [Windows Only] (read-only): Returns the name of the current
    /// active MDI child.
    /// Use IupGetAttributeHandle to directly retrieve the child handle.
    pub fn getMdiActive(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "MDIACTIVE", .{});
    }

    pub fn getDragDrop(self: *Self) bool {
        return c.getBoolAttribute(self, "DRAGDROP", .{});
    }

    pub fn setDragDrop(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "DRAGDROP", .{}, arg);
    }


    /// 
    /// DIALOGHINT [GTK Only] (creation-only): if enabled sets the window type hint
    /// to a dialog hint.
    pub fn getDialogHint(self: *Self) bool {
        return c.getBoolAttribute(self, "DIALOGHINT", .{});
    }


    /// 
    /// DIALOGHINT [GTK Only] (creation-only): if enabled sets the window type hint
    /// to a dialog hint.
    pub fn setDialogHint(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "DIALOGHINT", .{}, arg);
    }

    pub fn getShowMinimizeNext(self: *Self) bool {
        return c.getBoolAttribute(self, "SHOWMINIMIZENEXT", .{});
    }

    pub fn setShowMinimizeNext(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "SHOWMINIMIZENEXT", .{}, arg);
    }


    /// 
    /// DIALOGFRAME: Set the common decorations for modal dialogs.
    /// This means RESIZE=NO, MINBOX=NO and MAXBOX=NO.
    /// In Windows, if the PARENTDIALOG is defined then the MENUBOX is also
    /// removed, but the Close button remains.
    pub fn getDialogFrame(self: *Self) bool {
        return c.getBoolAttribute(self, "DIALOGFRAME", .{});
    }


    /// 
    /// DIALOGFRAME: Set the common decorations for modal dialogs.
    /// This means RESIZE=NO, MINBOX=NO and MAXBOX=NO.
    /// In Windows, if the PARENTDIALOG is defined then the MENUBOX is also
    /// removed, but the Close button remains.
    pub fn setDialogFrame(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "DIALOGFRAME", .{}, arg);
    }


    /// 
    /// NACTIVE (non inheritable): same as ACTIVE but does not affects the controls
    /// inside the dialog.
    /// (since 3.13)
    pub fn getNActive(self: *Self) bool {
        return c.getBoolAttribute(self, "NACTIVE", .{});
    }


    /// 
    /// NACTIVE (non inheritable): same as ACTIVE but does not affects the controls
    /// inside the dialog.
    /// (since 3.13)
    pub fn setNActive(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "NACTIVE", .{}, arg);
    }


    /// 
    /// TRAYTIPBALLOONTITLE [Windows Only]: When using the balloon format, the tip
    /// can also has a title in a separate area.
    /// Must be set before setting the TRAYTIP attribute.
    /// (since 3.6)
    pub fn getTrayTipBalloonTitle(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "TRAYTIPBALLOONTITLE", .{});
    }


    /// 
    /// TRAYTIPBALLOONTITLE [Windows Only]: When using the balloon format, the tip
    /// can also has a title in a separate area.
    /// Must be set before setting the TRAYTIP attribute.
    /// (since 3.6)
    pub fn setTrayTipBalloonTitle(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "TRAYTIPBALLOONTITLE", .{}, arg);
    }

    pub fn getTheme(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "THEME", .{});
    }

    pub fn setTheme(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "THEME", .{}, arg);
    }


    /// 
    /// TRAY [Windows and GTK Only]: When set to "YES", displays an icon on the
    /// system tray.
    /// (GTK 2.10 and GTK < 3.14)
    pub fn getTray(self: *Self) bool {
        return c.getBoolAttribute(self, "TRAY", .{});
    }


    /// 
    /// TRAY [Windows and GTK Only]: When set to "YES", displays an icon on the
    /// system tray.
    /// (GTK 2.10 and GTK < 3.14)
    pub fn setTray(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "TRAY", .{}, arg);
    }

    pub fn getDragCursorCopy(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "DRAGCURSORCOPY", .{});
    }

    pub fn setDragCursorCopy(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "DRAGCURSORCOPY", .{}, arg);
    }


    /// 
    /// TASKBARPROGRESS [Windows Only] (write-only): this functionality enables the
    /// use of progress bar on a taskbar button (Windows 7 or earlier version)
    /// (Available only for Visual C++ 10 and above).
    /// Default: NO (since 3.10).
    pub fn getTaskbarProgress(self: *Self) i32 {
        return c.getIntAttribute(self, "TASKBARPROGRESS", .{});
    }


    /// 
    /// TASKBARPROGRESS [Windows Only] (write-only): this functionality enables the
    /// use of progress bar on a taskbar button (Windows 7 or earlier version)
    /// (Available only for Visual C++ 10 and above).
    /// Default: NO (since 3.10).
    pub fn setTaskbarProgress(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "TASKBARPROGRESS", .{}, arg);
    }


    /// 
    /// CHILDOFFSET: Allow to specify a position offset for the child.
    /// Available for native containers only.
    /// It will not affect the natural size, and allows to position controls
    /// outside the client area.
    /// Format "dxxdy", where dx and dy are integer values corresponding to the
    /// horizontal and vertical offsets, respectively, in pixels.
    /// Default: 0x0.
    /// (since 3.14)
    pub fn getChildOffset(self: *Self) Size {
        var str = c.getStrAttribute(self, "CHILDOFFSET", .{});
        return Size.parse(str);
    }


    /// 
    /// CHILDOFFSET: Allow to specify a position offset for the child.
    /// Available for native containers only.
    /// It will not affect the natural size, and allows to position controls
    /// outside the client area.
    /// Format "dxxdy", where dx and dy are integer values corresponding to the
    /// horizontal and vertical offsets, respectively, in pixels.
    /// Default: 0x0.
    /// (since 3.14)
    pub fn setChildOffset(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "CHILDOFFSET", .{}, value);
    }


    /// 
    /// EXPAND (non inheritable): The default value is "YES".
    pub fn getExpand(self: *Self) ?Expand {
        var ret = c.getStrAttribute(self, "EXPAND", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("HORIZONTAL", ret)) return .Horizontal;
        if (std.ascii.eqlIgnoreCase("VERTICAL", ret)) return .Vertical;
        if (std.ascii.eqlIgnoreCase("HORIZONTALFREE", ret)) return .HorizontalFree;
        if (std.ascii.eqlIgnoreCase("VERTICALFREE", ret)) return .VerticalFree;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }


    /// 
    /// EXPAND (non inheritable): The default value is "YES".
    pub fn setExpand(self: *Self, arg: ?Expand) void {
        if (arg) |value| switch (value) {
            .Yes => c.setStrAttribute(self, "EXPAND", .{}, "YES"),
            .Horizontal => c.setStrAttribute(self, "EXPAND", .{}, "HORIZONTAL"),
            .Vertical => c.setStrAttribute(self, "EXPAND", .{}, "VERTICAL"),
            .HorizontalFree => c.setStrAttribute(self, "EXPAND", .{}, "HORIZONTALFREE"),
            .VerticalFree => c.setStrAttribute(self, "EXPAND", .{}, "VERTICALFREE"),
            .No => c.setStrAttribute(self, "EXPAND", .{}, "NO"),
        } else {
            c.clearAttribute(self, "EXPAND", .{});
        }
    }


    /// 
    /// SIZE (non inheritable): Dialogs size.
    /// Additionally the following values can also be defined for width and/or
    /// height: "FULL": Defines the dialogs width (or height) equal to the screen's
    /// width (or height) "HALF": Defines the dialogs width (or height) equal to
    /// half the screen's width (or height) "THIRD": Defines the dialogs width (or
    /// height) equal to 1/3 the screen's width (or height) "QUARTER": Defines the
    /// dialogs width (or height) equal to 1/4 of the screen's width (or height)
    /// "EIGHTH": Defines the dialogs width (or height) equal to 1/8 of the
    /// screen's width (or height).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    pub fn getSize(self: *Self) iup.DialogSize {
        var str = c.getStrAttribute(self, "SIZE", .{});
        return iup.DialogSize.parse(str);
    }


    /// 
    /// SIZE (non inheritable): Dialogs size.
    /// Additionally the following values can also be defined for width and/or
    /// height: "FULL": Defines the dialogs width (or height) equal to the screen's
    /// width (or height) "HALF": Defines the dialogs width (or height) equal to
    /// half the screen's width (or height) "THIRD": Defines the dialogs width (or
    /// height) equal to 1/3 the screen's width (or height) "QUARTER": Defines the
    /// dialogs width (or height) equal to 1/4 of the screen's width (or height)
    /// "EIGHTH": Defines the dialogs width (or height) equal to 1/8 of the
    /// screen's width (or height).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    pub fn setSize(self: *Self, width: ?iup.ScreenSize, height: ?iup.ScreenSize) void {
        var buffer: [128]u8 = undefined;
        var str = iup.DialogSize.screenSizeToString(&buffer, width, height);
        c.setStrAttribute(self, "SIZE", .{}, str);
    }

    pub fn getWId(self: *Self) i32 {
        return c.getIntAttribute(self, "WID", .{});
    }


    /// 
    /// STARTFOCUS: Name of the element that must receive the focus right after the
    /// dialog is shown using IupShow or IupPopup.
    /// If not defined then the first control than can receive the focus is
    /// selected (same effect of calling IupNextField for the dialog).
    /// Updated after SHOW_CB is called and only if the focus was not changed
    /// during the callback.
    pub fn getStartFocus(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "STARTFOCUS", .{});
    }


    /// 
    /// STARTFOCUS: Name of the element that must receive the focus right after the
    /// dialog is shown using IupShow or IupPopup.
    /// If not defined then the first control than can receive the focus is
    /// selected (same effect of calling IupNextField for the dialog).
    /// Updated after SHOW_CB is called and only if the focus was not changed
    /// during the callback.
    pub fn setStartFocus(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "STARTFOCUS", .{}, arg);
    }

    pub fn getFontSize(self: *Self) i32 {
        return c.getIntAttribute(self, "FONTSIZE", .{});
    }

    pub fn setFontSize(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "FONTSIZE", .{}, arg);
    }

    pub fn getNaturalSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "NATURALSIZE", .{});
        return Size.parse(str);
    }

    pub fn getTrayTipDelay(self: *Self) i32 {
        return c.getIntAttribute(self, "TRAYTIPDELAY", .{});
    }

    pub fn setTrayTipDelay(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "TRAYTIPDELAY", .{}, arg);
    }

    pub fn getDropTypes(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "DROPTYPES", .{});
    }

    pub fn setDropTypes(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "DROPTYPES", .{}, arg);
    }

    pub fn getUserSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "USERSIZE", .{});
        return Size.parse(str);
    }

    pub fn setUserSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "USERSIZE", .{}, value);
    }

    pub fn getTipDelay(self: *Self) i32 {
        return c.getIntAttribute(self, "TIPDELAY", .{});
    }

    pub fn setTipDelay(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "TIPDELAY", .{}, arg);
    }


    /// 
    /// CUSTOMFRAMECAPTIONLIMITS [Windows Only] (non inheritable): limits of the
    /// caption area at left and at right.
    /// The caption area is always expanded inside the limits when the dialog is resized.
    /// Format is "left:right" or in C "%d:%d".
    /// Default: "0:0".
    /// This will allow the dialog to be moved by the system when the user click
    /// and drag the caption area.
    /// If not defined but CUSTOMFRAMECAPTION is defined, then it will use the
    /// caption element horizontal position and size for the limits (since 3.22).
    /// (since 3.18)
    pub fn getCustomFrameCaptionLimits(self: *Self) iup.Range {
        var str = c.getStrAttribute(self, "CUSTOMFRAMECAPTIONLIMITS", .{});
        return iup.Range.parse(str, ',');
    }


    /// 
    /// CUSTOMFRAMECAPTIONLIMITS [Windows Only] (non inheritable): limits of the
    /// caption area at left and at right.
    /// The caption area is always expanded inside the limits when the dialog is resized.
    /// Format is "left:right" or in C "%d:%d".
    /// Default: "0:0".
    /// This will allow the dialog to be moved by the system when the user click
    /// and drag the caption area.
    /// If not defined but CUSTOMFRAMECAPTION is defined, then it will use the
    /// caption element horizontal position and size for the limits (since 3.22).
    /// (since 3.18)
    pub fn setCustomFrameCaptionLimits(self: *Self, begin: i32, end: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.Range.intIntToString(&buffer, begin, end, ',');
        c.setStrAttribute(self, "CUSTOMFRAMECAPTIONLIMITS", .{}, value);
    }

    pub fn getDragStart(self: *Self) iup.XYPos {
        var str = c.getStrAttribute(self, "DRAGSTART", .{});
        return iup.XYPos.parse(str, ',');
    }

    pub fn setDragStart(self: *Self, x: i32, y: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
        c.setStrAttribute(self, "DRAGSTART", .{}, value);
    }


    /// 
    /// CUSTOMFRAME [Windows and GTK Only] (non inheritable): allows the
    /// application to customize the dialog frame elements (the title and its
    /// buttons) by using IUP controls for its elements like caption, minimize
    /// button, maximize button, and close buttons.
    /// The custom frame support uses the native system support for custom frames.
    /// The application is responsible for leaving space for the borders.
    /// One drawback is that menu bars will not work.
    /// For the dialog to be able to be moved an IupLabel or an IupCanvas must be
    /// at the top of the dialog and must have the NAME attribute set to
    /// CUSTOMFRAMECAPTION (since 3.22).
    /// Native custom frames are supported only in Windows and in GTK version 3.10,
    /// so for older GTK versions we have to simulate the support using CUSTOMFRAMESIMULATE.
    /// (since 3.18) (renamed in 3.22) (GTK support since 3.22) See the Custom
    /// Frame notes bellow.
    pub fn getCustomFrame(self: *Self) bool {
        return c.getBoolAttribute(self, "CUSTOMFRAME", .{});
    }


    /// 
    /// CUSTOMFRAME [Windows and GTK Only] (non inheritable): allows the
    /// application to customize the dialog frame elements (the title and its
    /// buttons) by using IUP controls for its elements like caption, minimize
    /// button, maximize button, and close buttons.
    /// The custom frame support uses the native system support for custom frames.
    /// The application is responsible for leaving space for the borders.
    /// One drawback is that menu bars will not work.
    /// For the dialog to be able to be moved an IupLabel or an IupCanvas must be
    /// at the top of the dialog and must have the NAME attribute set to
    /// CUSTOMFRAMECAPTION (since 3.22).
    /// Native custom frames are supported only in Windows and in GTK version 3.10,
    /// so for older GTK versions we have to simulate the support using CUSTOMFRAMESIMULATE.
    /// (since 3.18) (renamed in 3.22) (GTK support since 3.22) See the Custom
    /// Frame notes bellow.
    pub fn setCustomFrame(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "CUSTOMFRAME", .{}, arg);
    }


    /// 
    /// MDINEXT [Windows Only] (read-only): Returns the name of the next available
    /// MDI child.
    /// Use IupGetAttributeHandle to directly retrieve the child handle.
    /// Must use MDIACTIVE to retrieve the first child.
    /// If the application is going to destroy the child retrieve the next child
    /// before destroying the current.
    pub fn getMdiNext(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "MDINEXT", .{});
    }


    /// 
    /// TITLE (non inheritable): Dialogs title.
    /// Default: NULL.
    /// If you want to remove the title bar you must also set MENUBOX=NO, MAXBOX=NO
    /// and MINBOX=NO, before map.
    /// But in Motif and GTK it will hide it only if RESIZE=NO also.
    pub fn getTitle(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "TITLE", .{});
    }


    /// 
    /// TITLE (non inheritable): Dialogs title.
    /// Default: NULL.
    /// If you want to remove the title bar you must also set MENUBOX=NO, MAXBOX=NO
    /// and MINBOX=NO, before map.
    /// But in Motif and GTK it will hide it only if RESIZE=NO also.
    pub fn setTitle(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "TITLE", .{}, arg);
    }


    /// 
    /// DEFAULTESC: Name of the button activated when the user press Esc when focus
    /// is in another control of the dialog.
    /// Use IupSetHandle or IupSetAttributeHandle to associate a button to a name.
    pub fn getDefaultEsc(self: *Self) ?*iup.Button {
        if (c.getHandleAttribute(self, "DEFAULTESC", .{})) |handle| {
            return @ptrCast(*iup.Button, handle);
        } else {
            return null;
        }
    }


    /// 
    /// DEFAULTESC: Name of the button activated when the user press Esc when focus
    /// is in another control of the dialog.
    /// Use IupSetHandle or IupSetAttributeHandle to associate a button to a name.
    pub fn setDefaultEsc(self: *Self, arg: *iup.Button) void {
        c.setHandleAttribute(self, "DEFAULTESC", .{}, arg);
    }


    /// 
    /// PLACEMENT: Changes how the dialog will be shown.
    /// Values: "FULL", "MAXIMIZED", "MINIMIZED" and "NORMAL".
    /// Default: NORMAL.
    /// After IupShow/IupPopup the attribute is set back to "NORMAL".
    /// FULL is similar to FULLSCREEN but only the dialog client area covers the
    /// screen area, menu and decorations will be there but out of the screen.
    /// In UNIX there is a chance that the placement won't work correctly, that
    /// depends on the Window Manager.
    /// In Windows, the SHOWNOACTIVATE attribute can be set to Yes to prevent the
    /// window from being activated (since 3.15).
    /// In Windows, the SHOWMINIMIZENEXT attribute can be set to Yes to activate
    /// the next top-level window in the Z order when minimizing (since 3.15).
    pub fn getPlacement(self: *Self) ?Placement {
        var ret = c.getStrAttribute(self, "PLACEMENT", .{});

        if (std.ascii.eqlIgnoreCase("MAXIMIZED", ret)) return .Maximized;
        if (std.ascii.eqlIgnoreCase("MINIMIZED", ret)) return .Minimized;
        if (std.ascii.eqlIgnoreCase("FULL", ret)) return .Full;
        return null;
    }


    /// 
    /// PLACEMENT: Changes how the dialog will be shown.
    /// Values: "FULL", "MAXIMIZED", "MINIMIZED" and "NORMAL".
    /// Default: NORMAL.
    /// After IupShow/IupPopup the attribute is set back to "NORMAL".
    /// FULL is similar to FULLSCREEN but only the dialog client area covers the
    /// screen area, menu and decorations will be there but out of the screen.
    /// In UNIX there is a chance that the placement won't work correctly, that
    /// depends on the Window Manager.
    /// In Windows, the SHOWNOACTIVATE attribute can be set to Yes to prevent the
    /// window from being activated (since 3.15).
    /// In Windows, the SHOWMINIMIZENEXT attribute can be set to Yes to activate
    /// the next top-level window in the Z order when minimizing (since 3.15).
    pub fn setPlacement(self: *Self, arg: ?Placement) void {
        if (arg) |value| switch (value) {
            .Maximized => c.setStrAttribute(self, "PLACEMENT", .{}, "MAXIMIZED"),
            .Minimized => c.setStrAttribute(self, "PLACEMENT", .{}, "MINIMIZED"),
            .Full => c.setStrAttribute(self, "PLACEMENT", .{}, "FULL"),
        } else {
            c.clearAttribute(self, "PLACEMENT", .{});
        }
    }

    pub fn getLayerAlpha(self: *Self) i32 {
        return c.getIntAttribute(self, "LAYERALPHA", .{});
    }

    pub fn setLayerAlpha(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "LAYERALPHA", .{}, arg);
    }

    pub fn getPropagateFocus(self: *Self) bool {
        return c.getBoolAttribute(self, "PROPAGATEFOCUS", .{});
    }

    pub fn setPropagateFocus(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "PROPAGATEFOCUS", .{}, arg);
    }

    pub fn getBgColor(self: *Self) ?iup.Rgb {
        return c.getRgb(self, "BGCOLOR", .{});
    }

    pub fn setBgColor(self: *Self, rgb: iup.Rgb) void {
        c.setRgb(self, "BGCOLOR", .{}, rgb);
    }

    pub fn getTipBalloonTitle(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "TIPBALLOONTITLE", .{});
    }

    pub fn setTipBalloonTitle(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "TIPBALLOONTITLE", .{}, arg);
    }

    pub fn getDropTarget(self: *Self) bool {
        return c.getBoolAttribute(self, "DROPTARGET", .{});
    }

    pub fn setDropTarget(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "DROPTARGET", .{}, arg);
    }


    /// 
    /// TRAYTIPBALLOON [Windows Only]: The tip window will have the appearance of a
    /// cartoon "balloon" with rounded corners and a stem pointing to the item.
    /// Default: NO.
    /// Must be set before setting the TRAYTIP attribute.
    /// (since 3.6)
    pub fn getTrayTipBalloon(self: *Self) bool {
        return c.getBoolAttribute(self, "TRAYTIPBALLOON", .{});
    }


    /// 
    /// TRAYTIPBALLOON [Windows Only]: The tip window will have the appearance of a
    /// cartoon "balloon" with rounded corners and a stem pointing to the item.
    /// Default: NO.
    /// Must be set before setting the TRAYTIP attribute.
    /// (since 3.6)
    pub fn setTrayTipBalloon(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "TRAYTIPBALLOON", .{}, arg);
    }

    pub fn getDragSource(self: *Self) bool {
        return c.getBoolAttribute(self, "DRAGSOURCE", .{});
    }

    pub fn setDragSource(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "DRAGSOURCE", .{}, arg);
    }


    /// 
    /// MDIARRANGE [Windows Only] (write-only): Action to arrange MDI child windows.
    /// Possible values: TILEHORIZONTAL, TILEVERTICAL, CASCADE and ICON (arrange
    /// the minimized icons).
    pub fn mdiArrange(self: *Self, arg: ?MdiArrange) void {
        if (arg) |value| switch (value) {
            .TileHorizontal => c.setStrAttribute(self, "MDIARRANGE", .{}, "TILEHORIZONTAL"),
            .TileVertical => c.setStrAttribute(self, "MDIARRANGE", .{}, "TILEVERTICAL"),
            .Cascade => c.setStrAttribute(self, "MDIARRANGE", .{}, "CASCADE"),
            .Icon => c.setStrAttribute(self, "MDIARRANGE", .{}, "ICON"),
        } else {
            c.clearAttribute(self, "MDIARRANGE", .{});
        }
    }


    /// 
    /// MAXIMIZED [Windows and GTK Only] (read-only): indicates if the dialog is maximized.
    /// Can be YES or NO.
    /// (since 3.12)
    pub fn getMaximized(self: *Self) bool {
        return c.getBoolAttribute(self, "MAXIMIZED", .{});
    }

    pub fn getFloating(self: *Self) ?Floating {
        var ret = c.getStrAttribute(self, "FLOATING", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("IGNORE", ret)) return .Ignore;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }

    pub fn setFloating(self: *Self, arg: ?Floating) void {
        if (arg) |value| switch (value) {
            .Yes => c.setStrAttribute(self, "FLOATING", .{}, "YES"),
            .Ignore => c.setStrAttribute(self, "FLOATING", .{}, "IGNORE"),
            .No => c.setStrAttribute(self, "FLOATING", .{}, "NO"),
        } else {
            c.clearAttribute(self, "FLOATING", .{});
        }
    }

    pub fn getNormalizerGroup(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "NORMALIZERGROUP", .{});
    }

    pub fn setNormalizerGroup(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "NORMALIZERGROUP", .{}, arg);
    }


    /// 
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    pub fn getRasterSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "RASTERSIZE", .{});
        return Size.parse(str);
    }


    /// 
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    /// Values set at SIZE or RASTERSIZE attributes of a dialog are always
    /// accepted, regardless of the minimum size required by its children.
    /// For a dialog to have the minimum necessary size to fit all elements
    /// contained in it, simply define SIZE or RASTERSIZE to NULL.
    /// Also if you set SIZE or RASTERSIZE to be used as the initial size of the
    /// dialog, its contents will be limited to this size as the minimum size, if
    /// you do not want that, then after showing the dialog reset this size to NULL
    /// so the dialog can be resized to smaller values.
    /// But notice that its contents will still be limited by the Natural size, to
    /// also remove that limitation set SHRINK=YES.
    /// To only change the User size in pixels, without resetting the Current size,
    /// set the USERSIZE attribute (since 3.12).
    pub fn setRasterSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "RASTERSIZE", .{}, value);
    }


    /// 
    /// SHAPEIMAGE [Windows and GTK Only]: sets a RGBA image as the dialog shape so
    /// it is possible to create a non rectangle window with children.
    /// (GTK 2.12) Only the fully transparent pixels will be transparent.
    /// The pixels colors will be ignored, only the alpha channel is used.
    /// (since 3.26)
    pub fn getShapeImage(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "SHAPEIMAGE", .{});
    }


    /// 
    /// SHAPEIMAGE [Windows and GTK Only]: sets a RGBA image as the dialog shape so
    /// it is possible to create a non rectangle window with children.
    /// (GTK 2.12) Only the fully transparent pixels will be transparent.
    /// The pixels colors will be ignored, only the alpha channel is used.
    /// (since 3.26)
    pub fn setShapeImage(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "SHAPEIMAGE", .{}, arg);
    }

    pub fn getTipFgColor(self: *Self) ?iup.Rgb {
        return c.getRgb(self, "TIPFGCOLOR", .{});
    }

    pub fn setTipFgColor(self: *Self, rgb: iup.Rgb) void {
        c.setRgb(self, "TIPFGCOLOR", .{}, rgb);
    }

    pub fn getControlId(self: *Self) i32 {
        return c.getIntAttribute(self, "CONTROLID", .{});
    }

    pub fn setControlId(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "CONTROLID", .{}, arg);
    }

    pub fn getShowNoActivate(self: *Self) bool {
        return c.getBoolAttribute(self, "SHOWNOACTIVATE", .{});
    }

    pub fn setShowNoActivate(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "SHOWNOACTIVATE", .{}, arg);
    }

    pub fn getFontFace(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "FONTFACE", .{});
    }

    pub fn setFontFace(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "FONTFACE", .{}, arg);
    }

    pub fn getMaximizeAtDialog(self: *Self) bool {
        return c.getBoolAttribute(self, "MAXIMIZEATDIALOG", .{});
    }

    pub fn setMaximizeAtDialog(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "MAXIMIZEATDIALOG", .{}, arg);
    }


    /// 
    /// TOPMOST [Windows and GTK Only]: puts the dialog always in front of all
    /// other dialogs in all applications.
    /// Default: NO.
    pub fn topMost(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "TOPMOST", .{}, arg);
    }


    /// 
    /// TASKBARBUTTON [Windows Only]: If set to SHOW force the application button
    /// to be shown on the taskbar even if the dialog does not have decorations.
    /// If set to HIDE force the application button to be hidden from the taskbar,
    /// but also in this case the system menu, the maximize and minimize buttons
    /// will be hidden.
    /// (since 3.28)
    pub fn getTaskbarButton(self: *Self) ?TaskbarButton {
        var ret = c.getStrAttribute(self, "TASKBARBUTTON", .{});

        if (std.ascii.eqlIgnoreCase("SHOW", ret)) return .Show;
        if (std.ascii.eqlIgnoreCase("HIDE", ret)) return .Hide;
        return null;
    }


    /// 
    /// TASKBARBUTTON [Windows Only]: If set to SHOW force the application button
    /// to be shown on the taskbar even if the dialog does not have decorations.
    /// If set to HIDE force the application button to be hidden from the taskbar,
    /// but also in this case the system menu, the maximize and minimize buttons
    /// will be hidden.
    /// (since 3.28)
    pub fn setTaskbarButton(self: *Self, arg: ?TaskbarButton) void {
        if (arg) |value| switch (value) {
            .Show => c.setStrAttribute(self, "TASKBARBUTTON", .{}, "SHOW"),
            .Hide => c.setStrAttribute(self, "TASKBARBUTTON", .{}, "HIDE"),
        } else {
            c.clearAttribute(self, "TASKBARBUTTON", .{});
        }
    }

    pub fn getName(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "NAME", .{});
    }

    pub fn setName(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "NAME", .{}, arg);
    }


    /// 
    /// DEFAULTENTER: Name of the button activated when the user press Enter when
    /// focus is in another control of the dialog.
    /// Use IupSetHandle or IupSetAttributeHandle to associate a button to a name.
    pub fn getDefaultEnter(self: *Self) ?*iup.Button {
        if (c.getHandleAttribute(self, "DEFAULTENTER", .{})) |handle| {
            return @ptrCast(*iup.Button, handle);
        } else {
            return null;
        }
    }


    /// 
    /// DEFAULTENTER: Name of the button activated when the user press Enter when
    /// focus is in another control of the dialog.
    /// Use IupSetHandle or IupSetAttributeHandle to associate a button to a name.
    pub fn setDefaultEnter(self: *Self, arg: *iup.Button) void {
        c.setHandleAttribute(self, "DEFAULTENTER", .{}, arg);
    }


    /// 
    /// MODAL (read-only): Returns the popup state.
    /// It is "YES" if the dialog was shown using IupPopup.
    /// It is "NO" if IupShow was used or it is not visible.
    /// At the first time the dialog is shown, MODAL is not set yet when SHOW_CB is called.
    /// (since 3.0)
    pub fn getModal(self: *Self) bool {
        return c.getBoolAttribute(self, "MODAL", .{});
    }

    pub fn getTipBalloonTitleIcon(self: *Self) bool {
        return c.getBoolAttribute(self, "TIPBALLOONTITLEICON", .{});
    }

    pub fn setTipBalloonTitleIcon(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "TIPBALLOONTITLEICON", .{}, arg);
    }


    /// 
    /// BACKGROUND (non inheritable): Dialog background color or image.
    /// Can be a non inheritable alternative to BGCOLOR or can be the name of an
    /// image to be tiled on the background.
    /// See also the screenshots of the sample.c results with normal background,
    /// changing the dialog BACKGROUND, the dialog BGCOLOR and the children BGCOLOR.
    /// Not working in GTK 3.
    /// (since 3.0)
    pub fn getBackground(self: *Self) ?iup.Rgb {
        return c.getRgb(self, "BACKGROUND", .{});
    }


    /// 
    /// BACKGROUND (non inheritable): Dialog background color or image.
    /// Can be a non inheritable alternative to BGCOLOR or can be the name of an
    /// image to be tiled on the background.
    /// See also the screenshots of the sample.c results with normal background,
    /// changing the dialog BACKGROUND, the dialog BGCOLOR and the children BGCOLOR.
    /// Not working in GTK 3.
    /// (since 3.0)
    pub fn setBackground(self: *Self, rgb: iup.Rgb) void {
        c.setRgb(self, "BACKGROUND", .{}, rgb);
    }


    /// 
    /// HIDETASKBAR [Windows and GTK Only] (write-only): Action attribute that when
    /// set to "YES", hides the dialog, but does not decrement the visible dialog
    /// count, does not call SHOW_CB and does not mark the dialog as hidden inside IUP.
    /// It is usually used to hide the dialog and keep the tray icon working
    /// without closing the main loop.
    /// It has the same effect as setting LOCKLOOP=Yes and normally hiding the dialog.
    /// IMPORTANT: when you hide using HIDETASKBAR, you must show using HIDETASKBAR also.
    /// Possible values: YES, NO.
    pub fn getHideTaskbar(self: *Self) bool {
        return c.getBoolAttribute(self, "HIDETASKBAR", .{});
    }


    /// 
    /// HIDETASKBAR [Windows and GTK Only] (write-only): Action attribute that when
    /// set to "YES", hides the dialog, but does not decrement the visible dialog
    /// count, does not call SHOW_CB and does not mark the dialog as hidden inside IUP.
    /// It is usually used to hide the dialog and keep the tray icon working
    /// without closing the main loop.
    /// It has the same effect as setting LOCKLOOP=Yes and normally hiding the dialog.
    /// IMPORTANT: when you hide using HIDETASKBAR, you must show using HIDETASKBAR also.
    /// Possible values: YES, NO.
    pub fn setHideTaskbar(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "HIDETASKBAR", .{}, arg);
    }


    /// 
    /// BRINGFRONT [Windows Only] (write-only): makes the dialog the foreground window.
    /// Use "YES" to activate it.
    /// Useful for multithreaded applications.
    pub fn getBringFront(self: *Self) bool {
        return c.getBoolAttribute(self, "BRINGFRONT", .{});
    }


    /// 
    /// BRINGFRONT [Windows Only] (write-only): makes the dialog the foreground window.
    /// Use "YES" to activate it.
    /// Useful for multithreaded applications.
    pub fn setBringFront(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "BRINGFRONT", .{}, arg);
    }


    /// 
    /// TRAYIMAGE [Windows and GTK Only]: Name of a IUP image to be used as the
    /// tray icon.
    /// The Windows SDK recommends that cursors and icons should be implemented as
    /// resources rather than created at run time.
    /// (GTK 2.10 and GTK < 3.14)
    pub fn getTrayImage(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "TRAYIMAGE", .{});
    }


    /// 
    /// TRAYIMAGE [Windows and GTK Only]: Name of a IUP image to be used as the
    /// tray icon.
    /// The Windows SDK recommends that cursors and icons should be implemented as
    /// resources rather than created at run time.
    /// (GTK 2.10 and GTK < 3.14)
    pub fn setTrayImage(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "TRAYIMAGE", .{}, arg);
    }


    /// 
    /// ACTIVE, BGCOLOR, FONT, EXPAND, SCREENPOSITION, WID, TIP, CLIENTOFFSET,
    /// CLIENTSIZE, RASTERSIZE, ZORDER: also accepted.
    /// Note that ACTIVE, BGCOLOR and FONT will also affect all the controls inside
    /// the dialog.
    pub fn getActive(self: *Self) bool {
        return c.getBoolAttribute(self, "ACTIVE", .{});
    }


    /// 
    /// ACTIVE, BGCOLOR, FONT, EXPAND, SCREENPOSITION, WID, TIP, CLIENTOFFSET,
    /// CLIENTSIZE, RASTERSIZE, ZORDER: also accepted.
    /// Note that ACTIVE, BGCOLOR and FONT will also affect all the controls inside
    /// the dialog.
    pub fn setActive(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "ACTIVE", .{}, arg);
    }

    pub fn getTipVisible(self: *Self) bool {
        return c.getBoolAttribute(self, "TIPVISIBLE", .{});
    }

    pub fn setTipVisible(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "TIPVISIBLE", .{}, arg);
    }

    pub fn getExpandWeight(self: *Self) f64 {
        return c.getDoubleAttribute(self, "EXPANDWEIGHT", .{});
    }

    pub fn setExpandWeight(self: *Self, arg: f64) void {
        c.setDoubleAttribute(self, "EXPANDWEIGHT", .{}, arg);
    }


    /// 
    /// MINSIZE: Minimum size for the dialog in raster units (pixels).
    /// The windowing system will not be able to change the size beyond this limit.
    /// Default: 1x1.
    /// Some systems define a very minimum size greater than this, for instance in
    /// Windows the horizontal minimum size includes the window decoration buttons.
    /// (since 3.0)
    pub fn getMinSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "MINSIZE", .{});
        return Size.parse(str);
    }


    /// 
    /// MINSIZE: Minimum size for the dialog in raster units (pixels).
    /// The windowing system will not be able to change the size beyond this limit.
    /// Default: 1x1.
    /// Some systems define a very minimum size greater than this, for instance in
    /// Windows the horizontal minimum size includes the window decoration buttons.
    /// (since 3.0)
    pub fn setMinSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "MINSIZE", .{}, value);
    }


    /// 
    /// ACTIVEWINDOW [Windows and GTK Only] (read-only): informs if the dialog is
    /// the active window (the window with focus).
    /// Can be Yes or No.
    /// (since 3.4)
    pub fn getActiveWindow(self: *Self) bool {
        return c.getBoolAttribute(self, "ACTIVEWINDOW", .{});
    }


    /// 
    /// CUSTOMFRAMECAPTIONHEIGHT [Windows Only] (non inheritable): height of the
    /// caption area.
    /// If not defined it will use the system size.
    /// (since 3.18) (renamed in 3.22)
    pub fn getCustomFrameCaptionHeight(self: *Self) i32 {
        return c.getIntAttribute(self, "CUSTOMFRAMECAPTIONHEIGHT", .{});
    }


    /// 
    /// CUSTOMFRAMECAPTIONHEIGHT [Windows Only] (non inheritable): height of the
    /// caption area.
    /// If not defined it will use the system size.
    /// (since 3.18) (renamed in 3.22)
    pub fn setCustomFrameCaptionHeight(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "CUSTOMFRAMECAPTIONHEIGHT", .{}, arg);
    }

    pub fn getNTheme(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "NTHEME", .{});
    }

    pub fn setNTheme(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "NTHEME", .{}, arg);
    }


    /// 
    /// CUSTOMFRAMESIMULATE: allows the application to customize the dialog frame
    /// elements (the title and its buttons) by using IUP controls for its elements
    /// like caption, minimize button, maximize button, and close buttons.
    /// The custom frame support is entirely simulated by IUP, no native support
    /// for custom frame is used (this seems to have less drawbacks on the
    /// application behavior).
    /// The application is responsible for leaving space for the borders.
    /// One drawback is that menu bars will not work.
    /// For the dialog to be able to be moved an IupLabel, or a IupFlatLabel or an
    /// IupCanvas must be at the top of the dialog and must have the NAME attribute
    /// set to CUSTOMFRAMECAPTION.
    /// See the Custom Frame notes bellow.
    /// (since 3.28)
    pub fn getCustomFramesImulate(self: *Self) bool {
        return c.getBoolAttribute(self, "CUSTOMFRAMESIMULATE", .{});
    }


    /// 
    /// CUSTOMFRAMESIMULATE: allows the application to customize the dialog frame
    /// elements (the title and its buttons) by using IUP controls for its elements
    /// like caption, minimize button, maximize button, and close buttons.
    /// The custom frame support is entirely simulated by IUP, no native support
    /// for custom frame is used (this seems to have less drawbacks on the
    /// application behavior).
    /// The application is responsible for leaving space for the borders.
    /// One drawback is that menu bars will not work.
    /// For the dialog to be able to be moved an IupLabel, or a IupFlatLabel or an
    /// IupCanvas must be at the top of the dialog and must have the NAME attribute
    /// set to CUSTOMFRAMECAPTION.
    /// See the Custom Frame notes bellow.
    /// (since 3.28)
    pub fn setCustomFramesImulate(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "CUSTOMFRAMESIMULATE", .{}, arg);
    }


    /// 
    /// MDICLOSEALL [Windows Only] (write-only): Action to close and destroy all
    /// MDI child windows.
    /// The CLOSE_CB callback will be called for each child.
    pub fn mdiCloseAll(self: *Self) void {
        c.setStrAttribute(self, "MDICLOSEALL", .{}, null);
    }


    /// 
    /// SHRINK: Allows changing the elements distribution when the dialog is
    /// smaller than the minimum size.
    /// Default: NO.
    pub fn getShrink(self: *Self) bool {
        return c.getBoolAttribute(self, "SHRINK", .{});
    }


    /// 
    /// SHRINK: Allows changing the elements distribution when the dialog is
    /// smaller than the minimum size.
    /// Default: NO.
    pub fn setShrink(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "SHRINK", .{}, arg);
    }

    pub fn getCharSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "CHARSIZE", .{});
        return Size.parse(str);
    }

    pub fn getClientSize(self: *Self) Size {
        var str = c.getStrAttribute(self, "CLIENTSIZE", .{});
        return Size.parse(str);
    }

    pub fn setClientSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        c.setStrAttribute(self, "CLIENTSIZE", .{}, value);
    }

    pub fn getClientOffset(self: *Self) Size {
        var str = c.getStrAttribute(self, "CLIENTOFFSET", .{});
        return Size.parse(str);
    }


    /// 
    /// TRAYTIP [Windows and GTK Only]: Tray icon's tooltip text.
    /// (GTK 2.10 and GTK < 3.14)
    pub fn getTrayTip(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "TRAYTIP", .{});
    }


    /// 
    /// TRAYTIP [Windows and GTK Only]: Tray icon's tooltip text.
    /// (GTK 2.10 and GTK < 3.14)
    pub fn setTrayTip(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "TRAYTIP", .{}, arg);
    }

    pub fn getDragTypes(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "DRAGTYPES", .{});
    }

    pub fn setDragTypes(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "DRAGTYPES", .{}, arg);
    }

    pub fn getFontStyle(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "FONTSTYLE", .{});
    }

    pub fn setFontStyle(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "FONTSTYLE", .{}, arg);
    }

    pub fn getTouch(self: *Self) bool {
        return c.getBoolAttribute(self, "TOUCH", .{});
    }

    pub fn setTouch(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "TOUCH", .{}, arg);
    }


    /// 
    /// TASKBARPROGRESSSTATE [Windows Only] (write-only): sets the type and state
    /// of the progress indicator displayed on a taskbar button.
    /// Possible values: NORMAL (a green bar), PAUSED (a yellow bar), ERROR (a red
    /// bar), INDETERMINATE (a green marquee) and NOPROGRESS (no bar).
    /// Default: NORMAL (since 3.10).
    pub fn taskbarProgressState(self: *Self, arg: ?TaskbarProgressState) void {
        if (arg) |value| switch (value) {
            .NoProgress => c.setStrAttribute(self, "TASKBARPROGRESSSTATE", .{}, "NOPROGRESS"),
            .Indeterminate => c.setStrAttribute(self, "TASKBARPROGRESSSTATE", .{}, "INDETERMINATE"),
            .Error => c.setStrAttribute(self, "TASKBARPROGRESSSTATE", .{}, "ERROR"),
            .Paused => c.setStrAttribute(self, "TASKBARPROGRESSSTATE", .{}, "PAUSED"),
            .Normal => c.setStrAttribute(self, "TASKBARPROGRESSSTATE", .{}, "NORMAL"),
        } else {
            c.clearAttribute(self, "TASKBARPROGRESSSTATE", .{});
        }
    }


    /// 
    /// TASKBARPROGRESSVALUE [Windows Only] (write-only): updates a progress bar
    /// hosted in a taskbar button to show the specific percentage completed of the
    /// full operation.
    /// The value must be between 0 and 100 (since 3.10).
    pub fn taskbarProgressValue(self: *Self, arg: i32) void {
        c.setIntAttribute(self, "TASKBARPROGRESSVALUE", .{}, arg);
    }


    /// 
    /// FULLSCREEN: Makes the dialog occupy the whole screen over any system bars
    /// in the main monitor.
    /// All dialog details, such as title bar, borders, maximize button, etc, are removed.
    /// Possible values: YES, NO.
    /// In Motif you may have to click in the dialog to set its focus.
    /// In Motif if set to YES when the dialog is hidden, then it can not be
    /// changed after it is visible.
    pub fn fullScreen(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "FULLSCREEN", .{}, arg);
    }

    pub fn getMaximizedIalog(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "MAXIMIZEDIALOG", .{});
    }

    pub fn setMaximizedIalog(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "MAXIMIZEDIALOG", .{}, arg);
    }

    pub fn getDragCursor(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "DRAGCURSOR", .{});
    }

    pub fn setDragCursor(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "DRAGCURSOR", .{}, arg);
    }


    /// 
    /// MINIMIZED [Windows and GTK Only] (read-only): indicates if the dialog is minimized.
    /// Can be YES or NO.
    /// (since 3.15)
    pub fn getMinimized(self: *Self) bool {
        return c.getBoolAttribute(self, "MINIMIZED", .{});
    }

    pub fn getFont(self: *Self) [:0]const u8 {
        return c.getStrAttribute(self, "FONT", .{});
    }

    pub fn setFont(self: *Self, arg: [:0]const u8) void {
        c.setStrAttribute(self, "FONT", .{}, arg);
    }


    /// 
    /// SIMULATEMODAL (write-only): disable all other visible dialogs, just like
    /// when the dialog is made modal.
    /// (since 3.21)
    pub fn simulateModal(self: *Self, arg: bool) void {
        c.setBoolAttribute(self, "SIMULATEMODAL", .{}, arg);
    }

    pub fn setTouchCallback(self: *Self, callback: ?OnTouchFn) void {
        const Handler = CallbackHandler(Self, OnTouchFn, "TOUCH_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// FOCUS_CB: Called when the dialog or any of its children gets the focus, or
    /// when another dialog or any control in another dialog gets the focus.
    /// It is called after the common callbacks GETFOCUS_CB and KILL_FOCUS_CB.
    /// (since 3.21) int function(Ihandle *ih, int focus); [in C]ih:focus_cb(focus:
    /// number) -> (ret: number) [in Lua]
    pub fn setFocusCallback(self: *Self, callback: ?OnFocusFn) void {
        const Handler = CallbackHandler(Self, OnFocusFn, "FOCUS_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// K_ANY K_ANY Action generated when a keyboard event occurs.
    /// Callback int function(Ihandle *ih, int c); [in C] ih:k_any(c: number) ->
    /// (ret: number) [in Lua] ih: identifier of the element that activated the event.
    /// c: identifier of typed key.
    /// Please refer to the Keyboard Codes table for a list of possible values.
    /// Returns: If IUP_IGNORE is returned the key is ignored and not processed by
    /// the control and not propagated.
    /// If returns IUP_CONTINUE, the key will be processed and the event will be
    /// propagated to the parent of the element receiving it, this is the default behavior.
    /// If returns IUP_DEFAULT the key is processed but it is not propagated.
    /// IUP_CLOSE will be processed.
    /// Notes Keyboard callbacks depend on the keyboard usage of the control with
    /// the focus.
    /// So if you return IUP_IGNORE the control will usually not process the key.
    /// But be aware that sometimes the control process the key in another event so
    /// even returning IUP_IGNORE the key can get processed.
    /// Although it will not be propagated.
    /// IMPORTANT: The callbacks "K_*" of the dialog or native containers depend on
    /// the IUP_CONTINUE return value to work while the control is in focus.
    /// If the callback does not exists it is automatically propagated to the
    /// parent of the element.
    /// K_* callbacks All defined keys are also callbacks of any element, called
    /// when the respective key is activated.
    /// For example: "K_cC" is also a callback activated when the user press
    /// Ctrl+C, when the focus is at the element or at a children with focus.
    /// This is the way an application can create shortcut keys, also called hot keys.
    /// These callbacks are not available in IupLua.
    /// Affects All elements with keyboard interaction.
    pub fn setKAnyCallback(self: *Self, callback: ?OnKAnyFn) void {
        const Handler = CallbackHandler(Self, OnKAnyFn, "K_ANY");
        Handler.setCallback(self, callback);
    }

    /// 
    /// HELP_CB HELP_CB Action generated when the user press F1 at a control.
    /// In Motif is also activated by the Help button in some workstations keyboard.
    /// Callback void function(Ihandle *ih); [in C] ih:help_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Returns: IUP_CLOSE will be processed.
    /// Affects All elements with user interaction.
    pub fn setHelpCallback(self: *Self, callback: ?OnHelpFn) void {
        const Handler = CallbackHandler(Self, OnHelpFn, "HELP_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// CLOSE_CB CLOSE_CB Called just before a dialog is closed when the user
    /// clicks the close button of the title bar or an equivalent action.
    /// Callback int function(Ihandle *ih); [in C] ih:close_cb() -> (ret: number)
    /// [in Lua] ih: identifies the element that activated the event.
    /// Returns: if IUP_IGNORE, it prevents the dialog from being closed.
    /// If you destroy the dialog in this callback, you must return IUP_IGNORE.
    /// IUP_CLOSE will be processed.
    /// Affects IupDialog
    pub fn setCloseCallback(self: *Self, callback: ?OnCloseFn) void {
        const Handler = CallbackHandler(Self, OnCloseFn, "CLOSE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropMotionCallback(self: *Self, callback: ?OnDropMotionFn) void {
        const Handler = CallbackHandler(Self, OnDropMotionFn, "DROPMOTION_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragEndCallback(self: *Self, callback: ?OnDragEndFn) void {
        const Handler = CallbackHandler(Self, OnDragEndFn, "DRAGEND_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragBeginCallback(self: *Self, callback: ?OnDragBeginFn) void {
        const Handler = CallbackHandler(Self, OnDragBeginFn, "DRAGBEGIN_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMultiTouchCallback(self: *Self, callback: ?OnMultiTouchFn) void {
        const Handler = CallbackHandler(Self, OnMultiTouchFn, "MULTITOUCH_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// MDIACTIVATE_CB [Windows Only]: Called when a MDI child window is activated.
    /// Only the MDI child receive this message.
    /// It is not called when the child is shown for the first time.
    /// int function(Ihandle *ih); [in C]elem:mdiactivate_cb() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    pub fn setMdiActivateCallback(self: *Self, callback: ?OnMdiActivateFn) void {
        const Handler = CallbackHandler(Self, OnMdiActivateFn, "MDIACTIVATE_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// MAP_CB MAP_CB Called right after an element is mapped and its attributes
    /// updated in IupMap.
    /// When the element is a dialog, it is called after the layout is updated.
    /// For all other elements is called before the layout is updated, so the
    /// element current size will still be 0x0 during MAP_CB (since 3.14).
    /// Callback int function(Ihandle *ih); [in C] ih:map_cb() -> (ret: number) [in
    /// Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub fn setMapCallback(self: *Self, callback: ?OnMapFn) void {
        const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// ENTERWINDOW_CB ENTERWINDOW_CB Action generated when the mouse enters the
    /// native element.
    /// Callback int function(Ihandle *ih); [in C] ih:enterwindow_cb() -> (ret:
    /// number) [in Lua] ih: identifier of the element that activated the event.
    /// Notes When the cursor is moved from one element to another, the call order
    /// in all platforms will be first the LEAVEWINDOW_CB callback of the old
    /// control followed by the ENTERWINDOW_CB callback of the new control.
    /// (since 3.14) If the mouse button is hold pressed and the cursor moves
    /// outside the element the behavior is system dependent.
    /// In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB callbacks are NOT called, in
    /// GTK the callbacks are called.
    /// Affects All controls with user interaction.
    /// See Also LEAVEWINDOW_CB
    pub fn setEnterWindowCallback(self: *Self, callback: ?OnEnterWindowFn) void {
        const Handler = CallbackHandler(Self, OnEnterWindowFn, "ENTERWINDOW_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// DESTROY_CB DESTROY_CB Called right before an element is destroyed.
    /// Callback int function(Ihandle *ih); [in C] ih:destroy_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Notes If the dialog is visible then it is hidden before it is destroyed.
    /// The callback will be called right after it is hidden.
    /// The callback will be called before all other destroy procedures.
    /// For instance, if the element has children then it is called before the
    /// children are destroyed.
    /// For language binding implementations use the callback name "LDESTROY_CB" to
    /// release memory allocated by the binding for the element.
    /// Also the callback will be called before the language callback.
    /// Affects All.
    pub fn setDestroyCallback(self: *Self, callback: ?OnDestroyFn) void {
        const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropDataCallback(self: *Self, callback: ?OnDropDataFn) void {
        const Handler = CallbackHandler(Self, OnDropDataFn, "DROPDATA_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// KILLFOCUS_CB KILLFOCUS_CB Action generated when an element loses keyboard focus.
    /// This callback is called before the GETFOCUS_CB of the element that gets the focus.
    /// Callback int function(Ihandle *ih); [in C] ih:killfocus_cb() -> (ret:
    /// number) [in Lua] ih: identifier of the element that activated the event.
    /// Affects All elements with user interaction, except menus.
    /// In Windows, there are restrictions when using this callback.
    /// From MSDN on WM_KILLFOCUS: "While processing this message, do not make any
    /// function calls that display or activate a window.
    /// This causes the thread to yield control and can cause the application to
    /// stop responding to messages.
    /// See Also GETFOCUS_CB, IupGetFocus, IupSetFocus
    pub fn setKillFocusCallback(self: *Self, callback: ?OnKillFocusFn) void {
        const Handler = CallbackHandler(Self, OnKillFocusFn, "KILLFOCUS_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// CUSTOMFRAMEACTIVATE_CB [Windows Only]: Called when the dialog active state
    /// is changed (for instance the user Alt+Tab to another application, or
    /// clicked in another window).
    /// Works only when CUSTOMFRAME or CUSTOMFRAMEEX is defined.
    /// (since 3.23) int function(Ihandle *ih, int active); [in
    /// C]ih:customframeactivate_cb(active: number) -> (ret: number) [in Lua]
    pub fn setCustomFrameActivateCallback(self: *Self, callback: ?OnCustomFrameActivateFn) void {
        const Handler = CallbackHandler(Self, OnCustomFrameActivateFn, "CUSTOMFRAMEACTIVATE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragDataCallback(self: *Self, callback: ?OnDragDataFn) void {
        const Handler = CallbackHandler(Self, OnDragDataFn, "DRAGDATA_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragDataSizeCallback(self: *Self, callback: ?OnDragDataSizeFn) void {
        const Handler = CallbackHandler(Self, OnDragDataSizeFn, "DRAGDATASIZE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setCustomFrameDrawCallback(self: *Self, callback: ?OnCustomFrameDrawFn) void {
        const Handler = CallbackHandler(Self, OnCustomFrameDrawFn, "CUSTOMFRAMEDRAW_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// SHOW_CB SHOW_CB Called right after the dialog is showed, hidden, maximized,
    /// minimized or restored from minimized/maximized.
    /// This callback is called when those actions were performed by the user or
    /// programmatically by the application.
    /// Callback int function(Ihandle *ih, int state); [in C] ih:show_cb(state:
    /// number) -> (ret: number) [in Lua] ih: identifier of the element that
    /// activated the event.
    /// state: indicates which of the following situations generated the event:
    /// IUP_HIDE (since 3.0) IUP_SHOW IUP_RESTORE (was minimized or maximized)
    /// IUP_MINIMIZE IUP_MAXIMIZE (since 3.0) (not received in Motif when activated
    /// from the maximize button) Returns: IUP_CLOSE will be processed.
    /// Affects IupDialog
    pub fn setShowCallback(self: *Self, callback: ?OnShowFn) void {
        const Handler = CallbackHandler(Self, OnShowFn, "SHOW_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// DROPFILES_CB DROPFILES_CB Action called when a file is "dropped" into the control.
    /// When several files are dropped at once, the callback is called several
    /// times, once for each file.
    /// If defined after the element is mapped then the attribute DROPFILESTARGET
    /// must be set to YES.
    /// [Windows and GTK Only] (GTK 2.6) Callback int function(Ihandle *ih, const
    /// char* filename, int num, int x, int y); [in C] ih:dropfiles_cb(filename:
    /// string; num, x, y: number) -> (ret: number) [in Lua] ih: identifier of the
    /// element that activated the event.
    /// filename: Name of the dropped file.
    /// num: Number index of the dropped file.
    /// If several files are dropped, num is the index of the dropped file starting
    /// from "total-1" to "0".
    /// x: X coordinate of the point where the user released the mouse button.
    /// y: Y coordinate of the point where the user released the mouse button.
    /// Returns: If IUP_IGNORE is returned the callback will NOT be called for the
    /// next dropped files, and the processing of dropped files will be interrupted.
    /// Affects IupDialog, IupCanvas, IupGLCanvas, IupText, IupList
    pub fn setDropFilesCallback(self: *Self, callback: ?OnDropFilesFn) void {
        const Handler = CallbackHandler(Self, OnDropFilesFn, "DROPFILES_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// RESIZE_CB RESIZE_CB Action generated when the canvas or dialog size is changed.
    /// Callback int function(Ihandle *ih, int width, int height); [in C]
    /// ih:resize_cb(width, height: number) -> (ret: number) [in Lua] ih:
    /// identifier of the element that activated the event.
    /// width: the width of the internal element size in pixels not considering the
    /// decorations (client size) height: the height of the internal element size
    /// in pixels not considering the decorations (client size) Notes For the
    /// dialog, this action is also generated when the dialog is mapped, after the
    /// map and before the show.
    /// When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the canvas scrollbar is
    /// hidden/shown after changing the DX or DY attributes from inside the
    /// callback, the size of the drawing area will immediately change, so the
    /// parameters with and height will be invalid.
    /// To update the parameters consult the DRAWSIZE attribute.
    /// Also activate the drawing toolkit only after updating the DX or DY attributes.
    /// Affects IupCanvas, IupGLCanvas, IupDialog
    pub fn setResizeCallback(self: *Self, callback: ?OnResizeFn) void {
        const Handler = CallbackHandler(Self, OnResizeFn, "RESIZE_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// UNMAP_CB UNMAP_CB Called right before an element is unmapped.
    /// Callback int function(Ihandle *ih); [in C] ih:unmap_cb() -> (ret: number)
    /// [in Lua] ih: identifier of the element that activated the event.
    /// Affects All that have a native representation.
    pub fn setUnmapCallback(self: *Self, callback: ?OnUnmapFn) void {
        const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// TRAYCLICK_CB [Windows and GTK Only]: Called right after the mouse button is
    /// pressed or released over the tray icon.
    /// (GTK 2.10) int function(Ihandle *ih, int but, int pressed, int dclick); [in
    /// C]elem:trayclick_cb(but, pressed, dclick: number) -> (ret: number) [in Lua]
    pub fn setTrayClickCallback(self: *Self, callback: ?OnTrayClickFn) void {
        const Handler = CallbackHandler(Self, OnTrayClickFn, "TRAYCLICK_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// GETFOCUS_CB GETFOCUS_CB Action generated when an element is given keyboard focus.
    /// This callback is called after the KILLFOCUS_CB of the element that loosed
    /// the focus.
    /// The IupGetFocus function during the callback returns the element that
    /// loosed the focus.
    /// Callback int function(Ihandle *ih); [in C] ih:getfocus_cb() -> (ret:
    /// number) [in Lua] ih: identifier of the element that received keyboard focus.
    /// Affects All elements with user interaction, except menus.
    /// See Also KILLFOCUS_CB, IupGetFocus, IupSetFocus
    pub fn setGetFocusCallback(self: *Self, callback: ?OnGetFocusFn) void {
        const Handler = CallbackHandler(Self, OnGetFocusFn, "GETFOCUS_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setLDestroyCallback(self: *Self, callback: ?OnLDestroyFn) void {
        const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
        Handler.setCallback(self, callback);
    }

    /// 
    /// LEAVEWINDOW_CB LEAVEWINDOW_CB Action generated when the mouse leaves the
    /// native element.
    /// Callback int function(Ihandle *ih); [in C] ih:leavewindow_cb() -> (ret:
    /// number) [in Lua] ih: identifier of the element that activated the event.
    /// Notes When the cursor is moved from one element to another, the call order
    /// in all platforms will be first the LEAVEWINDOW_CB callback of the old
    /// control followed by the ENTERWINDOW_CB callback of the new control.
    /// (since 3.14) If the mouse button is hold pressed and the cursor moves
    /// outside the element the behavior is system dependent.
    /// In Windows the LEAVEWINDOW_CB/ENTERWINDOW_CB callbacks are NOT called, in
    /// GTK the callbacks are called.
    /// Affects All controls with user interaction.
    /// See Also ENTERWINDOW_CB
    pub fn setLeaveWindowCallback(self: *Self, callback: ?OnLeaveWindowFn) void {
        const Handler = CallbackHandler(Self, OnLeaveWindowFn, "LEAVEWINDOW_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setPostMessageCallback(self: *Self, callback: ?OnPostMessageFn) void {
        const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
        Handler.setCallback(self, callback);
    }
};

test "Dialog TipBalloon" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTipBalloon(true).unwrap());
    defer item.deinit();

    var ret = item.getTipBalloon();

    try std.testing.expect(ret == true);
}

test "Dialog HandleName" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setHandleName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHandleName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog TipBgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTipBgColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getTipBgColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Dialog NoFlush" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setNoFlush(true).unwrap());
    defer item.deinit();

    var ret = item.getNoFlush();

    try std.testing.expect(ret == true);
}

test "Dialog MaxSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setMaxSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMaxSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Dialog TrayTipBalloonTitleIcon" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTrayTipBalloonTitleIcon(42).unwrap());
    defer item.deinit();

    var ret = item.getTrayTipBalloonTitleIcon();

    try std.testing.expect(ret == 42);
}

test "Dialog OpacityImage" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setOpacityImage("Hello").unwrap());
    defer item.deinit();

    var ret = item.getOpacityImage();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog ShowNoFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setShowNoFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getShowNoFocus();

    try std.testing.expect(ret == true);
}

test "Dialog MaximizeAtParent" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setMaximizeAtParent(true).unwrap());
    defer item.deinit();

    var ret = item.getMaximizeAtParent();

    try std.testing.expect(ret == true);
}

test "Dialog Opacity" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setOpacity(42).unwrap());
    defer item.deinit();

    var ret = item.getOpacity();

    try std.testing.expect(ret == 42);
}

test "Dialog Position" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setPosition(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getPosition();

    try std.testing.expect(ret.x == 9 and ret.y == 10);
}

test "Dialog DropFilesTarget" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDropFilesTarget(true).unwrap());
    defer item.deinit();

    var ret = item.getDropFilesTarget();

    try std.testing.expect(ret == true);
}

test "Dialog Tip" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTip("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTip();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog CanFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setCanFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getCanFocus();

    try std.testing.expect(ret == true);
}

test "Dialog DragSourceMove" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDragSourceMove(true).unwrap());
    defer item.deinit();

    var ret = item.getDragSourceMove();

    try std.testing.expect(ret == true);
}

test "Dialog Icon" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setIcon("Hello").unwrap());
    defer item.deinit();

    var ret = item.getIcon();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog Visible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setVisible(true).unwrap());
    defer item.deinit();

    var ret = item.getVisible();

    try std.testing.expect(ret == true);
}

test "Dialog CustomFrameDraw" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setCustomFrameDraw(true).unwrap());
    defer item.deinit();

    var ret = item.getCustomFrameDraw();

    try std.testing.expect(ret == true);
}

test "Dialog Cursor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setCursor("Hello").unwrap());
    defer item.deinit();

    var ret = item.getCursor();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog DragDrop" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDragDrop(true).unwrap());
    defer item.deinit();

    var ret = item.getDragDrop();

    try std.testing.expect(ret == true);
}

test "Dialog DialogHint" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDialogHint(true).unwrap());
    defer item.deinit();

    var ret = item.getDialogHint();

    try std.testing.expect(ret == true);
}

test "Dialog ShowMinimizeNext" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setShowMinimizeNext(true).unwrap());
    defer item.deinit();

    var ret = item.getShowMinimizeNext();

    try std.testing.expect(ret == true);
}

test "Dialog DialogFrame" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDialogFrame(true).unwrap());
    defer item.deinit();

    var ret = item.getDialogFrame();

    try std.testing.expect(ret == true);
}

test "Dialog NActive" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setNActive(true).unwrap());
    defer item.deinit();

    var ret = item.getNActive();

    try std.testing.expect(ret == true);
}

test "Dialog TrayTipBalloonTitle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTrayTipBalloonTitle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTrayTipBalloonTitle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog Theme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog Tray" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTray(true).unwrap());
    defer item.deinit();

    var ret = item.getTray();

    try std.testing.expect(ret == true);
}

test "Dialog DragCursorCopy" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDragCursorCopy("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDragCursorCopy();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog TaskbarProgress" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTaskbarProgress(42).unwrap());
    defer item.deinit();

    var ret = item.getTaskbarProgress();

    try std.testing.expect(ret == 42);
}

test "Dialog ChildOffset" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setChildOffset(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getChildOffset();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Dialog Expand" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setExpand(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getExpand();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "Dialog StartFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setStartFocus("Hello").unwrap());
    defer item.deinit();

    var ret = item.getStartFocus();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog FontSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setFontSize(42).unwrap());
    defer item.deinit();

    var ret = item.getFontSize();

    try std.testing.expect(ret == 42);
}

test "Dialog TrayTipDelay" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTrayTipDelay(42).unwrap());
    defer item.deinit();

    var ret = item.getTrayTipDelay();

    try std.testing.expect(ret == 42);
}

test "Dialog DropTypes" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDropTypes("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDropTypes();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog UserSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setUserSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getUserSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Dialog TipDelay" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTipDelay(42).unwrap());
    defer item.deinit();

    var ret = item.getTipDelay();

    try std.testing.expect(ret == 42);
}

test "Dialog CustomFrameCaptionLimits" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setCustomFrameCaptionLimits(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getCustomFrameCaptionLimits();

    try std.testing.expect(ret.begin == 9 and ret.end == 10);
}

test "Dialog DragStart" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDragStart(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getDragStart();

    try std.testing.expect(ret.x == 9 and ret.y == 10);
}

test "Dialog CustomFrame" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setCustomFrame(true).unwrap());
    defer item.deinit();

    var ret = item.getCustomFrame();

    try std.testing.expect(ret == true);
}

test "Dialog Title" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTitle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTitle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog Placement" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setPlacement(.Maximized).unwrap());
    defer item.deinit();

    var ret = item.getPlacement();

    try std.testing.expect(ret != null and ret.? == .Maximized);
}

test "Dialog LayerAlpha" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setLayerAlpha(42).unwrap());
    defer item.deinit();

    var ret = item.getLayerAlpha();

    try std.testing.expect(ret == 42);
}

test "Dialog PropagateFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setPropagateFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getPropagateFocus();

    try std.testing.expect(ret == true);
}

test "Dialog BgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setBgColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getBgColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Dialog TipBalloonTitle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTipBalloonTitle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTipBalloonTitle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog DropTarget" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDropTarget(true).unwrap());
    defer item.deinit();

    var ret = item.getDropTarget();

    try std.testing.expect(ret == true);
}

test "Dialog TrayTipBalloon" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTrayTipBalloon(true).unwrap());
    defer item.deinit();

    var ret = item.getTrayTipBalloon();

    try std.testing.expect(ret == true);
}

test "Dialog DragSource" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDragSource(true).unwrap());
    defer item.deinit();

    var ret = item.getDragSource();

    try std.testing.expect(ret == true);
}

test "Dialog Floating" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setFloating(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getFloating();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "Dialog NormalizerGroup" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setNormalizerGroup("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNormalizerGroup();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog RasterSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setRasterSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getRasterSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Dialog ShapeImage" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setShapeImage("Hello").unwrap());
    defer item.deinit();

    var ret = item.getShapeImage();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog TipFgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTipFgColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getTipFgColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Dialog ControlId" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setControlId(42).unwrap());
    defer item.deinit();

    var ret = item.getControlId();

    try std.testing.expect(ret == 42);
}

test "Dialog ShowNoActivate" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setShowNoActivate(true).unwrap());
    defer item.deinit();

    var ret = item.getShowNoActivate();

    try std.testing.expect(ret == true);
}

test "Dialog FontFace" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setFontFace("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontFace();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog MaximizeAtDialog" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setMaximizeAtDialog(true).unwrap());
    defer item.deinit();

    var ret = item.getMaximizeAtDialog();

    try std.testing.expect(ret == true);
}

test "Dialog TaskbarButton" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTaskbarButton(.Show).unwrap());
    defer item.deinit();

    var ret = item.getTaskbarButton();

    try std.testing.expect(ret != null and ret.? == .Show);
}

test "Dialog Name" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog TipBalloonTitleIcon" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTipBalloonTitleIcon(true).unwrap());
    defer item.deinit();

    var ret = item.getTipBalloonTitleIcon();

    try std.testing.expect(ret == true);
}

test "Dialog Background" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setBackground(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getBackground();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Dialog HideTaskbar" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setHideTaskbar(true).unwrap());
    defer item.deinit();

    var ret = item.getHideTaskbar();

    try std.testing.expect(ret == true);
}

test "Dialog BringFront" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setBringFront(true).unwrap());
    defer item.deinit();

    var ret = item.getBringFront();

    try std.testing.expect(ret == true);
}

test "Dialog TrayImage" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTrayImage("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTrayImage();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog Active" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setActive(true).unwrap());
    defer item.deinit();

    var ret = item.getActive();

    try std.testing.expect(ret == true);
}

test "Dialog TipVisible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTipVisible(true).unwrap());
    defer item.deinit();

    var ret = item.getTipVisible();

    try std.testing.expect(ret == true);
}

test "Dialog ExpandWeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setExpandWeight(3.14).unwrap());
    defer item.deinit();

    var ret = item.getExpandWeight();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Dialog MinSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setMinSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMinSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Dialog CustomFrameCaptionHeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setCustomFrameCaptionHeight(42).unwrap());
    defer item.deinit();

    var ret = item.getCustomFrameCaptionHeight();

    try std.testing.expect(ret == 42);
}

test "Dialog NTheme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setNTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog CustomFramesImulate" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setCustomFramesImulate(true).unwrap());
    defer item.deinit();

    var ret = item.getCustomFramesImulate();

    try std.testing.expect(ret == true);
}

test "Dialog Shrink" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setShrink(true).unwrap());
    defer item.deinit();

    var ret = item.getShrink();

    try std.testing.expect(ret == true);
}

test "Dialog ClientSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setClientSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getClientSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Dialog TrayTip" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTrayTip("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTrayTip();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog DragTypes" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDragTypes("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDragTypes();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog FontStyle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setFontStyle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontStyle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog Touch" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setTouch(true).unwrap());
    defer item.deinit();

    var ret = item.getTouch();

    try std.testing.expect(ret == true);
}

test "Dialog MaximizedIalog" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setMaximizedIalog("Hello").unwrap());
    defer item.deinit();

    var ret = item.getMaximizedIalog();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog DragCursor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setDragCursor("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDragCursor();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Dialog Font" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Dialog.init().setFont("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFont();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}
