// This code was generated by a tool.
// IUP Metadata Code Generator
// https://github.com/batiati/IUPMetadata
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.

const std = @import("std");

const interop = @import("../interop.zig");
const iup = @import("../iup.zig");

const Impl = @import("../impl.zig").Impl;
const CallbackHandler = @import("../callback_handler.zig").CallbackHandler;

const debug = std.debug;
const trait = std.meta.trait;

const Element = iup.Element;
const Handle = iup.Handle;
const Error = iup.Error;
const ChildrenIterator = iup.ChildrenIterator;
const Size = iup.Size;
const Margin = iup.Margin;

pub const MatrixEx = opaque {
    pub const CLASS_NAME = "matrixex";
    pub const NATIVE_TYPE = iup.NativeType.Canvas;
    const Self = @This();

    pub const OnColResizeFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnWheelFn = fn (self: *Self, arg0: f32, arg1: i32, arg2: i32, arg3: [:0]const u8) anyerror!void;

    pub const OnEditMouseMoveFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnDropCheckFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnDestroyFn = fn (self: *Self) anyerror!void;

    pub const OnNumEricSetValueFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: f64) anyerror!void;

    pub const OnKillFocusFn = fn (self: *Self) anyerror!void;

    pub const OnMotionFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnDragEndFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnSortColUmncompareFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32) anyerror!void;

    pub const OnPostMessageFn = fn (self: *Self, arg0: [:0]const u8, arg1: i32, arg2: f64, arg3: ?*anyopaque) anyerror!void;

    pub const OnTranslateValueFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) [:0]const u8;

    pub const OnScrollFn = fn (self: *Self, arg0: i32, arg1: f32, arg2: f32) anyerror!void;

    pub const OnMouseMoveFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnActionFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: [:0]const u8) anyerror!void;

    pub const OnWomFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnDropDataFn = fn (self: *Self, arg0: [:0]const u8, arg1: ?*anyopaque, arg2: i32, arg3: i32, arg4: i32) anyerror!void;

    pub const OnKAnyFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnScrollTopFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnDropFn = fn (self: *Self, arg0: iup.Element, arg1: i32, arg2: i32) anyerror!void;

    pub const OnMarkFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnEnterItemFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnUnmapFn = fn (self: *Self) anyerror!void;

    pub const OnEnterWindowFn = fn (self: *Self) anyerror!void;

    pub const OnLeaveWindowFn = fn (self: *Self) anyerror!void;

    pub const OnClickFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnMarkedItFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32) anyerror!void;

    pub const OnDragBeginFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnTypeFn = fn (self: *Self, arg0: i32, arg1: i32) [:0]const u8;

    pub const OnDragDataSizeFn = fn (self: *Self, arg0: [:0]const u8) anyerror!void;

    pub const OnEditReleaseFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnLDestroyFn = fn (self: *Self) anyerror!void;

    pub const OnCanvasActionFn = fn (self: *Self, arg0: f32, arg1: f32) anyerror!void;

    pub const OnEditClickFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnPasteSizeFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnValueEditFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnFontFn = fn (self: *Self, arg0: i32, arg1: i32) [:0]const u8;

    pub const OnDropMotionFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnKeyPressFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnBusYFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnToggleValueFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32) anyerror!void;

    pub const OnResizeFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnGetFocusFn = fn (self: *Self) anyerror!void;

    pub const OnHelpFn = fn (self: *Self) anyerror!void;

    pub const OnFocusFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnDropSelectFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: iup.Element, arg3: [:0]const u8, arg4: i32, arg5: i32) anyerror!void;

    pub const OnDropFilesFn = fn (self: *Self, arg0: [:0]const u8, arg1: i32, arg2: i32, arg3: i32) anyerror!void;

    pub const OnEditIOnFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32) anyerror!void;

    pub const OnMenuDropFn = fn (self: *Self, arg0: iup.Element, arg1: i32, arg2: i32) anyerror!void;

    pub const OnDrawFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32, arg5: i32, arg6: *iup.Canvas) anyerror!void;

    pub const OnMenuCOnTextCloseFn = fn (self: *Self, arg0: iup.Element, arg1: i32, arg2: i32) anyerror!void;

    pub const OnValueFn = fn (self: *Self, arg0: i32, arg1: i32) [:0]const u8;

    pub const OnValueChangedFn = fn (self: *Self) anyerror!void;

    pub const OnReleaseFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnDragDataFn = fn (self: *Self, arg0: [:0]const u8, arg1: ?*anyopaque, arg2: i32) anyerror!void;

    pub const OnButtonFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: [:0]const u8) anyerror!void;

    pub const OnMapFn = fn (self: *Self) anyerror!void;

    pub const OnFgColorFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: *i32, arg3: *i32, arg4: *i32) anyerror!void;

    pub const OnNumEricGetValueFn = fn (self: *Self, arg0: i32, arg1: i32) f64;

    pub const OnBgColorFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: *i32, arg3: *i32, arg4: *i32) anyerror!void;

    pub const OnMenuCOnTextFn = fn (self: *Self, arg0: iup.Element, arg1: i32, arg2: i32) anyerror!void;

    pub const OnLeaveItemFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnResizeMatrixFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const Expand = enum {
        Yes,
        Horizontal,
        Vertical,
        HorizontalFree,
        VerticalFree,
        No,
    };

    pub const DrawTextAlignment = enum {
        ACenter,
        ARight,
        ALeft,
    };

    pub const ZOrder = enum {
        Top,
        Bottom,
    };

    pub const DrawStyle = enum {
        Fill,
        StrokeDash,
        StrokeDot,
        StrokeDashDot,
        StrokeDashDotdot,
        DrawStroke,
    };

    pub const Mark = enum {
        BLock,
        ClearAll,
        MarkAll,
        InVertAll,
        InVert,
    };

    pub const MarkMode = enum {
        SInGle,
        Multiple,
    };

    pub const ToggleValue = enum {
        On,
        Off,
        NotDef,
    };

    pub const Floating = enum {
        Yes,
        Ignore,
        No,
    };

    pub const Initializer = struct {
        last_error: ?anyerror = null,
        ref: *Self,

        ///
        /// Returns a pointer to IUP element or an error.
        /// Only top-level or detached elements needs to be unwraped,
        pub fn unwrap(self: Initializer) !*Self {
            if (self.last_error) |e| {
                return e;
            } else {
                return self.ref;
            }
        }

        ///
        /// Captures a reference into a external variable
        /// Allows to capture some references even using full declarative API
        pub fn capture(self: *Initializer, ref: **Self) Initializer {
            ref.* = self.ref;
            return self.*;
        }

        pub fn setStrAttribute(self: *Initializer, attributeName: [:0]const u8, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setStrAttribute(self.ref, attributeName, arg);
            return self.*;
        }

        pub fn setIntAttribute(self: *Initializer, attributeName: [:0]const u8, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setIntAttribute(self.ref, attributeName, arg);
            return self.*;
        }

        pub fn setBoolAttribute(self: *Initializer, attributeName: [:0]const u8, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setBoolAttribute(self.ref, attributeName, arg);
            return self.*;
        }

        pub fn setPtrAttribute(self: *Initializer, comptime T: type, attributeName: [:0]const u8, value: ?*T) Initializer {
            if (self.last_error) |_| return self.*;
            Self.setPtrAttribute(self.ref, T, attributeName, value);
            return self.*;
        }

        pub fn setHandle(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setHandle(self.ref, arg);
            return self.*;
        }

        pub fn setDrawTextLayoutCenter(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DRAWTEXTLAYOUTCENTER", .{}, arg);
            return self.*;
        }

        pub fn setDragTypes(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "DRAGTYPES", .{}, arg);
            return self.*;
        }

        pub fn setHiddenTextMarks(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "HIDDENTEXTMARKS", .{}, arg);
            return self.*;
        }

        pub fn setXMax(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "XMAX", .{}, arg);
            return self.*;
        }

        pub fn setFrameVertColor(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FRAMEVERTCOLOR", .{index}, arg);
            return self.*;
        }

        pub fn numEricUnitSymbolSearch(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICUNITSYMBOLSEARCH", .{}, arg);
            return self.*;
        }

        pub fn setVisibleCol(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "VISIBLECOL", .{index}, arg);
            return self.*;
        }

        pub fn setAlign(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "ALIGN", .{index}, arg);
            return self.*;
        }

        pub fn setFreeze(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FREEZE", .{}, arg);
            return self.*;
        }

        pub fn setSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self.*;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "SIZE", .{}, value);
            return self.*;
        }

        pub fn addCol(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "ADDCOL", .{}, arg);
            return self.*;
        }

        pub fn setFrameHorizColor(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FRAMEHORIZCOLOR", .{index}, arg);
            return self.*;
        }

        pub fn setValue(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "VALUE", .{}, arg);
            return self.*;
        }

        pub fn setNumEricFormatPrecision(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICFORMATPRECISION", .{index}, arg);
            return self.*;
        }

        pub fn setType(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TYPE", .{index}, arg);
            return self.*;
        }

        pub fn setSortImageDown(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SORTIMAGEDOWN", .{}, arg);
            return self.*;
        }

        pub fn moveCol(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MOVECOL", .{index}, arg);
            return self.*;
        }

        pub fn setTipFgColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setRgb(self.ref, "TIPFGCOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setNumEricDecimalSymbol(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICDECIMALSYMBOL", .{}, arg);
            return self.*;
        }

        pub fn setExpand(self: *Initializer, arg: ?Expand) Initializer {
            if (self.last_error) |_| return self.*;
            if (arg) |value| switch (value) {
                .Yes => interop.setStrAttribute(self.ref, "EXPAND", .{}, "YES"),
                .Horizontal => interop.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTAL"),
                .Vertical => interop.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICAL"),
                .HorizontalFree => interop.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTALFREE"),
                .VerticalFree => interop.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICALFREE"),
                .No => interop.setStrAttribute(self.ref, "EXPAND", .{}, "NO"),
            } else {
                interop.clearAttribute(self.ref, "EXPAND", .{});
            }
            return self.*;
        }

        pub fn setDrawTextOrientation(self: *Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setDoubleAttribute(self.ref, "DRAWTEXTORIENTATION", .{}, arg);
            return self.*;
        }

        pub fn setArea(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "AREA", .{}, arg);
            return self.*;
        }

        pub fn setMerged(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MERGED", .{index}, arg);
            return self.*;
        }

        pub fn setDrawTextAlignment(self: *Initializer, arg: ?DrawTextAlignment) Initializer {
            if (self.last_error) |_| return self.*;
            if (arg) |value| switch (value) {
                .ACenter => interop.setStrAttribute(self.ref, "DRAWTEXTALIGNMENT", .{}, "ACENTER"),
                .ARight => interop.setStrAttribute(self.ref, "DRAWTEXTALIGNMENT", .{}, "ARIGHT"),
                .ALeft => interop.setStrAttribute(self.ref, "DRAWTEXTALIGNMENT", .{}, "ALEFT"),
            } else {
                interop.clearAttribute(self.ref, "DRAWTEXTALIGNMENT", .{});
            }
            return self.*;
        }

        pub fn setDragSource(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DRAGSOURCE", .{}, arg);
            return self.*;
        }

        pub fn setDrawColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setRgb(self.ref, "DRAWCOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setArrowImages(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "ARROWIMAGES", .{}, arg);
            return self.*;
        }

        pub fn setHtmltd(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "HTML<TD>", .{}, arg);
            return self.*;
        }

        pub fn undoPushCell(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "UNDOPUSHCELL", .{index}, arg);
            return self.*;
        }

        pub fn undoPushEnd(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "UNDOPUSHEND", .{}, arg);
            return self.*;
        }

        pub fn setOrigInOffset(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "ORIGINOFFSET", .{}, arg);
            return self.*;
        }

        pub fn setDrawLineWidth(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "DRAWLINEWIDTH", .{}, arg);
            return self.*;
        }

        pub fn setNumColNoScroll(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMCOL_NOSCROLL", .{}, arg);
            return self.*;
        }

        pub fn setFitMaxHeight(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FITMAXHEIGHT", .{index}, arg);
            return self.*;
        }

        pub fn mergeSplit(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MERGESPLIT", .{}, arg);
            return self.*;
        }

        pub fn setUserSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self.*;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "USERSIZE", .{}, value);
            return self.*;
        }

        pub fn setMarked(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "MARKED", .{}, arg);
            return self.*;
        }

        pub fn setNumEricFormatDef(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICFORMATDEF", .{}, arg);
            return self.*;
        }

        pub fn clearValue(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "CLEARVALUE", .{index}, arg);
            return self.*;
        }

        pub fn setXMin(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "XMIN", .{}, arg);
            return self.*;
        }

        pub fn setDrawTextEllipsis(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DRAWTEXTELLIPSIS", .{}, arg);
            return self.*;
        }

        pub fn delLin(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "DELLIN", .{}, arg);
            return self.*;
        }

        pub fn setMaskInt(self: *Initializer, index: i32, begin: i32, end: i32) Initializer {
            if (self.last_error) |_| return self.*;
            var buffer: [128]u8 = undefined;
            var value = iup.Range.intIntToString(&buffer, begin, end, ',');
            interop.setStrAttribute(self.ref, "MASKINT", .{index}, value);
            return self.*;
        }

        pub fn setResizeDrag(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "RESIZEDRAG", .{}, arg);
            return self.*;
        }

        pub fn clAsSupDate(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "CLASSUPDATE", .{}, arg);
            return self.*;
        }

        pub fn paste(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "PASTE", .{}, arg);
            return self.*;
        }

        pub fn setNumEricUnitSpell(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICUNITSPELL", .{}, arg);
            return self.*;
        }

        pub fn setHtmlth(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "HTML<TH>", .{}, arg);
            return self.*;
        }

        pub fn showDialog(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SHOWDIALOG", .{}, arg);
            return self.*;
        }

        pub fn setNumLinVisibleLast(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMLIN_VISIBLE_LAST", .{}, arg);
            return self.*;
        }

        pub fn sortColUmn(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SORTCOLUMN", .{index}, arg);
            return self.*;
        }

        pub fn setFrameColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setRgb(self.ref, "FRAMECOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setIdValue(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "IDVALUE", .{index}, arg);
            return self.*;
        }

        pub fn show(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SHOW", .{}, arg);
            return self.*;
        }

        pub fn setSbImageBottomInactive(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGEBOTTOMINACTIVE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageBottomInactiveHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGEBOTTOMINACTIVE", .{}, arg);
            return self.*;
        }

        pub fn setMarkArea(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MARKAREA", .{}, arg);
            return self.*;
        }

        pub fn setFrameTitleHighlight(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FRAMETITLEHIGHLIGHT", .{}, arg);
            return self.*;
        }

        pub fn setSbImageTopPress(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGETOPPRESS", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageTopPressHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGETOPPRESS", .{}, arg);
            return self.*;
        }

        pub fn setBorder(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "BORDER", .{}, arg);
            return self.*;
        }

        pub fn setCanFocus(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "CANFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setSbImageTop(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGETOP", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageTopHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGETOP", .{}, arg);
            return self.*;
        }

        pub fn setToggleImageOff(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TOGGLEIMAGEOFF", .{}, arg);
            return self.*;
        }

        pub fn setMerge(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MERGE", .{index}, arg);
            return self.*;
        }

        pub fn setSortSign(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SORTSIGN", .{index}, arg);
            return self.*;
        }

        pub fn setSbImageRightInactive(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGERIGHTINACTIVE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageRightInactiveHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGERIGHTINACTIVE", .{}, arg);
            return self.*;
        }

        pub fn setSortColUmnCaseSensitive(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SORTCOLUMNCASESENSITIVE", .{}, arg);
            return self.*;
        }

        pub fn setToggleImageOn(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TOGGLEIMAGEON", .{}, arg);
            return self.*;
        }

        pub fn setYAutoHide(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "YAUTOHIDE", .{}, arg);
            return self.*;
        }

        pub fn setDrawTextClip(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DRAWTEXTCLIP", .{}, arg);
            return self.*;
        }

        pub fn setTheme(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "THEME", .{}, arg);
            return self.*;
        }

        pub fn zOrder(self: *Initializer, arg: ?ZOrder) Initializer {
            if (self.last_error) |_| return self.*;
            if (arg) |value| switch (value) {
                .Top => interop.setStrAttribute(self.ref, "ZORDER", .{}, "TOP"),
                .Bottom => interop.setStrAttribute(self.ref, "ZORDER", .{}, "BOTTOM"),
            } else {
                interop.clearAttribute(self.ref, "ZORDER", .{});
            }
            return self.*;
        }

        pub fn setSkipLines(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SKIPLINES", .{}, arg);
            return self.*;
        }

        pub fn setRasterHeight(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "RASTERHEIGHT", .{index}, arg);
            return self.*;
        }

        pub fn copyFile(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "COPYFILE", .{}, arg);
            return self.*;
        }

        pub fn setFocusCell(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FOCUSCELL", .{}, arg);
            return self.*;
        }

        pub fn setLineAlignment(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "LINEALIGNMENT", .{index}, arg);
            return self.*;
        }

        pub fn setVisibleLin(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "VISIBLELIN", .{index}, arg);
            return self.*;
        }

        pub fn setWidthDef(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "WIDTHDEF", .{}, arg);
            return self.*;
        }

        pub fn setRasterWidth(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "RASTERWIDTH", .{index}, arg);
            return self.*;
        }

        pub fn setFInDDirection(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FINDDIRECTION", .{}, arg);
            return self.*;
        }

        pub fn setVisible(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "VISIBLE", .{}, arg);
            return self.*;
        }

        pub fn setNumLinNoScroll(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMLIN_NOSCROLL", .{}, arg);
            return self.*;
        }

        pub fn setBgColor(self: *Initializer, index: i32, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setRgb(self.ref, "BGCOLOR", .{index}, rgb);
            return self.*;
        }

        pub fn addLin(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "ADDLIN", .{}, arg);
            return self.*;
        }

        pub fn setRasterSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self.*;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "RASTERSIZE", .{}, value);
            return self.*;
        }

        pub fn setDrawStyle(self: *Initializer, arg: ?DrawStyle) Initializer {
            if (self.last_error) |_| return self.*;
            if (arg) |value| switch (value) {
                .Fill => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "FILL"),
                .StrokeDash => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "STROKE_DASH"),
                .StrokeDot => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "STROKE_DOT"),
                .StrokeDashDot => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "STROKE_DASH_DOT"),
                .StrokeDashDotdot => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "STROKE_DASH_DOT_DOT"),
                .DrawStroke => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "DRAW_STROKE"),
            } else {
                interop.clearAttribute(self.ref, "DRAWSTYLE", .{});
            }
            return self.*;
        }

        pub fn numEricAddQuantitY(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICADDQUANTITY", .{}, arg);
            return self.*;
        }

        pub fn setShowFillValue(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SHOWFILLVALUE", .{}, arg);
            return self.*;
        }

        pub fn setDropTarget(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DROPTARGET", .{}, arg);
            return self.*;
        }

        pub fn setMaskNoEmpty(self: *Initializer, index: i32, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "MASKNOEMPTY", .{index}, arg);
            return self.*;
        }

        pub fn setHideFocus(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "HIDEFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setNumCol(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "NUMCOL", .{}, arg);
            return self.*;
        }

        pub fn numEricAddUnitSymbol(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICADDUNITSYMBOL", .{}, arg);
            return self.*;
        }

        pub fn moveLin(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MOVELIN", .{index}, arg);
            return self.*;
        }

        pub fn setSortColUmNoRder(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SORTCOLUMNORDER", .{}, arg);
            return self.*;
        }

        pub fn setSbImageBottom(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGEBOTTOM", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageBottomHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGEBOTTOM", .{}, arg);
            return self.*;
        }

        pub fn setUndoRedo(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "UNDOREDO", .{}, arg);
            return self.*;
        }

        pub fn setDrawMakeInactive(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DRAWMAKEINACTIVE", .{}, arg);
            return self.*;
        }

        pub fn numEricAddUnitFactor(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICADDUNITFACTOR", .{}, arg);
            return self.*;
        }

        pub fn setDX(self: *Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setDoubleAttribute(self.ref, "DX", .{}, arg);
            return self.*;
        }

        pub fn setDY(self: *Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setDoubleAttribute(self.ref, "DY", .{}, arg);
            return self.*;
        }

        pub fn setTypeColorInactive(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TYPECOLORINACTIVE", .{}, arg);
            return self.*;
        }

        pub fn setMultiline(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "MULTILINE", .{}, arg);
            return self.*;
        }

        pub fn setCellFrameVertColor(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "CELLFRAMEVERTCOLOR", .{index}, arg);
            return self.*;
        }

        pub fn setCaret(self: *Initializer, lin: i32, col: i32) Initializer {
            if (self.last_error) |_| return self.*;
            var buffer: [128]u8 = undefined;
            var value = iup.LinColPos.intIntToString(&buffer, lin, col, ',');
            interop.setStrAttribute(self.ref, "CARET", .{}, value);
            return self.*;
        }

        pub fn setHtmltr(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "HTML<TR>", .{}, arg);
            return self.*;
        }

        pub fn setFreezeColor(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FREEZECOLOR", .{}, arg);
            return self.*;
        }

        pub fn setNumColVisibleLast(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMCOL_VISIBLE_LAST", .{}, arg);
            return self.*;
        }

        pub fn setPosition(self: *Initializer, x: i32, y: i32) Initializer {
            if (self.last_error) |_| return self.*;
            var buffer: [128]u8 = undefined;
            var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
            interop.setStrAttribute(self.ref, "POSITION", .{}, value);
            return self.*;
        }

        pub fn setMinSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self.*;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "MINSIZE", .{}, value);
            return self.*;
        }

        pub fn setMinColWidthDef(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "MINCOLWIDTHDEF", .{}, arg);
            return self.*;
        }

        pub fn setResizeMatrixColor(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "RESIZEMATRIXCOLOR", .{}, arg);
            return self.*;
        }

        pub fn setLineX(self: *Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setDoubleAttribute(self.ref, "LINEX", .{}, arg);
            return self.*;
        }

        pub fn setLineY(self: *Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setDoubleAttribute(self.ref, "LINEY", .{}, arg);
            return self.*;
        }

        pub fn setNumEricUnitSymbol(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICUNITSYMBOL", .{index}, arg);
            return self.*;
        }

        pub fn numEricAddUnit(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICADDUNIT", .{}, arg);
            return self.*;
        }

        pub fn setCopyData(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "COPYDATA", .{}, arg);
            return self.*;
        }

        pub fn setDropTypes(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "DROPTYPES", .{}, arg);
            return self.*;
        }

        pub fn setHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "HANDLENAME", .{}, arg);
            return self.*;
        }

        pub fn setFontFace(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FONTFACE", .{}, arg);
            return self.*;
        }

        pub fn setSbImageTopInactive(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGETOPINACTIVE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageTopInactiveHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGETOPINACTIVE", .{}, arg);
            return self.*;
        }

        pub fn showMenuCOnText(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SHOWMENUCONTEXT", .{index}, arg);
            return self.*;
        }

        pub fn setMark(self: *Initializer, index: i32, arg: ?Mark) Initializer {
            if (self.last_error) |_| return self.*;
            if (arg) |value| switch (value) {
                .BLock => interop.setStrAttribute(self.ref, "MARK", .{index}, "BLOCK"),
                .ClearAll => interop.setStrAttribute(self.ref, "MARK", .{index}, "CLEARALL"),
                .MarkAll => interop.setStrAttribute(self.ref, "MARK", .{index}, "MARKALL"),
                .InVertAll => interop.setStrAttribute(self.ref, "MARK", .{index}, "INVERTALL"),
                .InVert => interop.setStrAttribute(self.ref, "MARK", .{index}, "INVERT"),
            } else {
                interop.clearAttribute(self.ref, "MARK", .{index});
            }
            return self.*;
        }

        pub fn setFInDmatchCase(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FINDMATCHCASE", .{}, arg);
            return self.*;
        }

        pub fn setMask(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MASK", .{index}, arg);
            return self.*;
        }

        pub fn pasteFile(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "PASTEFILE", .{}, arg);
            return self.*;
        }

        pub fn setMaxSize(self: *Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self.*;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "MAXSIZE", .{}, value);
            return self.*;
        }

        pub fn setFlat(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "FLAT", .{}, arg);
            return self.*;
        }

        pub fn setNoScrollAsTitle(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NOSCROLLASTITLE", .{}, arg);
            return self.*;
        }

        pub fn clearAttrib(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "CLEARATTRIB", .{index}, arg);
            return self.*;
        }

        pub fn setHeight(self: *Initializer, index: i32, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "HEIGHT", .{index}, arg);
            return self.*;
        }

        pub fn setFontStyle(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FONTSTYLE", .{index}, arg);
            return self.*;
        }

        pub fn setFrameTitleVertColor(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FRAMETITLEVERTCOLOR", .{index}, arg);
            return self.*;
        }

        pub fn fitToSize(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FITTOSIZE", .{}, arg);
            return self.*;
        }

        pub fn setFont(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FONT", .{index}, arg);
            return self.*;
        }

        pub fn setMultiple(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "MULTIPLE", .{}, arg);
            return self.*;
        }

        pub fn setSbImageRightPress(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGERIGHTPRESS", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageRightPressHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGERIGHTPRESS", .{}, arg);
            return self.*;
        }

        pub fn setCursor(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "CURSOR", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setCursorHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "CURSOR", .{}, arg);
            return self.*;
        }

        pub fn setMinColWidth(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MINCOLWIDTH", .{index}, arg);
            return self.*;
        }

        pub fn setSortImageUp(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SORTIMAGEUP", .{}, arg);
            return self.*;
        }

        pub fn setNumEricUnitShown(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICUNITSHOWN", .{index}, arg);
            return self.*;
        }

        pub fn setWheelDropFocus(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "WHEELDROPFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setFileFormat(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FILEFORMAT", .{}, arg);
            return self.*;
        }

        pub fn setNumEricQuantitY(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICQUANTITY", .{index}, arg);
            return self.*;
        }

        pub fn setFontSize(self: *Initializer, index: i32, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "FONTSIZE", .{index}, arg);
            return self.*;
        }

        pub fn undoPushBegin(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "UNDOPUSHBEGIN", .{}, arg);
            return self.*;
        }

        pub fn copyCol(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "COPYCOL", .{index}, arg);
            return self.*;
        }

        pub fn pasteData(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "PASTEDATA", .{}, arg);
            return self.*;
        }

        pub fn setTipMarkup(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TIPMARKUP", .{}, arg);
            return self.*;
        }

        pub fn setSbImageLeftHighlight(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGELEFTHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageLeftHighlightHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGELEFTHIGHLIGHT", .{}, arg);
            return self.*;
        }

        pub fn setCellFrameHorizColor(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "CELLFRAMEHORIZCOLOR", .{index}, arg);
            return self.*;
        }

        pub fn setRedo(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "REDO", .{}, arg);
            return self.*;
        }

        pub fn setYMax(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "YMAX", .{}, arg);
            return self.*;
        }

        pub fn setSbImageLeft(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGELEFT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageLeftHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGELEFT", .{}, arg);
            return self.*;
        }

        pub fn setNTheme(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NTHEME", .{}, arg);
            return self.*;
        }

        pub fn setFitMaxWidth(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FITMAXWIDTH", .{index}, arg);
            return self.*;
        }

        pub fn undoClear(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "UNDOCLEAR", .{}, arg);
            return self.*;
        }

        pub fn setSkipColumns(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SKIPCOLUMNS", .{}, arg);
            return self.*;
        }

        pub fn setDragSourceMove(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DRAGSOURCEMOVE", .{}, arg);
            return self.*;
        }

        pub fn setNumLin(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "NUMLIN", .{}, arg);
            return self.*;
        }

        pub fn setNumEricUnit(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICUNIT", .{index}, arg);
            return self.*;
        }

        pub fn setResizeMatrix(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "RESIZEMATRIX", .{}, arg);
            return self.*;
        }

        pub fn setActive(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "ACTIVE", .{}, arg);
            return self.*;
        }

        pub fn setSbImageTopHighlight(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGETOPHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageTopHighlightHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGETOPHIGHLIGHT", .{}, arg);
            return self.*;
        }

        pub fn setFgColor(self: *Initializer, index: i32, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setRgb(self.ref, "FGCOLOR", .{index}, rgb);
            return self.*;
        }

        pub fn setHlColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setRgb(self.ref, "HLCOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setTipIcon(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TIPICON", .{}, arg);
            return self.*;
        }

        pub fn setMaskCasei(self: *Initializer, index: i32, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "MASKCASEI", .{index}, arg);
            return self.*;
        }

        pub fn fitToText(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FITTOTEXT", .{}, arg);
            return self.*;
        }

        pub fn setLimitExpand(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "LIMITEXPAND", .{}, arg);
            return self.*;
        }

        pub fn numEricUnitSearch(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICUNITSEARCH", .{}, arg);
            return self.*;
        }

        pub fn setPosX(self: *Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setDoubleAttribute(self.ref, "POSX", .{}, arg);
            return self.*;
        }

        pub fn setPosY(self: *Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setDoubleAttribute(self.ref, "POSY", .{}, arg);
            return self.*;
        }

        pub fn setNumEricQuantitYIndex(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICQUANTITYINDEX", .{index}, arg);
            return self.*;
        }

        pub fn setMenuCOnText(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MENUCONTEXT", .{}, arg);
            return self.*;
        }

        pub fn setXAutoHide(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "XAUTOHIDE", .{}, arg);
            return self.*;
        }

        pub fn setTipVisible(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "TIPVISIBLE", .{}, arg);
            return self.*;
        }

        pub fn setMarkMode(self: *Initializer, arg: ?MarkMode) Initializer {
            if (self.last_error) |_| return self.*;
            if (arg) |value| switch (value) {
                .SInGle => interop.setStrAttribute(self.ref, "MARKMODE", .{}, "SINGLE"),
                .Multiple => interop.setStrAttribute(self.ref, "MARKMODE", .{}, "MULTIPLE"),
            } else {
                interop.clearAttribute(self.ref, "MARKMODE", .{});
            }
            return self.*;
        }

        pub fn setDrawFont(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "DRAWFONT", .{}, arg);
            return self.*;
        }

        pub fn setHeightDef(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "HEIGHTDEF", .{}, arg);
            return self.*;
        }

        pub fn setExpandWeight(self: *Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setDoubleAttribute(self.ref, "EXPANDWEIGHT", .{}, arg);
            return self.*;
        }

        pub fn setCopyKeepstruct(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "COPYKEEPSTRUCT", .{}, arg);
            return self.*;
        }

        pub fn setTextSeparator(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TEXTSEPARATOR", .{}, arg);
            return self.*;
        }

        pub fn setTipBgColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setRgb(self.ref, "TIPBGCOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setOrigIn(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "ORIGIN", .{}, arg);
            return self.*;
        }

        pub fn copy(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "COPY", .{}, arg);
            return self.*;
        }

        pub fn setLateXLabel(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "LATEXLABEL", .{}, arg);
            return self.*;
        }

        pub fn setDrawBgColor(self: *Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setRgb(self.ref, "DRAWBGCOLOR", .{}, rgb);
            return self.*;
        }

        pub fn setTextSkipLines(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TEXTSKIPLINES", .{}, arg);
            return self.*;
        }

        pub fn setEditMode(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "EDITMODE", .{}, arg);
            return self.*;
        }

        pub fn setEditNext(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "EDITNEXT", .{}, arg);
            return self.*;
        }

        pub fn setYMin(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "YMIN", .{}, arg);
            return self.*;
        }

        pub fn setToggleCenterEd(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TOGGLECENTERED", .{}, arg);
            return self.*;
        }

        pub fn setNormalizerGroup(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NORMALIZERGROUP", .{}, arg);
            return self.*;
        }

        pub fn setScrollBar(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "SCROLLBAR", .{}, arg);
            return self.*;
        }

        pub fn setBusY(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "BUSY", .{}, arg);
            return self.*;
        }

        pub fn setUseTitleSize(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "USETITLESIZE", .{}, arg);
            return self.*;
        }

        pub fn setDropFilesTarget(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DROPFILESTARGET", .{}, arg);
            return self.*;
        }

        pub fn setAlignmentLin0(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "ALIGNMENTLIN0", .{}, arg);
            return self.*;
        }

        pub fn setFrameBorder(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FRAMEBORDER", .{}, arg);
            return self.*;
        }

        pub fn setNumEricUnitShowNIndex(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICUNITSHOWNINDEX", .{index}, arg);
            return self.*;
        }

        pub fn setFrameTitleHorizColor(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FRAMETITLEHORIZCOLOR", .{index}, arg);
            return self.*;
        }

        pub fn setMarkAtTitle(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MARKATTITLE", .{}, arg);
            return self.*;
        }

        pub fn setCopyColTo(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "COPYCOLTO", .{index}, arg);
            return self.*;
        }

        pub fn setEditHideOnFocus(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "EDITHIDEONFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setSbImageRightHighlight(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGERIGHTHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageRightHighlightHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGERIGHTHIGHLIGHT", .{}, arg);
            return self.*;
        }

        pub fn setUndo(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "UNDO", .{}, arg);
            return self.*;
        }

        pub fn setNumEricUnitIndex(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICUNITINDEX", .{index}, arg);
            return self.*;
        }

        pub fn setHtmlCaption(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "HTML<CAPTION>", .{}, arg);
            return self.*;
        }

        pub fn setSbImageLeftPress(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGELEFTPRESS", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageLeftPressHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGELEFTPRESS", .{}, arg);
            return self.*;
        }

        pub fn setCopyCaption(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "COPYCAPTION", .{}, arg);
            return self.*;
        }

        pub fn setHlColorAlpha(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "HLCOLORALPHA", .{}, arg);
            return self.*;
        }

        pub fn setHtmlTable(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "HTML<TABLE>", .{}, arg);
            return self.*;
        }

        pub fn setSbImageBottomHighlight(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGEBOTTOMHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageBottomHighlightHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGEBOTTOMHIGHLIGHT", .{}, arg);
            return self.*;
        }

        pub fn setNumEricUnitSymbolShown(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICUNITSYMBOLSHOWN", .{index}, arg);
            return self.*;
        }

        pub fn setDrawTextWrap(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DRAWTEXTWRAP", .{}, arg);
            return self.*;
        }

        pub fn delCol(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "DELCOL", .{}, arg);
            return self.*;
        }

        pub fn setTip(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TIP", .{}, arg);
            return self.*;
        }

        pub fn setDragDrop(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "DRAGDROP", .{}, arg);
            return self.*;
        }

        pub fn setTipDelay(self: *Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "TIPDELAY", .{}, arg);
            return self.*;
        }

        pub fn setToggleValue(self: *Initializer, index: i32, arg: ?ToggleValue) Initializer {
            if (self.last_error) |_| return self.*;
            if (arg) |value| switch (value) {
                .On => interop.setStrAttribute(self.ref, "TOGGLEVALUE", .{index}, "ON"),
                .Off => interop.setStrAttribute(self.ref, "TOGGLEVALUE", .{index}, "OFF"),
                .NotDef => interop.setStrAttribute(self.ref, "TOGGLEVALUE", .{index}, "NOTDEF"),
            } else {
                interop.clearAttribute(self.ref, "TOGGLEVALUE", .{index});
            }
            return self.*;
        }

        pub fn copyLin(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "COPYLIN", .{index}, arg);
            return self.*;
        }

        pub fn setNumColVisible(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMCOL_VISIBLE", .{}, arg);
            return self.*;
        }

        pub fn setSbImageRight(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGERIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageRightHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGERIGHT", .{}, arg);
            return self.*;
        }

        pub fn setFInd(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FIND", .{}, arg);
            return self.*;
        }

        pub fn setNumEricFormatTitle(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICFORMATTITLE", .{index}, arg);
            return self.*;
        }

        pub fn setSbImageLeftInactive(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGELEFTINACTIVE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageLeftInactiveHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGELEFTINACTIVE", .{}, arg);
            return self.*;
        }

        pub fn setMarkMultiple(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "MARKMULTIPLE", .{}, arg);
            return self.*;
        }

        pub fn setFloating(self: *Initializer, arg: ?Floating) Initializer {
            if (self.last_error) |_| return self.*;
            if (arg) |value| switch (value) {
                .Yes => interop.setStrAttribute(self.ref, "FLOATING", .{}, "YES"),
                .Ignore => interop.setStrAttribute(self.ref, "FLOATING", .{}, "IGNORE"),
                .No => interop.setStrAttribute(self.ref, "FLOATING", .{}, "NO"),
            } else {
                interop.clearAttribute(self.ref, "FLOATING", .{});
            }
            return self.*;
        }

        pub fn setNumEricFormat(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMERICFORMAT", .{index}, arg);
            return self.*;
        }

        pub fn setWidth(self: *Initializer, index: i32, arg: i32) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setIntAttribute(self.ref, "WIDTH", .{index}, arg);
            return self.*;
        }

        pub fn setTouch(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "TOUCH", .{}, arg);
            return self.*;
        }

        pub fn setBusYProgress(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "BUSYPROGRESS", .{}, arg);
            return self.*;
        }

        pub fn setName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NAME", .{}, arg);
            return self.*;
        }

        pub fn setReadonly(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "READONLY", .{}, arg);
            return self.*;
        }

        pub fn setFInDmatchWholeCell(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "FINDMATCHWHOLECELL", .{}, arg);
            return self.*;
        }

        pub fn setNumLinVisible(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "NUMLIN_VISIBLE", .{}, arg);
            return self.*;
        }

        pub fn setPropagateFocus(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "PROPAGATEFOCUS", .{}, arg);
            return self.*;
        }

        pub fn setBackingStore(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "BACKINGSTORE", .{}, arg);
            return self.*;
        }

        pub fn setSbImageBottomPress(self: *Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGEBOTTOMPRESS", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setSbImageBottomPressHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "SB_IMAGEBOTTOMPRESS", .{}, arg);
            return self.*;
        }

        pub fn setMdiClient(self: *Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setBoolAttribute(self.ref, "MDICLIENT", .{}, arg);
            return self.*;
        }

        pub fn setMdiMenu(self: *Initializer, arg: *iup.Menu) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setHandleAttribute(self.ref, "MDIMENU", .{}, arg);
            return self.*;
        }

        pub fn setMdiMenuHandleName(self: *Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "MDIMENU", .{}, arg);
            return self.*;
        }


        /// 
        /// TABIMAGEn (non inheritable): image name to be used in the respective tab.
        /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
        /// n starts at 0.
        /// See also IupImage.
        /// In Motif, the image is shown only if TABTITLEn is NULL.
        /// In Windows and Motif set the BGCOLOR attribute before setting the image.
        /// When set after map will update the TABIMAGE attribute on the respective
        /// child (since 3.10).
        /// (since 3.0).
        /// TABIMAGE (non inheritable) (at children only): Same as TABIMAGEn but set in
        /// each child.
        /// Works only if set before the child is added to the tabs.
        pub fn setTabImage(self: *Initializer, index: i32, arg: anytype) Initializer {
            if (self.last_error) |_| return self.*;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "TABIMAGE", .{index}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self.*;
        }

        pub fn setTabImageHandleName(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TABIMAGE", .{index}, arg);
            return self.*;
        }


        /// 
        /// TABTITLEn (non inheritable): Contains the text to be shown in the
        /// respective tab title.
        /// n starts at 0.
        /// If this value is NULL, it will remain empty.
        /// The "&" character can be used to define a mnemonic, the next character will
        /// be used as key.
        /// Use "&&" to show the "&" character instead on defining a mnemonic.
        /// The button can be activated from any control in the dialog using the
        /// "Alt+key" combination.
        /// (mnemonic support since 3.3).
        /// When set after map will update the TABTITLE attribute on the respective
        /// child (since 3.10).
        /// (since 3.0).
        /// TABTITLE (non inheritable) (at children only): Same as TABTITLEn but set in
        /// each child.
        /// Works only if set before the child is added to the tabs.
        pub fn setTabTitle(self: *Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self.*;
            interop.setStrAttribute(self.ref, "TABTITLE", .{index}, arg);
            return self.*;
        }

        pub fn setColResizeCallback(self: *Initializer, callback: ?OnColResizeFn) Initializer {
            const Handler = CallbackHandler(Self, OnColResizeFn, "COLRESIZE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setWheelCallback(self: *Initializer, callback: ?OnWheelFn) Initializer {
            const Handler = CallbackHandler(Self, OnWheelFn, "WHEEL_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setEditMouseMoveCallback(self: *Initializer, callback: ?OnEditMouseMoveFn) Initializer {
            const Handler = CallbackHandler(Self, OnEditMouseMoveFn, "EDITMOUSEMOVE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDropCheckCallback(self: *Initializer, callback: ?OnDropCheckFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropCheckFn, "DROPCHECK_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDestroyCallback(self: *Initializer, callback: ?OnDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setNumEricSetValueCallback(self: *Initializer, callback: ?OnNumEricSetValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnNumEricSetValueFn, "NUMERICSETVALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setKillFocusCallback(self: *Initializer, callback: ?OnKillFocusFn) Initializer {
            const Handler = CallbackHandler(Self, OnKillFocusFn, "KILLFOCUS_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setMotionCallback(self: *Initializer, callback: ?OnMotionFn) Initializer {
            const Handler = CallbackHandler(Self, OnMotionFn, "MOTION_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDragEndCallback(self: *Initializer, callback: ?OnDragEndFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragEndFn, "DRAGEND_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setSortColUmncompareCallback(self: *Initializer, callback: ?OnSortColUmncompareFn) Initializer {
            const Handler = CallbackHandler(Self, OnSortColUmncompareFn, "SORTCOLUMNCOMPARE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setPostMessageCallback(self: *Initializer, callback: ?OnPostMessageFn) Initializer {
            const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setTranslateValueCallback(self: *Initializer, callback: ?OnTranslateValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnTranslateValueFn, "TRANSLATEVALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setScrollCallback(self: *Initializer, callback: ?OnScrollFn) Initializer {
            const Handler = CallbackHandler(Self, OnScrollFn, "SCROLL_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setMouseMoveCallback(self: *Initializer, callback: ?OnMouseMoveFn) Initializer {
            const Handler = CallbackHandler(Self, OnMouseMoveFn, "MOUSEMOVE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setActionCallback(self: *Initializer, callback: ?OnActionFn) Initializer {
            const Handler = CallbackHandler(Self, OnActionFn, "ACTION_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setWomCallback(self: *Initializer, callback: ?OnWomFn) Initializer {
            const Handler = CallbackHandler(Self, OnWomFn, "WOM_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDropDataCallback(self: *Initializer, callback: ?OnDropDataFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropDataFn, "DROPDATA_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setKAnyCallback(self: *Initializer, callback: ?OnKAnyFn) Initializer {
            const Handler = CallbackHandler(Self, OnKAnyFn, "K_ANY");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setScrollTopCallback(self: *Initializer, callback: ?OnScrollTopFn) Initializer {
            const Handler = CallbackHandler(Self, OnScrollTopFn, "SCROLLTOP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDropCallback(self: *Initializer, callback: ?OnDropFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropFn, "DROP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setMarkCallback(self: *Initializer, callback: ?OnMarkFn) Initializer {
            const Handler = CallbackHandler(Self, OnMarkFn, "MARK_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setEnterItemCallback(self: *Initializer, callback: ?OnEnterItemFn) Initializer {
            const Handler = CallbackHandler(Self, OnEnterItemFn, "ENTERITEM_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setUnmapCallback(self: *Initializer, callback: ?OnUnmapFn) Initializer {
            const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setEnterWindowCallback(self: *Initializer, callback: ?OnEnterWindowFn) Initializer {
            const Handler = CallbackHandler(Self, OnEnterWindowFn, "ENTERWINDOW_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setLeaveWindowCallback(self: *Initializer, callback: ?OnLeaveWindowFn) Initializer {
            const Handler = CallbackHandler(Self, OnLeaveWindowFn, "LEAVEWINDOW_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setClickCallback(self: *Initializer, callback: ?OnClickFn) Initializer {
            const Handler = CallbackHandler(Self, OnClickFn, "CLICK_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setMarkedItCallback(self: *Initializer, callback: ?OnMarkedItFn) Initializer {
            const Handler = CallbackHandler(Self, OnMarkedItFn, "MARKEDIT_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDragBeginCallback(self: *Initializer, callback: ?OnDragBeginFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragBeginFn, "DRAGBEGIN_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setTypeCallback(self: *Initializer, callback: ?OnTypeFn) Initializer {
            const Handler = CallbackHandler(Self, OnTypeFn, "TYPE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDragDataSizeCallback(self: *Initializer, callback: ?OnDragDataSizeFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragDataSizeFn, "DRAGDATASIZE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setEditReleaseCallback(self: *Initializer, callback: ?OnEditReleaseFn) Initializer {
            const Handler = CallbackHandler(Self, OnEditReleaseFn, "EDITRELEASE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setLDestroyCallback(self: *Initializer, callback: ?OnLDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setCanvasActionCallback(self: *Initializer, callback: ?OnCanvasActionFn) Initializer {
            const Handler = CallbackHandler(Self, OnCanvasActionFn, "ACTION");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setEditClickCallback(self: *Initializer, callback: ?OnEditClickFn) Initializer {
            const Handler = CallbackHandler(Self, OnEditClickFn, "EDITCLICK_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setPasteSizeCallback(self: *Initializer, callback: ?OnPasteSizeFn) Initializer {
            const Handler = CallbackHandler(Self, OnPasteSizeFn, "PASTESIZE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setValueEditCallback(self: *Initializer, callback: ?OnValueEditFn) Initializer {
            const Handler = CallbackHandler(Self, OnValueEditFn, "VALUE_EDIT_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setFontCallback(self: *Initializer, callback: ?OnFontFn) Initializer {
            const Handler = CallbackHandler(Self, OnFontFn, "FONT_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDropMotionCallback(self: *Initializer, callback: ?OnDropMotionFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropMotionFn, "DROPMOTION_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setKeyPressCallback(self: *Initializer, callback: ?OnKeyPressFn) Initializer {
            const Handler = CallbackHandler(Self, OnKeyPressFn, "KEYPRESS_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setBusYCallback(self: *Initializer, callback: ?OnBusYFn) Initializer {
            const Handler = CallbackHandler(Self, OnBusYFn, "BUSY_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setToggleValueCallback(self: *Initializer, callback: ?OnToggleValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnToggleValueFn, "TOGGLEVALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setResizeCallback(self: *Initializer, callback: ?OnResizeFn) Initializer {
            const Handler = CallbackHandler(Self, OnResizeFn, "RESIZE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setGetFocusCallback(self: *Initializer, callback: ?OnGetFocusFn) Initializer {
            const Handler = CallbackHandler(Self, OnGetFocusFn, "GETFOCUS_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setHelpCallback(self: *Initializer, callback: ?OnHelpFn) Initializer {
            const Handler = CallbackHandler(Self, OnHelpFn, "HELP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setFocusCallback(self: *Initializer, callback: ?OnFocusFn) Initializer {
            const Handler = CallbackHandler(Self, OnFocusFn, "FOCUS_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDropSelectCallback(self: *Initializer, callback: ?OnDropSelectFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropSelectFn, "DROPSELECT_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDropFilesCallback(self: *Initializer, callback: ?OnDropFilesFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropFilesFn, "DROPFILES_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setEditIOnCallback(self: *Initializer, callback: ?OnEditIOnFn) Initializer {
            const Handler = CallbackHandler(Self, OnEditIOnFn, "EDITION_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setMenuDropCallback(self: *Initializer, callback: ?OnMenuDropFn) Initializer {
            const Handler = CallbackHandler(Self, OnMenuDropFn, "MENUDROP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDrawCallback(self: *Initializer, callback: ?OnDrawFn) Initializer {
            const Handler = CallbackHandler(Self, OnDrawFn, "DRAW_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setMenuCOnTextCloseCallback(self: *Initializer, callback: ?OnMenuCOnTextCloseFn) Initializer {
            const Handler = CallbackHandler(Self, OnMenuCOnTextCloseFn, "MENUCONTEXTCLOSE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setValueCallback(self: *Initializer, callback: ?OnValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnValueFn, "VALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setValueChangedCallback(self: *Initializer, callback: ?OnValueChangedFn) Initializer {
            const Handler = CallbackHandler(Self, OnValueChangedFn, "VALUECHANGED_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setReleaseCallback(self: *Initializer, callback: ?OnReleaseFn) Initializer {
            const Handler = CallbackHandler(Self, OnReleaseFn, "RELEASE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setDragDataCallback(self: *Initializer, callback: ?OnDragDataFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragDataFn, "DRAGDATA_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setButtonCallback(self: *Initializer, callback: ?OnButtonFn) Initializer {
            const Handler = CallbackHandler(Self, OnButtonFn, "BUTTON_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setMapCallback(self: *Initializer, callback: ?OnMapFn) Initializer {
            const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setFgColorCallback(self: *Initializer, callback: ?OnFgColorFn) Initializer {
            const Handler = CallbackHandler(Self, OnFgColorFn, "FGCOLOR_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setNumEricGetValueCallback(self: *Initializer, callback: ?OnNumEricGetValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnNumEricGetValueFn, "NUMERICGETVALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setBgColorCallback(self: *Initializer, callback: ?OnBgColorFn) Initializer {
            const Handler = CallbackHandler(Self, OnBgColorFn, "BGCOLOR_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setMenuCOnTextCallback(self: *Initializer, callback: ?OnMenuCOnTextFn) Initializer {
            const Handler = CallbackHandler(Self, OnMenuCOnTextFn, "MENUCONTEXT_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setLeaveItemCallback(self: *Initializer, callback: ?OnLeaveItemFn) Initializer {
            const Handler = CallbackHandler(Self, OnLeaveItemFn, "LEAVEITEM_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }

        pub fn setResizeMatrixCallback(self: *Initializer, callback: ?OnResizeMatrixFn) Initializer {
            const Handler = CallbackHandler(Self, OnResizeMatrixFn, "RESIZEMATRIX_CB");
            Handler.setCallback(self.ref, callback);
            return self.*;
        }
    };

    pub fn setStrAttribute(self: *Self, attribute: [:0]const u8, arg: [:0]const u8) void {
        interop.setStrAttribute(self, attribute, .{}, arg);
    }

    pub fn getStrAttribute(self: *Self, attribute: [:0]const u8) [:0]const u8 {
        return interop.getStrAttribute(self, attribute, .{});
    }

    pub fn setIntAttribute(self: *Self, attribute: [:0]const u8, arg: i32) void {
        interop.setIntAttribute(self, attribute, .{}, arg);
    }

    pub fn getIntAttribute(self: *Self, attribute: [:0]const u8) i32 {
        return interop.getIntAttribute(self, attribute, .{});
    }

    pub fn setBoolAttribute(self: *Self, attribute: [:0]const u8, arg: bool) void {
        interop.setBoolAttribute(self, attribute, .{}, arg);
    }

    pub fn getBoolAttribute(self: *Self, attribute: [:0]const u8) bool {
        return interop.getBoolAttribute(self, attribute, .{});
    }

    pub fn getPtrAttribute(self: *Self, comptime T: type, attribute: [:0]const u8) ?*T {
        return interop.getPtrAttribute(T, self, attribute, .{});
    }

    pub fn setPtrAttribute(self: *Self, comptime T: type, attribute: [:0]const u8, value: ?*T) void {
        interop.setPtrAttribute(T, self, attribute, .{}, value);
    }

    pub fn setHandle(self: *Self, arg: [:0]const u8) void {
        interop.setHandle(self, arg);
    }

    pub fn fromHandleName(handle_name: [:0]const u8) ?*Self {
        return interop.fromHandleName(Self, handle_name);
    }

    pub fn postMessage(self: *Self, s: [:0]const u8, i: i32, f: f64, p: ?*anyopaque) void {
        return interop.postMessage(self, s, i, f, p);
    }

    ///
    /// Creates an interface element given its class name and parameters.
    /// After creation the element still needs to be attached to a container and mapped to the native system so it can be visible.
    pub fn init() Initializer {
        var handle = interop.create(Self);

        if (handle) |valid| {
            return .{
                .ref = @ptrCast(*Self, valid),
            };
        } else {
            return .{ .ref = undefined, .last_error = Error.NotInitialized };
        }
    }

    /// 
    /// Destroys an interface element and all its children.
    /// Only dialogs, timers, popup menus and images should be normally destroyed, but detached elements can also be destroyed.        
    pub fn deinit(self: *Self) void {
        interop.destroy(self);
    }

    /// 
    /// Creates (maps) the native interface objects corresponding to the given IUP interface elements.
    /// It will also called recursively to create the native element of all the children in the element's tree.
    /// The element must be already attached to a mapped container, except the dialog. A child can only be mapped if its parent is already mapped.
    /// This function is automatically called before the dialog is shown in IupShow, IupShowXY or IupPopup.
    /// If the element is a dialog then the abstract layout will be updated even if the dialog is already mapped. If the dialog is visible the elements will be immediately repositioned. Calling IupMap for an already mapped dialog is the same as only calling IupRefresh for the dialog.
    /// Calling IupMap for an already mapped element that is not a dialog does nothing.
    /// If you add new elements to an already mapped dialog you must call IupMap for that elements. And then call IupRefresh to update the dialog layout.
    /// If the WID attribute of an element is NULL, it means the element was not already mapped. Some containers do not have a native element associated, like VBOX and HBOX. In this case their WID is a fake value (void*)(-1).
    /// It is useful for the application to call IupMap when the value of the WID attribute must be known, i.e. the native element must exist, before a dialog is made visible.
    /// The MAP_CB callback is called at the end of the IupMap function, after all processing, so it can also be used to create other things that depend on the WID attribute. But notice that for non dialog elements it will be called before the dialog layout has been updated, so the element current size will still be 0x0 (since 3.14).
    pub fn map(self: *Self) !void {
        try interop.map(self);
    }

    ///
    ///
    pub fn getDialog(self: *Self) ?*iup.Dialog {
        return interop.getDialog(self);
    }

    ///
    /// Returns the the child element that has the NAME attribute equals to the given value on the same dialog hierarchy.
    /// Works also for children of a menu that is associated with a dialog.
    pub fn getDialogChild(self: *Self, byName: [:0]const u8) ?Element {
        return interop.getDialogChild(self, byName);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog.
    /// To be used after changing size attributes, or attributes that affect the size of the control. Can be used for any element inside a dialog, but the layout of the dialog and all controls will be updated. It can change the layout of all the controls inside the dialog because of the dynamic layout positioning.
    pub fn refresh(self: *Self) void {
        Impl(Self).refresh(self);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog. 
    pub fn update(self: *Self) void {
        Impl(Self).update(self);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog. 
    pub fn updateChildren(self: *Self) void {
        Impl(Self).updateChildren(self);
    }

    ///
    /// Force the element and its children to be redrawn immediately. 
    pub fn redraw(self: *Self, redraw_children: bool) void {
        Impl(Self).redraw(self, redraw_children);
    }

    pub fn getIntId(self: *Self, attribute: [:0]const u8, index: i32) i32 {
        return interop.getIntAttribute(self, attribute, .{index});
    }

    pub fn setIntId(self: *Self, attribute: [:0]const u8, index: i32, value: i32) void {
        interop.setIntAttribute(self, attribute, .{index}, value);
    }

    pub fn getFloatId(self: *Self, attribute: [:0]const u8, index: i32) f32 {
        return interop.getFloatAttribute(self, attribute, .{index});
    }

    pub fn setFloatId(self: *Self, attribute: [:0]const u8, index: i32, value: f32) void {
        interop.setFloatAttribute(self, attribute, .{index}, value);
    }

    pub fn getDoubleId(self: *Self, attribute: [:0]const u8, index: i32) f64 {
        return interop.getDoubleAttribute(self, attribute, .{index});
    }

    pub fn setDoubleId(self: *Self, attribute: [:0]const u8, index: i32, value: f64) void {
        interop.setFloatAttribute(self, attribute, .{index}, value);
    }

    pub fn getStrId(self: *Self, attribute: [:0]const u8, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, attribute, .{index});
    }

    pub fn setStrId(self: *Self, attribute: [:0]const u8, index: i32, value: [:0]const u8) void {
        interop.setStrAttribute(self, attribute, .{index}, value);
    }

    pub fn getPtrId(self: *Self, comptime T: type, attribute: [:0]const u8, index: i32) ?*T {
        return interop.getPtrAttribute(type, self, attribute, .{index});
    }

    pub fn setPtrId(self: *Self, comptime T: type, attribute: [:0]const u8, index: i32, value: ?*T) void {
        interop.setPtrAttribute(type, self, attribute, .{index}, value);
    }

    pub fn getDrawTextLayoutCenter(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWTEXTLAYOUTCENTER", .{});
    }

    pub fn setDrawTextLayoutCenter(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWTEXTLAYOUTCENTER", .{}, arg);
    }

    pub fn getDragTypes(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "DRAGTYPES", .{});
    }

    pub fn setDragTypes(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DRAGTYPES", .{}, arg);
    }

    pub fn getHiddenTextMarks(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HIDDENTEXTMARKS", .{});
    }

    pub fn setHiddenTextMarks(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HIDDENTEXTMARKS", .{}, arg);
    }

    pub fn getNumEricfoundUnitSymbol(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFOUNDUNITSYMBOL", .{});
    }

    pub fn getXMax(self: *Self) i32 {
        return interop.getIntAttribute(self, "XMAX", .{});
    }

    pub fn setXMax(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "XMAX", .{}, arg);
    }

    pub fn getFrameVertColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMEVERTCOLOR", .{index});
    }

    pub fn setFrameVertColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMEVERTCOLOR", .{index}, arg);
    }

    pub fn numEricUnitSymbolSearch(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITSYMBOLSEARCH", .{}, arg);
    }

    pub fn getVisibleCol(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "VISIBLECOL", .{index});
    }

    pub fn setVisibleCol(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "VISIBLECOL", .{index}, arg);
    }

    pub fn getAlign(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "ALIGN", .{index});
    }

    pub fn setAlign(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ALIGN", .{index}, arg);
    }

    pub fn getFreeze(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FREEZE", .{});
    }

    pub fn setFreeze(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FREEZE", .{}, arg);
    }

    pub fn getSortColUmnInterval(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTCOLUMNINTERVAL", .{});
    }

    pub fn getSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "SIZE", .{});
        return Size.parse(str);
    }

    pub fn setSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "SIZE", .{}, value);
    }

    pub fn getScreenPosition(self: *Self) iup.XYPos {
        var str = interop.getStrAttribute(self, "SCREENPOSITION", .{});
        return iup.XYPos.parse(str, ',');
    }

    pub fn addCol(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ADDCOL", .{}, arg);
    }

    pub fn getX(self: *Self) i32 {
        return interop.getIntAttribute(self, "X", .{});
    }

    pub fn getY(self: *Self) i32 {
        return interop.getIntAttribute(self, "Y", .{});
    }

    pub fn getFrameHorizColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMEHORIZCOLOR", .{index});
    }

    pub fn setFrameHorizColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMEHORIZCOLOR", .{index}, arg);
    }

    pub fn getValue(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "VALUE", .{});
    }

    pub fn setValue(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "VALUE", .{}, arg);
    }

    pub fn getNumEricFormatPrecision(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFORMATPRECISION", .{index});
    }

    pub fn setNumEricFormatPrecision(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICFORMATPRECISION", .{index}, arg);
    }

    pub fn getMergedend(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MERGEDEND", .{index});
    }

    pub fn getType(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "TYPE", .{index});
    }

    pub fn setType(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TYPE", .{index}, arg);
    }

    pub fn getSortImageDown(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTIMAGEDOWN", .{});
    }

    pub fn setSortImageDown(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTIMAGEDOWN", .{}, arg);
    }

    pub fn moveCol(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MOVECOL", .{index}, arg);
    }

    pub fn getTipFgColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "TIPFGCOLOR", .{});
    }

    pub fn setTipFgColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "TIPFGCOLOR", .{}, rgb);
    }

    pub fn getNumEricDecimalSymbol(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICDECIMALSYMBOL", .{});
    }

    pub fn setNumEricDecimalSymbol(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICDECIMALSYMBOL", .{}, arg);
    }

    pub fn getNumEricfoundQuantitY(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFOUNDQUANTITY", .{});
    }

    pub fn getExpand(self: *Self) ?Expand {
        var ret = interop.getStrAttribute(self, "EXPAND", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("HORIZONTAL", ret)) return .Horizontal;
        if (std.ascii.eqlIgnoreCase("VERTICAL", ret)) return .Vertical;
        if (std.ascii.eqlIgnoreCase("HORIZONTALFREE", ret)) return .HorizontalFree;
        if (std.ascii.eqlIgnoreCase("VERTICALFREE", ret)) return .VerticalFree;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }

    pub fn setExpand(self: *Self, arg: ?Expand) void {
        if (arg) |value| switch (value) {
            .Yes => interop.setStrAttribute(self, "EXPAND", .{}, "YES"),
            .Horizontal => interop.setStrAttribute(self, "EXPAND", .{}, "HORIZONTAL"),
            .Vertical => interop.setStrAttribute(self, "EXPAND", .{}, "VERTICAL"),
            .HorizontalFree => interop.setStrAttribute(self, "EXPAND", .{}, "HORIZONTALFREE"),
            .VerticalFree => interop.setStrAttribute(self, "EXPAND", .{}, "VERTICALFREE"),
            .No => interop.setStrAttribute(self, "EXPAND", .{}, "NO"),
        } else {
            interop.clearAttribute(self, "EXPAND", .{});
        }
    }

    pub fn getDrawTextOrientation(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "DRAWTEXTORIENTATION", .{});
    }

    pub fn setDrawTextOrientation(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "DRAWTEXTORIENTATION", .{}, arg);
    }

    pub fn getArea(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "AREA", .{});
    }

    pub fn setArea(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "AREA", .{}, arg);
    }

    pub fn getMerged(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MERGED", .{index});
    }

    pub fn setMerged(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MERGED", .{index}, arg);
    }

    pub fn getSortLineIndex(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTLINEINDEX", .{index});
    }

    pub fn getDrawTextAlignment(self: *Self) ?DrawTextAlignment {
        var ret = interop.getStrAttribute(self, "DRAWTEXTALIGNMENT", .{});

        if (std.ascii.eqlIgnoreCase("ACENTER", ret)) return .ACenter;
        if (std.ascii.eqlIgnoreCase("ARIGHT", ret)) return .ARight;
        if (std.ascii.eqlIgnoreCase("ALEFT", ret)) return .ALeft;
        return null;
    }

    pub fn setDrawTextAlignment(self: *Self, arg: ?DrawTextAlignment) void {
        if (arg) |value| switch (value) {
            .ACenter => interop.setStrAttribute(self, "DRAWTEXTALIGNMENT", .{}, "ACENTER"),
            .ARight => interop.setStrAttribute(self, "DRAWTEXTALIGNMENT", .{}, "ARIGHT"),
            .ALeft => interop.setStrAttribute(self, "DRAWTEXTALIGNMENT", .{}, "ALEFT"),
        } else {
            interop.clearAttribute(self, "DRAWTEXTALIGNMENT", .{});
        }
    }

    pub fn getDragSource(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAGSOURCE", .{});
    }

    pub fn setDragSource(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAGSOURCE", .{}, arg);
    }

    pub fn getDrawColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "DRAWCOLOR", .{});
    }

    pub fn setDrawColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "DRAWCOLOR", .{}, rgb);
    }

    pub fn getArrowImages(self: *Self) i32 {
        return interop.getIntAttribute(self, "ARROWIMAGES", .{});
    }

    pub fn setArrowImages(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "ARROWIMAGES", .{}, arg);
    }

    pub fn getHtmltd(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HTML<TD>", .{});
    }

    pub fn setHtmltd(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HTML<TD>", .{}, arg);
    }

    pub fn undoPushCell(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "UNDOPUSHCELL", .{index}, arg);
    }

    pub fn undoPushEnd(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "UNDOPUSHEND", .{}, arg);
    }

    pub fn getOrigInOffset(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "ORIGINOFFSET", .{});
    }

    pub fn setOrigInOffset(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ORIGINOFFSET", .{}, arg);
    }

    pub fn getDrawLineWidth(self: *Self) i32 {
        return interop.getIntAttribute(self, "DRAWLINEWIDTH", .{});
    }

    pub fn setDrawLineWidth(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "DRAWLINEWIDTH", .{}, arg);
    }

    pub fn getCellFont(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLFONT", .{index});
    }

    pub fn getNumColNoScroll(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMCOL_NOSCROLL", .{});
    }

    pub fn setNumColNoScroll(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMCOL_NOSCROLL", .{}, arg);
    }

    pub fn getFitMaxHeight(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FITMAXHEIGHT", .{index});
    }

    pub fn setFitMaxHeight(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FITMAXHEIGHT", .{index}, arg);
    }

    pub fn mergeSplit(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MERGESPLIT", .{}, arg);
    }

    pub fn getUserSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "USERSIZE", .{});
        return Size.parse(str);
    }

    pub fn setUserSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "USERSIZE", .{}, value);
    }

    pub fn getMarked(self: *Self) bool {
        return interop.getBoolAttribute(self, "MARKED", .{});
    }

    pub fn setMarked(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MARKED", .{}, arg);
    }

    pub fn getNumEricFormatDef(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFORMATDEF", .{});
    }

    pub fn setNumEricFormatDef(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICFORMATDEF", .{}, arg);
    }

    pub fn clearValue(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CLEARVALUE", .{index}, arg);
    }

    pub fn getXMin(self: *Self) i32 {
        return interop.getIntAttribute(self, "XMIN", .{});
    }

    pub fn setXMin(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "XMIN", .{}, arg);
    }

    pub fn getDrawTextEllipsis(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWTEXTELLIPSIS", .{});
    }

    pub fn setDrawTextEllipsis(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWTEXTELLIPSIS", .{}, arg);
    }

    pub fn delLin(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DELLIN", .{}, arg);
    }

    pub fn getMaskInt(self: *Self, index: i32) iup.Range {
        var str = interop.getStrAttribute(self, "MASKINT", .{index});
        return iup.Range.parse(str, ',');
    }

    pub fn setMaskInt(self: *Self, index: i32, begin: i32, end: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.Range.intIntToString(&buffer, begin, end, ',');
        interop.setStrAttribute(self, "MASKINT", .{index}, value);
    }

    pub fn getResizeDrag(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "RESIZEDRAG", .{});
    }

    pub fn setResizeDrag(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "RESIZEDRAG", .{}, arg);
    }

    pub fn clAsSupDate(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CLASSUPDATE", .{}, arg);
    }

    pub fn paste(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "PASTE", .{}, arg);
    }

    pub fn getNumEricUnitSpell(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNITSPELL", .{});
    }

    pub fn setNumEricUnitSpell(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITSPELL", .{}, arg);
    }

    pub fn getHtmlth(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HTML<TH>", .{});
    }

    pub fn setHtmlth(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HTML<TH>", .{}, arg);
    }

    pub fn showDialog(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SHOWDIALOG", .{}, arg);
    }

    pub fn getNumLinVisibleLast(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMLIN_VISIBLE_LAST", .{});
    }

    pub fn setNumLinVisibleLast(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMLIN_VISIBLE_LAST", .{}, arg);
    }

    pub fn sortColUmn(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTCOLUMN", .{index}, arg);
    }

    pub fn getFrameColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "FRAMECOLOR", .{});
    }

    pub fn setFrameColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "FRAMECOLOR", .{}, rgb);
    }

    pub fn getIdValue(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "IDVALUE", .{index});
    }

    pub fn setIdValue(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IDVALUE", .{index}, arg);
    }

    pub fn getLastError(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "LASTERROR", .{});
    }

    pub fn show(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SHOW", .{}, arg);
    }

    pub fn getSbImageBottomInactive(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGEBOTTOMINACTIVE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageBottomInactive(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGEBOTTOMINACTIVE", .{}, arg);
    }

    pub fn setSbImageBottomInactiveHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGEBOTTOMINACTIVE", .{}, arg);
    }

    pub fn getDrawSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "DRAWSIZE", .{});
        return Size.parse(str);
    }

    pub fn getMarkArea(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "MARKAREA", .{});
    }

    pub fn setMarkArea(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MARKAREA", .{}, arg);
    }

    pub fn getFrameTitleHighlight(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMETITLEHIGHLIGHT", .{});
    }

    pub fn setFrameTitleHighlight(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMETITLEHIGHLIGHT", .{}, arg);
    }

    pub fn getSbImageTopPress(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGETOPPRESS", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageTopPress(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGETOPPRESS", .{}, arg);
    }

    pub fn setSbImageTopPressHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGETOPPRESS", .{}, arg);
    }

    pub fn getBorder(self: *Self) bool {
        return interop.getBoolAttribute(self, "BORDER", .{});
    }

    pub fn setBorder(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "BORDER", .{}, arg);
    }

    pub fn getCanFocus(self: *Self) bool {
        return interop.getBoolAttribute(self, "CANFOCUS", .{});
    }

    pub fn setCanFocus(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "CANFOCUS", .{}, arg);
    }

    pub fn getSbImageTop(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGETOP", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageTop(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGETOP", .{}, arg);
    }

    pub fn setSbImageTopHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGETOP", .{}, arg);
    }

    pub fn getToggleImageOff(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TOGGLEIMAGEOFF", .{});
    }

    pub fn setToggleImageOff(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TOGGLEIMAGEOFF", .{}, arg);
    }

    pub fn getMerge(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MERGE", .{index});
    }

    pub fn setMerge(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MERGE", .{index}, arg);
    }

    pub fn getSortSign(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTSIGN", .{index});
    }

    pub fn setSortSign(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTSIGN", .{index}, arg);
    }

    pub fn getSbImageRightInactive(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGERIGHTINACTIVE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageRightInactive(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGERIGHTINACTIVE", .{}, arg);
    }

    pub fn setSbImageRightInactiveHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGERIGHTINACTIVE", .{}, arg);
    }

    pub fn getSortColUmnCaseSensitive(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTCOLUMNCASESENSITIVE", .{});
    }

    pub fn setSortColUmnCaseSensitive(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTCOLUMNCASESENSITIVE", .{}, arg);
    }

    pub fn getToggleImageOn(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TOGGLEIMAGEON", .{});
    }

    pub fn setToggleImageOn(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TOGGLEIMAGEON", .{}, arg);
    }

    pub fn getYAutoHide(self: *Self) bool {
        return interop.getBoolAttribute(self, "YAUTOHIDE", .{});
    }

    pub fn setYAutoHide(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "YAUTOHIDE", .{}, arg);
    }

    pub fn getDrawTextClip(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWTEXTCLIP", .{});
    }

    pub fn setDrawTextClip(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWTEXTCLIP", .{}, arg);
    }

    pub fn getTheme(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "THEME", .{});
    }

    pub fn setTheme(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "THEME", .{}, arg);
    }

    pub fn zOrder(self: *Self, arg: ?ZOrder) void {
        if (arg) |value| switch (value) {
            .Top => interop.setStrAttribute(self, "ZORDER", .{}, "TOP"),
            .Bottom => interop.setStrAttribute(self, "ZORDER", .{}, "BOTTOM"),
        } else {
            interop.clearAttribute(self, "ZORDER", .{});
        }
    }

    pub fn getSkipLines(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SKIPLINES", .{});
    }

    pub fn setSkipLines(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SKIPLINES", .{}, arg);
    }

    pub fn getRasterHeight(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "RASTERHEIGHT", .{index});
    }

    pub fn setRasterHeight(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "RASTERHEIGHT", .{index}, arg);
    }

    pub fn copyFile(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPYFILE", .{}, arg);
    }

    pub fn getFocusCell(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FOCUSCELL", .{});
    }

    pub fn setFocusCell(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FOCUSCELL", .{}, arg);
    }

    pub fn getLineAlignment(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "LINEALIGNMENT", .{index});
    }

    pub fn setLineAlignment(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "LINEALIGNMENT", .{index}, arg);
    }

    pub fn getVisibleLin(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "VISIBLELIN", .{index});
    }

    pub fn setVisibleLin(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "VISIBLELIN", .{index}, arg);
    }

    pub fn getWidthDef(self: *Self) i32 {
        return interop.getIntAttribute(self, "WIDTHDEF", .{});
    }

    pub fn setWidthDef(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "WIDTHDEF", .{}, arg);
    }

    pub fn getRasterWidth(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "RASTERWIDTH", .{index});
    }

    pub fn setRasterWidth(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "RASTERWIDTH", .{index}, arg);
    }

    pub fn getFInDDirection(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FINDDIRECTION", .{});
    }

    pub fn setFInDDirection(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FINDDIRECTION", .{}, arg);
    }

    pub fn getVisible(self: *Self) bool {
        return interop.getBoolAttribute(self, "VISIBLE", .{});
    }

    pub fn setVisible(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "VISIBLE", .{}, arg);
    }

    pub fn getNumLinNoScroll(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMLIN_NOSCROLL", .{});
    }

    pub fn setNumLinNoScroll(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMLIN_NOSCROLL", .{}, arg);
    }

    pub fn getUndoCount(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "UNDOCOUNT", .{});
    }

    pub fn getBgColor(self: *Self, index: i32) ?iup.Rgb {
        return interop.getRgb(self, "BGCOLOR", .{index});
    }

    pub fn setBgColor(self: *Self, index: i32, rgb: iup.Rgb) void {
        interop.setRgb(self, "BGCOLOR", .{index}, rgb);
    }

    pub fn addLin(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ADDLIN", .{}, arg);
    }

    pub fn getRasterSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "RASTERSIZE", .{});
        return Size.parse(str);
    }

    pub fn setRasterSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "RASTERSIZE", .{}, value);
    }

    pub fn getDrawStyle(self: *Self) ?DrawStyle {
        var ret = interop.getStrAttribute(self, "DRAWSTYLE", .{});

        if (std.ascii.eqlIgnoreCase("FILL", ret)) return .Fill;
        if (std.ascii.eqlIgnoreCase("STROKE_DASH", ret)) return .StrokeDash;
        if (std.ascii.eqlIgnoreCase("STROKE_DOT", ret)) return .StrokeDot;
        if (std.ascii.eqlIgnoreCase("STROKE_DASH_DOT", ret)) return .StrokeDashDot;
        if (std.ascii.eqlIgnoreCase("STROKE_DASH_DOT_DOT", ret)) return .StrokeDashDotdot;
        if (std.ascii.eqlIgnoreCase("DRAW_STROKE", ret)) return .DrawStroke;
        return null;
    }

    pub fn setDrawStyle(self: *Self, arg: ?DrawStyle) void {
        if (arg) |value| switch (value) {
            .Fill => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "FILL"),
            .StrokeDash => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "STROKE_DASH"),
            .StrokeDot => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "STROKE_DOT"),
            .StrokeDashDot => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "STROKE_DASH_DOT"),
            .StrokeDashDotdot => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "STROKE_DASH_DOT_DOT"),
            .DrawStroke => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "DRAW_STROKE"),
        } else {
            interop.clearAttribute(self, "DRAWSTYLE", .{});
        }
    }

    pub fn numEricAddQuantitY(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICADDQUANTITY", .{}, arg);
    }

    pub fn getShowFillValue(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SHOWFILLVALUE", .{});
    }

    pub fn setShowFillValue(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SHOWFILLVALUE", .{}, arg);
    }

    pub fn getDropTarget(self: *Self) bool {
        return interop.getBoolAttribute(self, "DROPTARGET", .{});
    }

    pub fn setDropTarget(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DROPTARGET", .{}, arg);
    }

    pub fn getMaskNoEmpty(self: *Self, index: i32) bool {
        return interop.getBoolAttribute(self, "MASKNOEMPTY", .{index});
    }

    pub fn setMaskNoEmpty(self: *Self, index: i32, arg: bool) void {
        interop.setBoolAttribute(self, "MASKNOEMPTY", .{index}, arg);
    }

    pub fn getHideFocus(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HIDEFOCUS", .{});
    }

    pub fn setHideFocus(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HIDEFOCUS", .{}, arg);
    }

    pub fn getCharSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "CHARSIZE", .{});
        return Size.parse(str);
    }

    pub fn getNumCol(self: *Self) i32 {
        return interop.getIntAttribute(self, "NUMCOL", .{});
    }

    pub fn setNumCol(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "NUMCOL", .{}, arg);
    }

    pub fn numEricAddUnitSymbol(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICADDUNITSYMBOL", .{}, arg);
    }

    pub fn moveLin(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MOVELIN", .{index}, arg);
    }

    pub fn getSortColUmNoRder(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTCOLUMNORDER", .{});
    }

    pub fn setSortColUmNoRder(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTCOLUMNORDER", .{}, arg);
    }

    pub fn getSbImageBottom(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGEBOTTOM", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageBottom(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGEBOTTOM", .{}, arg);
    }

    pub fn setSbImageBottomHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGEBOTTOM", .{}, arg);
    }

    pub fn getUndoRedo(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "UNDOREDO", .{});
    }

    pub fn setUndoRedo(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "UNDOREDO", .{}, arg);
    }

    pub fn getDrawMakeInactive(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWMAKEINACTIVE", .{});
    }

    pub fn setDrawMakeInactive(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWMAKEINACTIVE", .{}, arg);
    }

    pub fn numEricAddUnitFactor(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICADDUNITFACTOR", .{}, arg);
    }

    pub fn getDX(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "DX", .{});
    }

    pub fn setDX(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "DX", .{}, arg);
    }

    pub fn getDY(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "DY", .{});
    }

    pub fn setDY(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "DY", .{}, arg);
    }

    pub fn getCellFgColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLFGCOLOR", .{index});
    }

    pub fn getTypeColorInactive(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TYPECOLORINACTIVE", .{});
    }

    pub fn setTypeColorInactive(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TYPECOLORINACTIVE", .{}, arg);
    }

    pub fn getMultiline(self: *Self) bool {
        return interop.getBoolAttribute(self, "MULTILINE", .{});
    }

    pub fn setMultiline(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MULTILINE", .{}, arg);
    }

    pub fn getCellFrameVertColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLFRAMEVERTCOLOR", .{index});
    }

    pub fn setCellFrameVertColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CELLFRAMEVERTCOLOR", .{index}, arg);
    }

    pub fn getCaret(self: *Self) iup.LinColPos {
        var str = interop.getStrAttribute(self, "CARET", .{});
        return iup.LinColPos.parse(str, ',');
    }

    pub fn setCaret(self: *Self, lin: i32, col: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.LinColPos.intIntToString(&buffer, lin, col, ',');
        interop.setStrAttribute(self, "CARET", .{}, value);
    }

    pub fn getHtmltr(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HTML<TR>", .{});
    }

    pub fn setHtmltr(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HTML<TR>", .{}, arg);
    }

    pub fn getFreezeColor(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FREEZECOLOR", .{});
    }

    pub fn setFreezeColor(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FREEZECOLOR", .{}, arg);
    }

    pub fn getNumColVisibleLast(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMCOL_VISIBLE_LAST", .{});
    }

    pub fn setNumColVisibleLast(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMCOL_VISIBLE_LAST", .{}, arg);
    }

    pub fn getPosition(self: *Self) iup.XYPos {
        var str = interop.getStrAttribute(self, "POSITION", .{});
        return iup.XYPos.parse(str, ',');
    }

    pub fn setPosition(self: *Self, x: i32, y: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
        interop.setStrAttribute(self, "POSITION", .{}, value);
    }

    pub fn getMinSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "MINSIZE", .{});
        return Size.parse(str);
    }

    pub fn setMinSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "MINSIZE", .{}, value);
    }

    pub fn getMinColWidthDef(self: *Self) i32 {
        return interop.getIntAttribute(self, "MINCOLWIDTHDEF", .{});
    }

    pub fn setMinColWidthDef(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "MINCOLWIDTHDEF", .{}, arg);
    }

    pub fn getEditText(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITTEXT", .{});
    }

    pub fn getLastSortColUmn(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "LASTSORTCOLUMN", .{});
    }

    pub fn getResizeMatrixColor(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "RESIZEMATRIXCOLOR", .{});
    }

    pub fn setResizeMatrixColor(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "RESIZEMATRIXCOLOR", .{}, arg);
    }

    pub fn getLineX(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "LINEX", .{});
    }

    pub fn setLineX(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "LINEX", .{}, arg);
    }

    pub fn getNaturalSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "NATURALSIZE", .{});
        return Size.parse(str);
    }

    pub fn getLineY(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "LINEY", .{});
    }

    pub fn setLineY(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "LINEY", .{}, arg);
    }

    pub fn getNumEricUnitSymbol(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNITSYMBOL", .{index});
    }

    pub fn setNumEricUnitSymbol(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITSYMBOL", .{index}, arg);
    }

    pub fn numEricAddUnit(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICADDUNIT", .{}, arg);
    }

    pub fn getCopyData(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "COPYDATA", .{});
    }

    pub fn setCopyData(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPYDATA", .{}, arg);
    }

    pub fn getDropTypes(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "DROPTYPES", .{});
    }

    pub fn setDropTypes(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DROPTYPES", .{}, arg);
    }

    pub fn getHandleName(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HANDLENAME", .{});
    }

    pub fn setHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HANDLENAME", .{}, arg);
    }

    pub fn getFontFace(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FONTFACE", .{});
    }

    pub fn setFontFace(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FONTFACE", .{}, arg);
    }

    pub fn getSbImageTopInactive(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGETOPINACTIVE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageTopInactive(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGETOPINACTIVE", .{}, arg);
    }

    pub fn setSbImageTopInactiveHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGETOPINACTIVE", .{}, arg);
    }

    pub fn showMenuCOnText(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SHOWMENUCONTEXT", .{index}, arg);
    }

    pub fn getMark(self: *Self, index: i32) ?Mark {
        var ret = interop.getStrAttribute(self, "MARK", .{index});

        if (std.ascii.eqlIgnoreCase("BLOCK", ret)) return .BLock;
        if (std.ascii.eqlIgnoreCase("CLEARALL", ret)) return .ClearAll;
        if (std.ascii.eqlIgnoreCase("MARKALL", ret)) return .MarkAll;
        if (std.ascii.eqlIgnoreCase("INVERTALL", ret)) return .InVertAll;
        if (std.ascii.eqlIgnoreCase("INVERT", ret)) return .InVert;
        return null;
    }

    pub fn setMark(self: *Self, index: i32, arg: ?Mark) void {
        if (arg) |value| switch (value) {
            .BLock => interop.setStrAttribute(self, "MARK", .{index}, "BLOCK"),
            .ClearAll => interop.setStrAttribute(self, "MARK", .{index}, "CLEARALL"),
            .MarkAll => interop.setStrAttribute(self, "MARK", .{index}, "MARKALL"),
            .InVertAll => interop.setStrAttribute(self, "MARK", .{index}, "INVERTALL"),
            .InVert => interop.setStrAttribute(self, "MARK", .{index}, "INVERT"),
        } else {
            interop.clearAttribute(self, "MARK", .{index});
        }
    }

    pub fn getFInDmatchCase(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FINDMATCHCASE", .{});
    }

    pub fn setFInDmatchCase(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FINDMATCHCASE", .{}, arg);
    }

    pub fn getEditIng(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITING", .{});
    }

    pub fn getMask(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MASK", .{index});
    }

    pub fn setMask(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MASK", .{index}, arg);
    }

    pub fn pasteFile(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "PASTEFILE", .{}, arg);
    }

    pub fn getMaxSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "MAXSIZE", .{});
        return Size.parse(str);
    }

    pub fn setMaxSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "MAXSIZE", .{}, value);
    }

    pub fn getFlat(self: *Self) bool {
        return interop.getBoolAttribute(self, "FLAT", .{});
    }

    pub fn setFlat(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "FLAT", .{}, arg);
    }

    pub fn getNoScrollAsTitle(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NOSCROLLASTITLE", .{});
    }

    pub fn setNoScrollAsTitle(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NOSCROLLASTITLE", .{}, arg);
    }

    pub fn clearAttrib(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CLEARATTRIB", .{index}, arg);
    }

    pub fn getHeight(self: *Self, index: i32) i32 {
        return interop.getIntAttribute(self, "HEIGHT", .{index});
    }

    pub fn setHeight(self: *Self, index: i32, arg: i32) void {
        interop.setIntAttribute(self, "HEIGHT", .{index}, arg);
    }

    pub fn getFontStyle(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FONTSTYLE", .{index});
    }

    pub fn setFontStyle(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FONTSTYLE", .{index}, arg);
    }

    pub fn getFrameTitleVertColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMETITLEVERTCOLOR", .{index});
    }

    pub fn setFrameTitleVertColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMETITLEVERTCOLOR", .{index}, arg);
    }

    pub fn fitToSize(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FITTOSIZE", .{}, arg);
    }

    pub fn getFont(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FONT", .{index});
    }

    pub fn setFont(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FONT", .{index}, arg);
    }

    pub fn getMultiple(self: *Self) bool {
        return interop.getBoolAttribute(self, "MULTIPLE", .{});
    }

    pub fn setMultiple(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MULTIPLE", .{}, arg);
    }

    pub fn getSbImageRightPress(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGERIGHTPRESS", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageRightPress(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGERIGHTPRESS", .{}, arg);
    }

    pub fn setSbImageRightPressHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGERIGHTPRESS", .{}, arg);
    }

    pub fn getCursor(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "CURSOR", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setCursor(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "CURSOR", .{}, arg);
    }

    pub fn setCursorHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CURSOR", .{}, arg);
    }

    pub fn getNumEricfoundUnit(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFOUNDUNIT", .{});
    }

    pub fn getMinColWidth(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MINCOLWIDTH", .{index});
    }

    pub fn setMinColWidth(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MINCOLWIDTH", .{index}, arg);
    }

    pub fn getSortImageUp(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTIMAGEUP", .{});
    }

    pub fn setSortImageUp(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTIMAGEUP", .{}, arg);
    }

    pub fn getNumEricUnitShown(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNITSHOWN", .{index});
    }

    pub fn setNumEricUnitShown(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITSHOWN", .{index}, arg);
    }

    pub fn getWheelDropFocus(self: *Self) bool {
        return interop.getBoolAttribute(self, "WHEELDROPFOCUS", .{});
    }

    pub fn setWheelDropFocus(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "WHEELDROPFOCUS", .{}, arg);
    }

    pub fn getXHidden(self: *Self) bool {
        return interop.getBoolAttribute(self, "XHIDDEN", .{});
    }

    pub fn getFileFormat(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FILEFORMAT", .{});
    }

    pub fn setFileFormat(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FILEFORMAT", .{}, arg);
    }

    pub fn getNumEricQuantitY(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICQUANTITY", .{index});
    }

    pub fn setNumEricQuantitY(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICQUANTITY", .{index}, arg);
    }

    pub fn getFontSize(self: *Self, index: i32) i32 {
        return interop.getIntAttribute(self, "FONTSIZE", .{index});
    }

    pub fn setFontSize(self: *Self, index: i32, arg: i32) void {
        interop.setIntAttribute(self, "FONTSIZE", .{index}, arg);
    }

    pub fn undoPushBegin(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "UNDOPUSHBEGIN", .{}, arg);
    }

    pub fn copyCol(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPYCOL", .{index}, arg);
    }

    pub fn pasteData(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "PASTEDATA", .{}, arg);
    }

    pub fn getTipMarkup(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TIPMARKUP", .{});
    }

    pub fn setTipMarkup(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TIPMARKUP", .{}, arg);
    }

    pub fn getSbImageLeftHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGELEFTHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageLeftHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGELEFTHIGHLIGHT", .{}, arg);
    }

    pub fn setSbImageLeftHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGELEFTHIGHLIGHT", .{}, arg);
    }

    pub fn getCellFrameHorizColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLFRAMEHORIZCOLOR", .{index});
    }

    pub fn setCellFrameHorizColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CELLFRAMEHORIZCOLOR", .{index}, arg);
    }

    pub fn getRedo(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "REDO", .{});
    }

    pub fn setRedo(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "REDO", .{}, arg);
    }

    pub fn getYMax(self: *Self) i32 {
        return interop.getIntAttribute(self, "YMAX", .{});
    }

    pub fn setYMax(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "YMAX", .{}, arg);
    }

    pub fn getMergedStart(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MERGEDSTART", .{index});
    }

    pub fn getSbImageLeft(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGELEFT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageLeft(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGELEFT", .{}, arg);
    }

    pub fn setSbImageLeftHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGELEFT", .{}, arg);
    }

    pub fn getNTheme(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NTHEME", .{});
    }

    pub fn setNTheme(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NTHEME", .{}, arg);
    }

    pub fn getFitMaxWidth(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FITMAXWIDTH", .{index});
    }

    pub fn setFitMaxWidth(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FITMAXWIDTH", .{index}, arg);
    }

    pub fn undoClear(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "UNDOCLEAR", .{}, arg);
    }

    pub fn getSkipColumns(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SKIPCOLUMNS", .{});
    }

    pub fn setSkipColumns(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SKIPCOLUMNS", .{}, arg);
    }

    pub fn getDragSourceMove(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAGSOURCEMOVE", .{});
    }

    pub fn setDragSourceMove(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAGSOURCEMOVE", .{}, arg);
    }

    pub fn getNumLin(self: *Self) i32 {
        return interop.getIntAttribute(self, "NUMLIN", .{});
    }

    pub fn setNumLin(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "NUMLIN", .{}, arg);
    }

    pub fn getCell(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELL", .{index});
    }

    pub fn getNumEricUnit(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNIT", .{index});
    }

    pub fn setNumEricUnit(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNIT", .{index}, arg);
    }

    pub fn getResizeMatrix(self: *Self) bool {
        return interop.getBoolAttribute(self, "RESIZEMATRIX", .{});
    }

    pub fn setResizeMatrix(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "RESIZEMATRIX", .{}, arg);
    }

    pub fn getActive(self: *Self) bool {
        return interop.getBoolAttribute(self, "ACTIVE", .{});
    }

    pub fn setActive(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "ACTIVE", .{}, arg);
    }

    pub fn getSbImageTopHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGETOPHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageTopHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGETOPHIGHLIGHT", .{}, arg);
    }

    pub fn setSbImageTopHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGETOPHIGHLIGHT", .{}, arg);
    }

    pub fn getCellsIZe(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLSIZE", .{index});
    }

    pub fn getFgColor(self: *Self, index: i32) ?iup.Rgb {
        return interop.getRgb(self, "FGCOLOR", .{index});
    }

    pub fn setFgColor(self: *Self, index: i32, rgb: iup.Rgb) void {
        interop.setRgb(self, "FGCOLOR", .{index}, rgb);
    }

    pub fn getHlColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "HLCOLOR", .{});
    }

    pub fn setHlColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "HLCOLOR", .{}, rgb);
    }

    pub fn getTipIcon(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TIPICON", .{});
    }

    pub fn setTipIcon(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TIPICON", .{}, arg);
    }

    pub fn getMaskCasei(self: *Self, index: i32) bool {
        return interop.getBoolAttribute(self, "MASKCASEI", .{index});
    }

    pub fn setMaskCasei(self: *Self, index: i32, arg: bool) void {
        interop.setBoolAttribute(self, "MASKCASEI", .{index}, arg);
    }

    pub fn getWId(self: *Self) i32 {
        return interop.getIntAttribute(self, "WID", .{});
    }

    pub fn getCellType(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLTYPE", .{index});
    }

    pub fn fitToText(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FITTOTEXT", .{}, arg);
    }

    pub fn getLimitExpand(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "LIMITEXPAND", .{});
    }

    pub fn setLimitExpand(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "LIMITEXPAND", .{}, arg);
    }

    pub fn numEricUnitSearch(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITSEARCH", .{}, arg);
    }

    pub fn getPosX(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "POSX", .{});
    }

    pub fn setPosX(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "POSX", .{}, arg);
    }

    pub fn getPosY(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "POSY", .{});
    }

    pub fn setPosY(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "POSY", .{}, arg);
    }

    pub fn getNumEricQuantitYIndex(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICQUANTITYINDEX", .{index});
    }

    pub fn setNumEricQuantitYIndex(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICQUANTITYINDEX", .{index}, arg);
    }

    pub fn getUndoName(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "UNDONAME", .{index});
    }

    pub fn getMenuCOnText(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "MENUCONTEXT", .{});
    }

    pub fn setMenuCOnText(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MENUCONTEXT", .{}, arg);
    }

    pub fn getXAutoHide(self: *Self) bool {
        return interop.getBoolAttribute(self, "XAUTOHIDE", .{});
    }

    pub fn setXAutoHide(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "XAUTOHIDE", .{}, arg);
    }

    pub fn getTipVisible(self: *Self) bool {
        return interop.getBoolAttribute(self, "TIPVISIBLE", .{});
    }

    pub fn setTipVisible(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "TIPVISIBLE", .{}, arg);
    }

    pub fn getMarkMode(self: *Self) ?MarkMode {
        var ret = interop.getStrAttribute(self, "MARKMODE", .{});

        if (std.ascii.eqlIgnoreCase("SINGLE", ret)) return .SInGle;
        if (std.ascii.eqlIgnoreCase("MULTIPLE", ret)) return .Multiple;
        return null;
    }

    pub fn setMarkMode(self: *Self, arg: ?MarkMode) void {
        if (arg) |value| switch (value) {
            .SInGle => interop.setStrAttribute(self, "MARKMODE", .{}, "SINGLE"),
            .Multiple => interop.setStrAttribute(self, "MARKMODE", .{}, "MULTIPLE"),
        } else {
            interop.clearAttribute(self, "MARKMODE", .{});
        }
    }

    pub fn getDrawFont(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "DRAWFONT", .{});
    }

    pub fn setDrawFont(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DRAWFONT", .{}, arg);
    }

    pub fn getHeightDef(self: *Self) i32 {
        return interop.getIntAttribute(self, "HEIGHTDEF", .{});
    }

    pub fn setHeightDef(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "HEIGHTDEF", .{}, arg);
    }

    pub fn getExpandWeight(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "EXPANDWEIGHT", .{});
    }

    pub fn setExpandWeight(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "EXPANDWEIGHT", .{}, arg);
    }

    pub fn getCopyKeepstruct(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "COPYKEEPSTRUCT", .{});
    }

    pub fn setCopyKeepstruct(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPYKEEPSTRUCT", .{}, arg);
    }

    pub fn getTextSeparator(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TEXTSEPARATOR", .{});
    }

    pub fn setTextSeparator(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TEXTSEPARATOR", .{}, arg);
    }

    pub fn getTipBgColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "TIPBGCOLOR", .{});
    }

    pub fn setTipBgColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "TIPBGCOLOR", .{}, rgb);
    }

    pub fn getOrigIn(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "ORIGIN", .{});
    }

    pub fn setOrigIn(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ORIGIN", .{}, arg);
    }

    pub fn copy(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPY", .{}, arg);
    }

    pub fn getLateXLabel(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "LATEXLABEL", .{});
    }

    pub fn setLateXLabel(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "LATEXLABEL", .{}, arg);
    }

    pub fn getDrawBgColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "DRAWBGCOLOR", .{});
    }

    pub fn setDrawBgColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "DRAWBGCOLOR", .{}, rgb);
    }

    pub fn getTextSkipLines(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TEXTSKIPLINES", .{});
    }

    pub fn setTextSkipLines(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TEXTSKIPLINES", .{}, arg);
    }

    pub fn getEditMode(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITMODE", .{});
    }

    pub fn setEditMode(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "EDITMODE", .{}, arg);
    }

    pub fn getEditNext(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITNEXT", .{});
    }

    pub fn setEditNext(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "EDITNEXT", .{}, arg);
    }

    pub fn getYMin(self: *Self) i32 {
        return interop.getIntAttribute(self, "YMIN", .{});
    }

    pub fn setYMin(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "YMIN", .{}, arg);
    }

    pub fn getToggleCenterEd(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TOGGLECENTERED", .{});
    }

    pub fn setToggleCenterEd(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TOGGLECENTERED", .{}, arg);
    }

    pub fn getNormalizerGroup(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NORMALIZERGROUP", .{});
    }

    pub fn setNormalizerGroup(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NORMALIZERGROUP", .{}, arg);
    }

    pub fn getScrollBar(self: *Self) bool {
        return interop.getBoolAttribute(self, "SCROLLBAR", .{});
    }

    pub fn setScrollBar(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "SCROLLBAR", .{}, arg);
    }

    pub fn getBusY(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "BUSY", .{});
    }

    pub fn setBusY(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "BUSY", .{}, arg);
    }

    pub fn getUseTitleSize(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "USETITLESIZE", .{});
    }

    pub fn setUseTitleSize(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "USETITLESIZE", .{}, arg);
    }

    pub fn getDropFilesTarget(self: *Self) bool {
        return interop.getBoolAttribute(self, "DROPFILESTARGET", .{});
    }

    pub fn setDropFilesTarget(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DROPFILESTARGET", .{}, arg);
    }

    pub fn getNumEricUnitCount(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNITCOUNT", .{index});
    }

    pub fn getAlignmentLin0(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "ALIGNMENTLIN0", .{});
    }

    pub fn setAlignmentLin0(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ALIGNMENTLIN0", .{}, arg);
    }

    pub fn getFrameBorder(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMEBORDER", .{});
    }

    pub fn setFrameBorder(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMEBORDER", .{}, arg);
    }

    pub fn getNumEricUnitShowNIndex(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNITSHOWNINDEX", .{index});
    }

    pub fn setNumEricUnitShowNIndex(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITSHOWNINDEX", .{index}, arg);
    }

    pub fn getFrameTitleHorizColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMETITLEHORIZCOLOR", .{index});
    }

    pub fn setFrameTitleHorizColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMETITLEHORIZCOLOR", .{index}, arg);
    }

    pub fn getMarkAtTitle(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "MARKATTITLE", .{});
    }

    pub fn setMarkAtTitle(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MARKATTITLE", .{}, arg);
    }

    pub fn getCopyColTo(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "COPYCOLTO", .{index});
    }

    pub fn setCopyColTo(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPYCOLTO", .{index}, arg);
    }

    pub fn getEditHideOnFocus(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITHIDEONFOCUS", .{});
    }

    pub fn setEditHideOnFocus(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "EDITHIDEONFOCUS", .{}, arg);
    }

    pub fn getSbImageRightHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGERIGHTHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageRightHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGERIGHTHIGHLIGHT", .{}, arg);
    }

    pub fn setSbImageRightHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGERIGHTHIGHLIGHT", .{}, arg);
    }

    pub fn getUndo(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "UNDO", .{});
    }

    pub fn setUndo(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "UNDO", .{}, arg);
    }

    pub fn getEditCell(self: *Self) ?iup.LinColPos {
        if (interop.getNullableStrAttribute(self, "EDITCELL", .{})) |str| {
            return iup.LinColPos.parse(str, ':');
        } else {
            return null;
        }
    }

    pub fn getNumEricUnitIndex(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNITINDEX", .{index});
    }

    pub fn setNumEricUnitIndex(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITINDEX", .{index}, arg);
    }

    pub fn getHtmlCaption(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HTML<CAPTION>", .{});
    }

    pub fn setHtmlCaption(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HTML<CAPTION>", .{}, arg);
    }

    pub fn getSbImageLeftPress(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGELEFTPRESS", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageLeftPress(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGELEFTPRESS", .{}, arg);
    }

    pub fn setSbImageLeftPressHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGELEFTPRESS", .{}, arg);
    }

    pub fn getCopyCaption(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "COPYCAPTION", .{});
    }

    pub fn setCopyCaption(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPYCAPTION", .{}, arg);
    }

    pub fn getHlColorAlpha(self: *Self) i32 {
        return interop.getIntAttribute(self, "HLCOLORALPHA", .{});
    }

    pub fn setHlColorAlpha(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "HLCOLORALPHA", .{}, arg);
    }

    pub fn getHtmlTable(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HTML<TABLE>", .{});
    }

    pub fn setHtmlTable(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HTML<TABLE>", .{}, arg);
    }

    pub fn getSbImageBottomHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGEBOTTOMHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageBottomHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGEBOTTOMHIGHLIGHT", .{}, arg);
    }

    pub fn setSbImageBottomHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGEBOTTOMHIGHLIGHT", .{}, arg);
    }

    pub fn getNumEricUnitSymbolShown(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNITSYMBOLSHOWN", .{index});
    }

    pub fn setNumEricUnitSymbolShown(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITSYMBOLSHOWN", .{index}, arg);
    }

    pub fn getDrawTextWrap(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWTEXTWRAP", .{});
    }

    pub fn setDrawTextWrap(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWTEXTWRAP", .{}, arg);
    }

    pub fn getCellAlignment(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLALIGNMENT", .{index});
    }

    pub fn delCol(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DELCOL", .{}, arg);
    }

    pub fn getCount(self: *Self) i32 {
        return interop.getIntAttribute(self, "COUNT", .{});
    }

    pub fn getTip(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TIP", .{});
    }

    pub fn setTip(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TIP", .{}, arg);
    }

    pub fn getDragDrop(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAGDROP", .{});
    }

    pub fn setDragDrop(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAGDROP", .{}, arg);
    }

    pub fn getTipDelay(self: *Self) i32 {
        return interop.getIntAttribute(self, "TIPDELAY", .{});
    }

    pub fn setTipDelay(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "TIPDELAY", .{}, arg);
    }

    pub fn getToggleValue(self: *Self, index: i32) ?ToggleValue {
        var ret = interop.getStrAttribute(self, "TOGGLEVALUE", .{index});

        if (std.ascii.eqlIgnoreCase("ON", ret)) return .On;
        if (std.ascii.eqlIgnoreCase("OFF", ret)) return .Off;
        if (std.ascii.eqlIgnoreCase("NOTDEF", ret)) return .NotDef;
        return null;
    }

    pub fn setToggleValue(self: *Self, index: i32, arg: ?ToggleValue) void {
        if (arg) |value| switch (value) {
            .On => interop.setStrAttribute(self, "TOGGLEVALUE", .{index}, "ON"),
            .Off => interop.setStrAttribute(self, "TOGGLEVALUE", .{index}, "OFF"),
            .NotDef => interop.setStrAttribute(self, "TOGGLEVALUE", .{index}, "NOTDEF"),
        } else {
            interop.clearAttribute(self, "TOGGLEVALUE", .{index});
        }
    }

    pub fn copyLin(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPYLIN", .{index}, arg);
    }

    pub fn getNumColVisible(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMCOL_VISIBLE", .{});
    }

    pub fn setNumColVisible(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMCOL_VISIBLE", .{}, arg);
    }

    pub fn getSbImageRight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGERIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageRight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGERIGHT", .{}, arg);
    }

    pub fn setSbImageRightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGERIGHT", .{}, arg);
    }

    pub fn getYHidden(self: *Self) bool {
        return interop.getBoolAttribute(self, "YHIDDEN", .{});
    }

    pub fn getFInd(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FIND", .{});
    }

    pub fn setFInd(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FIND", .{}, arg);
    }

    pub fn getCellBgColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLBGCOLOR", .{index});
    }

    pub fn getNumEricFormatTitle(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFORMATTITLE", .{index});
    }

    pub fn setNumEricFormatTitle(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICFORMATTITLE", .{index}, arg);
    }

    pub fn getSbImageLeftInactive(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGELEFTINACTIVE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageLeftInactive(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGELEFTINACTIVE", .{}, arg);
    }

    pub fn setSbImageLeftInactiveHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGELEFTINACTIVE", .{}, arg);
    }

    pub fn getMarkMultiple(self: *Self) bool {
        return interop.getBoolAttribute(self, "MARKMULTIPLE", .{});
    }

    pub fn setMarkMultiple(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MARKMULTIPLE", .{}, arg);
    }

    pub fn getFloating(self: *Self) ?Floating {
        var ret = interop.getStrAttribute(self, "FLOATING", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("IGNORE", ret)) return .Ignore;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }

    pub fn setFloating(self: *Self, arg: ?Floating) void {
        if (arg) |value| switch (value) {
            .Yes => interop.setStrAttribute(self, "FLOATING", .{}, "YES"),
            .Ignore => interop.setStrAttribute(self, "FLOATING", .{}, "IGNORE"),
            .No => interop.setStrAttribute(self, "FLOATING", .{}, "NO"),
        } else {
            interop.clearAttribute(self, "FLOATING", .{});
        }
    }

    pub fn getNumEricFormat(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFORMAT", .{index});
    }

    pub fn setNumEricFormat(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICFORMAT", .{index}, arg);
    }

    pub fn getCellOffset(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLOFFSET", .{index});
    }

    pub fn getWidth(self: *Self, index: i32) i32 {
        return interop.getIntAttribute(self, "WIDTH", .{index});
    }

    pub fn setWidth(self: *Self, index: i32, arg: i32) void {
        interop.setIntAttribute(self, "WIDTH", .{index}, arg);
    }

    pub fn getTouch(self: *Self) bool {
        return interop.getBoolAttribute(self, "TOUCH", .{});
    }

    pub fn setTouch(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "TOUCH", .{}, arg);
    }

    pub fn getBusYProgress(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "BUSYPROGRESS", .{});
    }

    pub fn setBusYProgress(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "BUSYPROGRESS", .{}, arg);
    }

    pub fn getName(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NAME", .{});
    }

    pub fn setName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NAME", .{}, arg);
    }

    pub fn getEditValue(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITVALUE", .{});
    }

    pub fn getReadonly(self: *Self) bool {
        return interop.getBoolAttribute(self, "READONLY", .{});
    }

    pub fn setReadonly(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "READONLY", .{}, arg);
    }

    pub fn getFInDmatchWholeCell(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FINDMATCHWHOLECELL", .{});
    }

    pub fn setFInDmatchWholeCell(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FINDMATCHWHOLECELL", .{}, arg);
    }

    pub fn getNumLinVisible(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMLIN_VISIBLE", .{});
    }

    pub fn setNumLinVisible(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMLIN_VISIBLE", .{}, arg);
    }

    pub fn getPropagateFocus(self: *Self) bool {
        return interop.getBoolAttribute(self, "PROPAGATEFOCUS", .{});
    }

    pub fn setPropagateFocus(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "PROPAGATEFOCUS", .{}, arg);
    }

    pub fn getBackingStore(self: *Self) bool {
        return interop.getBoolAttribute(self, "BACKINGSTORE", .{});
    }

    pub fn setBackingStore(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "BACKINGSTORE", .{}, arg);
    }

    pub fn getDrawDriver(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "DRAWDRIVER", .{});
    }

    pub fn getSbImageBottomPress(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGEBOTTOMPRESS", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageBottomPress(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGEBOTTOMPRESS", .{}, arg);
    }

    pub fn setSbImageBottomPressHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGEBOTTOMPRESS", .{}, arg);
    }

    pub fn getMdiClient(self: *Self) bool {
        return interop.getBoolAttribute(self, "MDICLIENT", .{});
    }

    pub fn setMdiClient(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MDICLIENT", .{}, arg);
    }

    pub fn getMdiMenu(self: *Self) ?*iup.Menu {
        if (interop.getHandleAttribute(self, "MDIMENU", .{})) |handle| {
            return @ptrCast(*iup.Menu, handle);
        } else {
            return null;
        }
    }

    pub fn setMdiMenu(self: *Self, arg: *iup.Menu) void {
        interop.setHandleAttribute(self, "MDIMENU", .{}, arg);
    }

    pub fn setMdiMenuHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MDIMENU", .{}, arg);
    }


    /// 
    /// TABIMAGEn (non inheritable): image name to be used in the respective tab.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// n starts at 0.
    /// See also IupImage.
    /// In Motif, the image is shown only if TABTITLEn is NULL.
    /// In Windows and Motif set the BGCOLOR attribute before setting the image.
    /// When set after map will update the TABIMAGE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABIMAGE (non inheritable) (at children only): Same as TABIMAGEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn getTabImage(self: *Self, index: i32) ?iup.Element {
        if (interop.getHandleAttribute(self, "TABIMAGE", .{index})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }


    /// 
    /// TABIMAGEn (non inheritable): image name to be used in the respective tab.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// n starts at 0.
    /// See also IupImage.
    /// In Motif, the image is shown only if TABTITLEn is NULL.
    /// In Windows and Motif set the BGCOLOR attribute before setting the image.
    /// When set after map will update the TABIMAGE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABIMAGE (non inheritable) (at children only): Same as TABIMAGEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn setTabImage(self: *Self, index: i32, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "TABIMAGE", .{index}, arg);
    }

    pub fn setTabImageHandleName(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TABIMAGE", .{index}, arg);
    }


    /// 
    /// TABTITLEn (non inheritable): Contains the text to be shown in the
    /// respective tab title.
    /// n starts at 0.
    /// If this value is NULL, it will remain empty.
    /// The "&" character can be used to define a mnemonic, the next character will
    /// be used as key.
    /// Use "&&" to show the "&" character instead on defining a mnemonic.
    /// The button can be activated from any control in the dialog using the
    /// "Alt+key" combination.
    /// (mnemonic support since 3.3).
    /// When set after map will update the TABTITLE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABTITLE (non inheritable) (at children only): Same as TABTITLEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn getTabTitle(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "TABTITLE", .{index});
    }


    /// 
    /// TABTITLEn (non inheritable): Contains the text to be shown in the
    /// respective tab title.
    /// n starts at 0.
    /// If this value is NULL, it will remain empty.
    /// The "&" character can be used to define a mnemonic, the next character will
    /// be used as key.
    /// Use "&&" to show the "&" character instead on defining a mnemonic.
    /// The button can be activated from any control in the dialog using the
    /// "Alt+key" combination.
    /// (mnemonic support since 3.3).
    /// When set after map will update the TABTITLE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABTITLE (non inheritable) (at children only): Same as TABTITLEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn setTabTitle(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TABTITLE", .{index}, arg);
    }

    pub fn setColResizeCallback(self: *Self, callback: ?OnColResizeFn) void {
        const Handler = CallbackHandler(Self, OnColResizeFn, "COLRESIZE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setWheelCallback(self: *Self, callback: ?OnWheelFn) void {
        const Handler = CallbackHandler(Self, OnWheelFn, "WHEEL_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEditMouseMoveCallback(self: *Self, callback: ?OnEditMouseMoveFn) void {
        const Handler = CallbackHandler(Self, OnEditMouseMoveFn, "EDITMOUSEMOVE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropCheckCallback(self: *Self, callback: ?OnDropCheckFn) void {
        const Handler = CallbackHandler(Self, OnDropCheckFn, "DROPCHECK_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDestroyCallback(self: *Self, callback: ?OnDestroyFn) void {
        const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setNumEricSetValueCallback(self: *Self, callback: ?OnNumEricSetValueFn) void {
        const Handler = CallbackHandler(Self, OnNumEricSetValueFn, "NUMERICSETVALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setKillFocusCallback(self: *Self, callback: ?OnKillFocusFn) void {
        const Handler = CallbackHandler(Self, OnKillFocusFn, "KILLFOCUS_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMotionCallback(self: *Self, callback: ?OnMotionFn) void {
        const Handler = CallbackHandler(Self, OnMotionFn, "MOTION_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragEndCallback(self: *Self, callback: ?OnDragEndFn) void {
        const Handler = CallbackHandler(Self, OnDragEndFn, "DRAGEND_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setSortColUmncompareCallback(self: *Self, callback: ?OnSortColUmncompareFn) void {
        const Handler = CallbackHandler(Self, OnSortColUmncompareFn, "SORTCOLUMNCOMPARE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setPostMessageCallback(self: *Self, callback: ?OnPostMessageFn) void {
        const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setTranslateValueCallback(self: *Self, callback: ?OnTranslateValueFn) void {
        const Handler = CallbackHandler(Self, OnTranslateValueFn, "TRANSLATEVALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setScrollCallback(self: *Self, callback: ?OnScrollFn) void {
        const Handler = CallbackHandler(Self, OnScrollFn, "SCROLL_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMouseMoveCallback(self: *Self, callback: ?OnMouseMoveFn) void {
        const Handler = CallbackHandler(Self, OnMouseMoveFn, "MOUSEMOVE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setActionCallback(self: *Self, callback: ?OnActionFn) void {
        const Handler = CallbackHandler(Self, OnActionFn, "ACTION_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setWomCallback(self: *Self, callback: ?OnWomFn) void {
        const Handler = CallbackHandler(Self, OnWomFn, "WOM_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropDataCallback(self: *Self, callback: ?OnDropDataFn) void {
        const Handler = CallbackHandler(Self, OnDropDataFn, "DROPDATA_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setKAnyCallback(self: *Self, callback: ?OnKAnyFn) void {
        const Handler = CallbackHandler(Self, OnKAnyFn, "K_ANY");
        Handler.setCallback(self, callback);
    }

    pub fn setScrollTopCallback(self: *Self, callback: ?OnScrollTopFn) void {
        const Handler = CallbackHandler(Self, OnScrollTopFn, "SCROLLTOP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropCallback(self: *Self, callback: ?OnDropFn) void {
        const Handler = CallbackHandler(Self, OnDropFn, "DROP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMarkCallback(self: *Self, callback: ?OnMarkFn) void {
        const Handler = CallbackHandler(Self, OnMarkFn, "MARK_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEnterItemCallback(self: *Self, callback: ?OnEnterItemFn) void {
        const Handler = CallbackHandler(Self, OnEnterItemFn, "ENTERITEM_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setUnmapCallback(self: *Self, callback: ?OnUnmapFn) void {
        const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEnterWindowCallback(self: *Self, callback: ?OnEnterWindowFn) void {
        const Handler = CallbackHandler(Self, OnEnterWindowFn, "ENTERWINDOW_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setLeaveWindowCallback(self: *Self, callback: ?OnLeaveWindowFn) void {
        const Handler = CallbackHandler(Self, OnLeaveWindowFn, "LEAVEWINDOW_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setClickCallback(self: *Self, callback: ?OnClickFn) void {
        const Handler = CallbackHandler(Self, OnClickFn, "CLICK_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMarkedItCallback(self: *Self, callback: ?OnMarkedItFn) void {
        const Handler = CallbackHandler(Self, OnMarkedItFn, "MARKEDIT_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragBeginCallback(self: *Self, callback: ?OnDragBeginFn) void {
        const Handler = CallbackHandler(Self, OnDragBeginFn, "DRAGBEGIN_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setTypeCallback(self: *Self, callback: ?OnTypeFn) void {
        const Handler = CallbackHandler(Self, OnTypeFn, "TYPE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragDataSizeCallback(self: *Self, callback: ?OnDragDataSizeFn) void {
        const Handler = CallbackHandler(Self, OnDragDataSizeFn, "DRAGDATASIZE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEditReleaseCallback(self: *Self, callback: ?OnEditReleaseFn) void {
        const Handler = CallbackHandler(Self, OnEditReleaseFn, "EDITRELEASE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setLDestroyCallback(self: *Self, callback: ?OnLDestroyFn) void {
        const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setCanvasActionCallback(self: *Self, callback: ?OnCanvasActionFn) void {
        const Handler = CallbackHandler(Self, OnCanvasActionFn, "ACTION");
        Handler.setCallback(self, callback);
    }

    pub fn setEditClickCallback(self: *Self, callback: ?OnEditClickFn) void {
        const Handler = CallbackHandler(Self, OnEditClickFn, "EDITCLICK_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setPasteSizeCallback(self: *Self, callback: ?OnPasteSizeFn) void {
        const Handler = CallbackHandler(Self, OnPasteSizeFn, "PASTESIZE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setValueEditCallback(self: *Self, callback: ?OnValueEditFn) void {
        const Handler = CallbackHandler(Self, OnValueEditFn, "VALUE_EDIT_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setFontCallback(self: *Self, callback: ?OnFontFn) void {
        const Handler = CallbackHandler(Self, OnFontFn, "FONT_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropMotionCallback(self: *Self, callback: ?OnDropMotionFn) void {
        const Handler = CallbackHandler(Self, OnDropMotionFn, "DROPMOTION_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setKeyPressCallback(self: *Self, callback: ?OnKeyPressFn) void {
        const Handler = CallbackHandler(Self, OnKeyPressFn, "KEYPRESS_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setBusYCallback(self: *Self, callback: ?OnBusYFn) void {
        const Handler = CallbackHandler(Self, OnBusYFn, "BUSY_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setToggleValueCallback(self: *Self, callback: ?OnToggleValueFn) void {
        const Handler = CallbackHandler(Self, OnToggleValueFn, "TOGGLEVALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setResizeCallback(self: *Self, callback: ?OnResizeFn) void {
        const Handler = CallbackHandler(Self, OnResizeFn, "RESIZE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setGetFocusCallback(self: *Self, callback: ?OnGetFocusFn) void {
        const Handler = CallbackHandler(Self, OnGetFocusFn, "GETFOCUS_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setHelpCallback(self: *Self, callback: ?OnHelpFn) void {
        const Handler = CallbackHandler(Self, OnHelpFn, "HELP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setFocusCallback(self: *Self, callback: ?OnFocusFn) void {
        const Handler = CallbackHandler(Self, OnFocusFn, "FOCUS_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropSelectCallback(self: *Self, callback: ?OnDropSelectFn) void {
        const Handler = CallbackHandler(Self, OnDropSelectFn, "DROPSELECT_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropFilesCallback(self: *Self, callback: ?OnDropFilesFn) void {
        const Handler = CallbackHandler(Self, OnDropFilesFn, "DROPFILES_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEditIOnCallback(self: *Self, callback: ?OnEditIOnFn) void {
        const Handler = CallbackHandler(Self, OnEditIOnFn, "EDITION_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMenuDropCallback(self: *Self, callback: ?OnMenuDropFn) void {
        const Handler = CallbackHandler(Self, OnMenuDropFn, "MENUDROP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDrawCallback(self: *Self, callback: ?OnDrawFn) void {
        const Handler = CallbackHandler(Self, OnDrawFn, "DRAW_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMenuCOnTextCloseCallback(self: *Self, callback: ?OnMenuCOnTextCloseFn) void {
        const Handler = CallbackHandler(Self, OnMenuCOnTextCloseFn, "MENUCONTEXTCLOSE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setValueCallback(self: *Self, callback: ?OnValueFn) void {
        const Handler = CallbackHandler(Self, OnValueFn, "VALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setValueChangedCallback(self: *Self, callback: ?OnValueChangedFn) void {
        const Handler = CallbackHandler(Self, OnValueChangedFn, "VALUECHANGED_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setReleaseCallback(self: *Self, callback: ?OnReleaseFn) void {
        const Handler = CallbackHandler(Self, OnReleaseFn, "RELEASE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragDataCallback(self: *Self, callback: ?OnDragDataFn) void {
        const Handler = CallbackHandler(Self, OnDragDataFn, "DRAGDATA_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setButtonCallback(self: *Self, callback: ?OnButtonFn) void {
        const Handler = CallbackHandler(Self, OnButtonFn, "BUTTON_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMapCallback(self: *Self, callback: ?OnMapFn) void {
        const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setFgColorCallback(self: *Self, callback: ?OnFgColorFn) void {
        const Handler = CallbackHandler(Self, OnFgColorFn, "FGCOLOR_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setNumEricGetValueCallback(self: *Self, callback: ?OnNumEricGetValueFn) void {
        const Handler = CallbackHandler(Self, OnNumEricGetValueFn, "NUMERICGETVALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setBgColorCallback(self: *Self, callback: ?OnBgColorFn) void {
        const Handler = CallbackHandler(Self, OnBgColorFn, "BGCOLOR_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMenuCOnTextCallback(self: *Self, callback: ?OnMenuCOnTextFn) void {
        const Handler = CallbackHandler(Self, OnMenuCOnTextFn, "MENUCONTEXT_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setLeaveItemCallback(self: *Self, callback: ?OnLeaveItemFn) void {
        const Handler = CallbackHandler(Self, OnLeaveItemFn, "LEAVEITEM_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setResizeMatrixCallback(self: *Self, callback: ?OnResizeMatrixFn) void {
        const Handler = CallbackHandler(Self, OnResizeMatrixFn, "RESIZEMATRIX_CB");
        Handler.setCallback(self, callback);
    }
};

test "MatrixEx DrawTextLayoutCenter" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawTextLayoutCenter(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextLayoutCenter();

    try std.testing.expect(ret == true);
}

test "MatrixEx DragTypes" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDragTypes("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDragTypes();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx HiddenTextMarks" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHiddenTextMarks("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHiddenTextMarks();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx XMax" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setXMax(42).unwrap());
    defer item.deinit();

    var ret = item.getXMax();

    try std.testing.expect(ret == 42);
}

test "MatrixEx FrameVertColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFrameVertColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameVertColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx VisibleCol" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setVisibleCol(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getVisibleCol(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Align" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setAlign(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getAlign(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Freeze" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFreeze("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFreeze();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Size" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "MatrixEx FrameHorizColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFrameHorizColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameHorizColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Value" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setValue("Hello").unwrap());
    defer item.deinit();

    var ret = item.getValue();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumEricFormatPrecision" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricFormatPrecision(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricFormatPrecision(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Type" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setType(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getType(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx SortImageDown" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setSortImageDown("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortImageDown();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx TipFgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTipFgColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getTipFgColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "MatrixEx NumEricDecimalSymbol" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricDecimalSymbol("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricDecimalSymbol();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Expand" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setExpand(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getExpand();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "MatrixEx DrawTextOrientation" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawTextOrientation(3.14).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextOrientation();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "MatrixEx Area" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setArea("Hello").unwrap());
    defer item.deinit();

    var ret = item.getArea();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Merged" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMerged(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getMerged(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DrawTextAlignment" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawTextAlignment(.ACenter).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextAlignment();

    try std.testing.expect(ret != null and ret.? == .ACenter);
}

test "MatrixEx DragSource" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDragSource(true).unwrap());
    defer item.deinit();

    var ret = item.getDragSource();

    try std.testing.expect(ret == true);
}

test "MatrixEx DrawColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getDrawColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "MatrixEx ArrowImages" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setArrowImages(42).unwrap());
    defer item.deinit();

    var ret = item.getArrowImages();

    try std.testing.expect(ret == 42);
}

test "MatrixEx Htmltd" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHtmltd("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHtmltd();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx OrigInOffset" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setOrigInOffset("Hello").unwrap());
    defer item.deinit();

    var ret = item.getOrigInOffset();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DrawLineWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawLineWidth(42).unwrap());
    defer item.deinit();

    var ret = item.getDrawLineWidth();

    try std.testing.expect(ret == 42);
}

test "MatrixEx NumColNoScroll" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumColNoScroll("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumColNoScroll();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FitMaxHeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFitMaxHeight(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFitMaxHeight(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx UserSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setUserSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getUserSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "MatrixEx Marked" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMarked(true).unwrap());
    defer item.deinit();

    var ret = item.getMarked();

    try std.testing.expect(ret == true);
}

test "MatrixEx NumEricFormatDef" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricFormatDef("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricFormatDef();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx XMin" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setXMin(42).unwrap());
    defer item.deinit();

    var ret = item.getXMin();

    try std.testing.expect(ret == 42);
}

test "MatrixEx DrawTextEllipsis" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawTextEllipsis(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextEllipsis();

    try std.testing.expect(ret == true);
}

test "MatrixEx MaskInt" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMaskInt(0, 9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMaskInt(0);

    try std.testing.expect(ret.begin == 9 and ret.end == 10);
}

test "MatrixEx ResizeDrag" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setResizeDrag("Hello").unwrap());
    defer item.deinit();

    var ret = item.getResizeDrag();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumEricUnitSpell" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricUnitSpell("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricUnitSpell();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Htmlth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHtmlth("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHtmlth();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumLinVisibleLast" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumLinVisibleLast("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumLinVisibleLast();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FrameColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFrameColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getFrameColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "MatrixEx IdValue" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setIdValue(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getIdValue(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx MarkArea" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMarkArea("Hello").unwrap());
    defer item.deinit();

    var ret = item.getMarkArea();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FrameTitleHighlight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFrameTitleHighlight("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameTitleHighlight();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Border" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setBorder(true).unwrap());
    defer item.deinit();

    var ret = item.getBorder();

    try std.testing.expect(ret == true);
}

test "MatrixEx CanFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setCanFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getCanFocus();

    try std.testing.expect(ret == true);
}

test "MatrixEx ToggleImageOff" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setToggleImageOff("Hello").unwrap());
    defer item.deinit();

    var ret = item.getToggleImageOff();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Merge" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMerge(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getMerge(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx SortSign" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setSortSign(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortSign(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx SortColUmnCaseSensitive" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setSortColUmnCaseSensitive("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortColUmnCaseSensitive();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx ToggleImageOn" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setToggleImageOn("Hello").unwrap());
    defer item.deinit();

    var ret = item.getToggleImageOn();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx YAutoHide" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setYAutoHide(true).unwrap());
    defer item.deinit();

    var ret = item.getYAutoHide();

    try std.testing.expect(ret == true);
}

test "MatrixEx DrawTextClip" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawTextClip(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextClip();

    try std.testing.expect(ret == true);
}

test "MatrixEx Theme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx SkipLines" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setSkipLines("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSkipLines();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx RasterHeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setRasterHeight(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getRasterHeight(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FocusCell" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFocusCell("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFocusCell();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx LineAlignment" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setLineAlignment(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getLineAlignment(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx VisibleLin" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setVisibleLin(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getVisibleLin(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx WidthDef" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setWidthDef(42).unwrap());
    defer item.deinit();

    var ret = item.getWidthDef();

    try std.testing.expect(ret == 42);
}

test "MatrixEx RasterWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setRasterWidth(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getRasterWidth(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FInDDirection" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFInDDirection("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFInDDirection();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Visible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setVisible(true).unwrap());
    defer item.deinit();

    var ret = item.getVisible();

    try std.testing.expect(ret == true);
}

test "MatrixEx NumLinNoScroll" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumLinNoScroll("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumLinNoScroll();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx BgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setBgColor(0, .{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getBgColor(0);

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "MatrixEx RasterSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setRasterSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getRasterSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "MatrixEx DrawStyle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawStyle(.Fill).unwrap());
    defer item.deinit();

    var ret = item.getDrawStyle();

    try std.testing.expect(ret != null and ret.? == .Fill);
}

test "MatrixEx ShowFillValue" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setShowFillValue("Hello").unwrap());
    defer item.deinit();

    var ret = item.getShowFillValue();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DropTarget" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDropTarget(true).unwrap());
    defer item.deinit();

    var ret = item.getDropTarget();

    try std.testing.expect(ret == true);
}

test "MatrixEx MaskNoEmpty" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMaskNoEmpty(0, true).unwrap());
    defer item.deinit();

    var ret = item.getMaskNoEmpty(0);

    try std.testing.expect(ret == true);
}

test "MatrixEx HideFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHideFocus("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHideFocus();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumCol" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumCol(42).unwrap());
    defer item.deinit();

    var ret = item.getNumCol();

    try std.testing.expect(ret == 42);
}

test "MatrixEx SortColUmNoRder" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setSortColUmNoRder("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortColUmNoRder();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx UndoRedo" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setUndoRedo("Hello").unwrap());
    defer item.deinit();

    var ret = item.getUndoRedo();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DrawMakeInactive" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawMakeInactive(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawMakeInactive();

    try std.testing.expect(ret == true);
}

test "MatrixEx DX" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDX(3.14).unwrap());
    defer item.deinit();

    var ret = item.getDX();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "MatrixEx DY" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDY(3.14).unwrap());
    defer item.deinit();

    var ret = item.getDY();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "MatrixEx TypeColorInactive" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTypeColorInactive("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTypeColorInactive();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Multiline" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMultiline(true).unwrap());
    defer item.deinit();

    var ret = item.getMultiline();

    try std.testing.expect(ret == true);
}

test "MatrixEx CellFrameVertColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setCellFrameVertColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getCellFrameVertColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Caret" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setCaret(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getCaret();

    try std.testing.expect(ret.lin == 9 and ret.col == 10);
}

test "MatrixEx Htmltr" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHtmltr("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHtmltr();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FreezeColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFreezeColor("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFreezeColor();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumColVisibleLast" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumColVisibleLast("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumColVisibleLast();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Position" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setPosition(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getPosition();

    try std.testing.expect(ret.x == 9 and ret.y == 10);
}

test "MatrixEx MinSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMinSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMinSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "MatrixEx MinColWidthDef" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMinColWidthDef(42).unwrap());
    defer item.deinit();

    var ret = item.getMinColWidthDef();

    try std.testing.expect(ret == 42);
}

test "MatrixEx ResizeMatrixColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setResizeMatrixColor("Hello").unwrap());
    defer item.deinit();

    var ret = item.getResizeMatrixColor();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx LineX" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setLineX(3.14).unwrap());
    defer item.deinit();

    var ret = item.getLineX();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "MatrixEx LineY" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setLineY(3.14).unwrap());
    defer item.deinit();

    var ret = item.getLineY();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "MatrixEx NumEricUnitSymbol" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricUnitSymbol(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricUnitSymbol(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx CopyData" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setCopyData("Hello").unwrap());
    defer item.deinit();

    var ret = item.getCopyData();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DropTypes" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDropTypes("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDropTypes();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx HandleName" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHandleName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHandleName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FontFace" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFontFace("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontFace();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Mark" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMark(0, .BLock).unwrap());
    defer item.deinit();

    var ret = item.getMark(0);

    try std.testing.expect(ret != null and ret.? == .BLock);
}

test "MatrixEx FInDmatchCase" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFInDmatchCase("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFInDmatchCase();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Mask" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMask(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getMask(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx MaxSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMaxSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMaxSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "MatrixEx Flat" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFlat(true).unwrap());
    defer item.deinit();

    var ret = item.getFlat();

    try std.testing.expect(ret == true);
}

test "MatrixEx NoScrollAsTitle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNoScrollAsTitle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNoScrollAsTitle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Height" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHeight(0, 42).unwrap());
    defer item.deinit();

    var ret = item.getHeight(0);

    try std.testing.expect(ret == 42);
}

test "MatrixEx FontStyle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFontStyle(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontStyle(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FrameTitleVertColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFrameTitleVertColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameTitleVertColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Font" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFont(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFont(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Multiple" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMultiple(true).unwrap());
    defer item.deinit();

    var ret = item.getMultiple();

    try std.testing.expect(ret == true);
}

test "MatrixEx MinColWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMinColWidth(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getMinColWidth(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx SortImageUp" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setSortImageUp("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortImageUp();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumEricUnitShown" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricUnitShown(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricUnitShown(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx WheelDropFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setWheelDropFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getWheelDropFocus();

    try std.testing.expect(ret == true);
}

test "MatrixEx FileFormat" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFileFormat("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFileFormat();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumEricQuantitY" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricQuantitY(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricQuantitY(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FontSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFontSize(0, 42).unwrap());
    defer item.deinit();

    var ret = item.getFontSize(0);

    try std.testing.expect(ret == 42);
}

test "MatrixEx TipMarkup" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTipMarkup("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTipMarkup();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx CellFrameHorizColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setCellFrameHorizColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getCellFrameHorizColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Redo" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setRedo("Hello").unwrap());
    defer item.deinit();

    var ret = item.getRedo();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx YMax" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setYMax(42).unwrap());
    defer item.deinit();

    var ret = item.getYMax();

    try std.testing.expect(ret == 42);
}

test "MatrixEx NTheme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FitMaxWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFitMaxWidth(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFitMaxWidth(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx SkipColumns" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setSkipColumns("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSkipColumns();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DragSourceMove" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDragSourceMove(true).unwrap());
    defer item.deinit();

    var ret = item.getDragSourceMove();

    try std.testing.expect(ret == true);
}

test "MatrixEx NumLin" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumLin(42).unwrap());
    defer item.deinit();

    var ret = item.getNumLin();

    try std.testing.expect(ret == 42);
}

test "MatrixEx NumEricUnit" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricUnit(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricUnit(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx ResizeMatrix" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setResizeMatrix(true).unwrap());
    defer item.deinit();

    var ret = item.getResizeMatrix();

    try std.testing.expect(ret == true);
}

test "MatrixEx Active" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setActive(true).unwrap());
    defer item.deinit();

    var ret = item.getActive();

    try std.testing.expect(ret == true);
}

test "MatrixEx FgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFgColor(0, .{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getFgColor(0);

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "MatrixEx HlColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHlColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getHlColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "MatrixEx TipIcon" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTipIcon("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTipIcon();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx MaskCasei" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMaskCasei(0, true).unwrap());
    defer item.deinit();

    var ret = item.getMaskCasei(0);

    try std.testing.expect(ret == true);
}

test "MatrixEx LimitExpand" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setLimitExpand("Hello").unwrap());
    defer item.deinit();

    var ret = item.getLimitExpand();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx PosX" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setPosX(3.14).unwrap());
    defer item.deinit();

    var ret = item.getPosX();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "MatrixEx PosY" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setPosY(3.14).unwrap());
    defer item.deinit();

    var ret = item.getPosY();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "MatrixEx NumEricQuantitYIndex" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricQuantitYIndex(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricQuantitYIndex(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx MenuCOnText" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMenuCOnText("Hello").unwrap());
    defer item.deinit();

    var ret = item.getMenuCOnText();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx XAutoHide" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setXAutoHide(true).unwrap());
    defer item.deinit();

    var ret = item.getXAutoHide();

    try std.testing.expect(ret == true);
}

test "MatrixEx TipVisible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTipVisible(true).unwrap());
    defer item.deinit();

    var ret = item.getTipVisible();

    try std.testing.expect(ret == true);
}

test "MatrixEx MarkMode" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMarkMode(.SInGle).unwrap());
    defer item.deinit();

    var ret = item.getMarkMode();

    try std.testing.expect(ret != null and ret.? == .SInGle);
}

test "MatrixEx DrawFont" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawFont("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDrawFont();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx HeightDef" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHeightDef(42).unwrap());
    defer item.deinit();

    var ret = item.getHeightDef();

    try std.testing.expect(ret == 42);
}

test "MatrixEx ExpandWeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setExpandWeight(3.14).unwrap());
    defer item.deinit();

    var ret = item.getExpandWeight();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "MatrixEx CopyKeepstruct" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setCopyKeepstruct("Hello").unwrap());
    defer item.deinit();

    var ret = item.getCopyKeepstruct();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx TextSeparator" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTextSeparator("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTextSeparator();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx TipBgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTipBgColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getTipBgColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "MatrixEx OrigIn" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setOrigIn("Hello").unwrap());
    defer item.deinit();

    var ret = item.getOrigIn();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx LateXLabel" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setLateXLabel("Hello").unwrap());
    defer item.deinit();

    var ret = item.getLateXLabel();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DrawBgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawBgColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getDrawBgColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "MatrixEx TextSkipLines" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTextSkipLines("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTextSkipLines();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx EditMode" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setEditMode("Hello").unwrap());
    defer item.deinit();

    var ret = item.getEditMode();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx EditNext" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setEditNext("Hello").unwrap());
    defer item.deinit();

    var ret = item.getEditNext();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx YMin" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setYMin(42).unwrap());
    defer item.deinit();

    var ret = item.getYMin();

    try std.testing.expect(ret == 42);
}

test "MatrixEx ToggleCenterEd" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setToggleCenterEd("Hello").unwrap());
    defer item.deinit();

    var ret = item.getToggleCenterEd();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NormalizerGroup" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNormalizerGroup("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNormalizerGroup();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx ScrollBar" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setScrollBar(true).unwrap());
    defer item.deinit();

    var ret = item.getScrollBar();

    try std.testing.expect(ret == true);
}

test "MatrixEx BusY" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setBusY("Hello").unwrap());
    defer item.deinit();

    var ret = item.getBusY();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx UseTitleSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setUseTitleSize("Hello").unwrap());
    defer item.deinit();

    var ret = item.getUseTitleSize();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DropFilesTarget" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDropFilesTarget(true).unwrap());
    defer item.deinit();

    var ret = item.getDropFilesTarget();

    try std.testing.expect(ret == true);
}

test "MatrixEx AlignmentLin0" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setAlignmentLin0("Hello").unwrap());
    defer item.deinit();

    var ret = item.getAlignmentLin0();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FrameBorder" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFrameBorder("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameBorder();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumEricUnitShowNIndex" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricUnitShowNIndex(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricUnitShowNIndex(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FrameTitleHorizColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFrameTitleHorizColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameTitleHorizColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx MarkAtTitle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMarkAtTitle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getMarkAtTitle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx CopyColTo" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setCopyColTo(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getCopyColTo(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx EditHideOnFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setEditHideOnFocus("Hello").unwrap());
    defer item.deinit();

    var ret = item.getEditHideOnFocus();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Undo" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setUndo("Hello").unwrap());
    defer item.deinit();

    var ret = item.getUndo();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumEricUnitIndex" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricUnitIndex(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricUnitIndex(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx HtmlCaption" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHtmlCaption("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHtmlCaption();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx CopyCaption" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setCopyCaption("Hello").unwrap());
    defer item.deinit();

    var ret = item.getCopyCaption();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx HlColorAlpha" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHlColorAlpha(42).unwrap());
    defer item.deinit();

    var ret = item.getHlColorAlpha();

    try std.testing.expect(ret == 42);
}

test "MatrixEx HtmlTable" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setHtmlTable("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHtmlTable();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumEricUnitSymbolShown" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricUnitSymbolShown(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricUnitSymbolShown(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DrawTextWrap" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDrawTextWrap(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextWrap();

    try std.testing.expect(ret == true);
}

test "MatrixEx Tip" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTip("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTip();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx DragDrop" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setDragDrop(true).unwrap());
    defer item.deinit();

    var ret = item.getDragDrop();

    try std.testing.expect(ret == true);
}

test "MatrixEx TipDelay" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTipDelay(42).unwrap());
    defer item.deinit();

    var ret = item.getTipDelay();

    try std.testing.expect(ret == 42);
}

test "MatrixEx ToggleValue" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setToggleValue(0, .On).unwrap());
    defer item.deinit();

    var ret = item.getToggleValue(0);

    try std.testing.expect(ret != null and ret.? == .On);
}

test "MatrixEx NumColVisible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumColVisible("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumColVisible();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx FInd" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFInd("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFInd();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumEricFormatTitle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricFormatTitle(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricFormatTitle(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx MarkMultiple" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setMarkMultiple(true).unwrap());
    defer item.deinit();

    var ret = item.getMarkMultiple();

    try std.testing.expect(ret == true);
}

test "MatrixEx Floating" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFloating(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getFloating();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "MatrixEx NumEricFormat" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumEricFormat(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricFormat(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Width" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setWidth(0, 42).unwrap());
    defer item.deinit();

    var ret = item.getWidth(0);

    try std.testing.expect(ret == 42);
}

test "MatrixEx Touch" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setTouch(true).unwrap());
    defer item.deinit();

    var ret = item.getTouch();

    try std.testing.expect(ret == true);
}

test "MatrixEx BusYProgress" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setBusYProgress("Hello").unwrap());
    defer item.deinit();

    var ret = item.getBusYProgress();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Name" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx Readonly" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setReadonly(true).unwrap());
    defer item.deinit();

    var ret = item.getReadonly();

    try std.testing.expect(ret == true);
}

test "MatrixEx FInDmatchWholeCell" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setFInDmatchWholeCell("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFInDmatchWholeCell();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx NumLinVisible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setNumLinVisible("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumLinVisible();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "MatrixEx PropagateFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setPropagateFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getPropagateFocus();

    try std.testing.expect(ret == true);
}

test "MatrixEx BackingStore" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.MatrixEx.init().setBackingStore(true).unwrap());
    defer item.deinit();

    var ret = item.getBackingStore();

    try std.testing.expect(ret == true);
}
