// This code was generated by a tool.
// IUP Metadata Code Generator
// https://github.com/batiati/IUPMetadata
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.

const std = @import("std");

const interop = @import("../interop.zig");
const iup = @import("../iup.zig");

const Impl = @import("../impl.zig").Impl;
const CallbackHandler = @import("../callback_handler.zig").CallbackHandler;

const debug = std.debug;
const trait = std.meta.trait;

const Element = iup.Element;
const Handle = iup.Handle;
const Error = iup.Error;
const ChildrenIterator = iup.ChildrenIterator;
const Size = iup.Size;
const Margin = iup.Margin;

pub const Matrix = opaque {
    pub const CLASS_NAME = "matrix";
    pub const NATIVE_TYPE = iup.NativeType.Canvas;
    const Self = @This();

    pub const OnColResizeFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnWheelFn = fn (self: *Self, arg0: f32, arg1: i32, arg2: i32, arg3: [:0]const u8) anyerror!void;

    pub const OnEditMouseMoveFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnDropCheckFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnDestroyFn = fn (self: *Self) anyerror!void;

    pub const OnNumEricSetValueFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: f64) anyerror!void;

    pub const OnKillFocusFn = fn (self: *Self) anyerror!void;

    pub const OnMotionFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnDragEndFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnSortColUmncompareFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32) anyerror!void;

    pub const OnPostMessageFn = fn (self: *Self, arg0: [:0]const u8, arg1: i32, arg2: f64, arg3: ?*anyopaque) anyerror!void;

    pub const OnTranslateValueFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) [:0]const u8;

    pub const OnScrollFn = fn (self: *Self, arg0: i32, arg1: f32, arg2: f32) anyerror!void;

    pub const OnMouseMoveFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnActionFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: [:0]const u8) anyerror!void;

    pub const OnWomFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnDropDataFn = fn (self: *Self, arg0: [:0]const u8, arg1: ?*anyopaque, arg2: i32, arg3: i32, arg4: i32) anyerror!void;

    pub const OnKAnyFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnScrollTopFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnDropFn = fn (self: *Self, arg0: iup.Element, arg1: i32, arg2: i32) anyerror!void;

    pub const OnMarkFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnEnterItemFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnUnmapFn = fn (self: *Self) anyerror!void;

    pub const OnEnterWindowFn = fn (self: *Self) anyerror!void;

    pub const OnLeaveWindowFn = fn (self: *Self) anyerror!void;

    pub const OnClickFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnMarkedItFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32) anyerror!void;

    pub const OnDragBeginFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnTypeFn = fn (self: *Self, arg0: i32, arg1: i32) [:0]const u8;

    pub const OnDragDataSizeFn = fn (self: *Self, arg0: [:0]const u8) anyerror!void;

    pub const OnEditReleaseFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnLDestroyFn = fn (self: *Self) anyerror!void;

    pub const OnCanvasActionFn = fn (self: *Self, arg0: f32, arg1: f32) anyerror!void;

    pub const OnEditClickFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnValueEditFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnFontFn = fn (self: *Self, arg0: i32, arg1: i32) [:0]const u8;

    pub const OnDropMotionFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnKeyPressFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnToggleValueFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32) anyerror!void;

    pub const OnResizeFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnGetFocusFn = fn (self: *Self) anyerror!void;

    pub const OnHelpFn = fn (self: *Self) anyerror!void;

    pub const OnFocusFn = fn (self: *Self, arg0: i32) anyerror!void;

    pub const OnDropSelectFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: iup.Element, arg3: [:0]const u8, arg4: i32, arg5: i32) anyerror!void;

    pub const OnDropFilesFn = fn (self: *Self, arg0: [:0]const u8, arg1: i32, arg2: i32, arg3: i32) anyerror!void;

    pub const OnEditIOnFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32) anyerror!void;

    pub const OnMenuDropFn = fn (self: *Self, arg0: iup.Element, arg1: i32, arg2: i32) anyerror!void;

    pub const OnDrawFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32, arg5: i32, arg6: *iup.Canvas) anyerror!void;

    pub const OnValueFn = fn (self: *Self, arg0: i32, arg1: i32) [:0]const u8;

    pub const OnValueChangedFn = fn (self: *Self) anyerror!void;

    pub const OnReleaseFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: [:0]const u8) anyerror!void;

    pub const OnDragDataFn = fn (self: *Self, arg0: [:0]const u8, arg1: ?*anyopaque, arg2: i32) anyerror!void;

    pub const OnButtonFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: [:0]const u8) anyerror!void;

    pub const OnMapFn = fn (self: *Self) anyerror!void;

    pub const OnFgColorFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: *i32, arg3: *i32, arg4: *i32) anyerror!void;

    pub const OnNumEricGetValueFn = fn (self: *Self, arg0: i32, arg1: i32) f64;

    pub const OnBgColorFn = fn (self: *Self, arg0: i32, arg1: i32, arg2: *i32, arg3: *i32, arg4: *i32) anyerror!void;

    pub const OnLeaveItemFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const OnResizeMatrixFn = fn (self: *Self, arg0: i32, arg1: i32) anyerror!void;

    pub const Expand = enum {
        Yes,
        Horizontal,
        Vertical,
        HorizontalFree,
        VerticalFree,
        No,
    };

    pub const DrawTextAlignment = enum {
        ACenter,
        ARight,
        ALeft,
    };

    pub const ZOrder = enum {
        Top,
        Bottom,
    };

    pub const DrawStyle = enum {
        Fill,
        StrokeDash,
        StrokeDot,
        StrokeDashDot,
        StrokeDashDotdot,
        DrawStroke,
    };

    pub const Mark = enum {
        BLock,
        ClearAll,
        MarkAll,
        InVertAll,
        InVert,
    };

    pub const MarkMode = enum {
        SInGle,
        Multiple,
        Cell,
    };

    pub const ToggleValue = enum {
        On,
        Off,
        NotDef,
    };

    pub const Floating = enum {
        Yes,
        Ignore,
        No,
    };

    pub const Initializer = struct {
        last_error: ?anyerror = null,
        ref: *Self,

        ///
        /// Returns a pointer to IUP element or an error.
        /// Only top-level or detached elements needs to be unwraped,
        pub fn unwrap(self: Initializer) !*Self {
            if (self.last_error) |e| {
                return e;
            } else {
                return self.ref;
            }
        }

        ///
        /// Captures a reference into a external variable
        /// Allows to capture some references even using full declarative API
        pub fn capture(self: Initializer, ref: **Self) Initializer {
            ref.* = self.ref;
            return self;
        }

        pub fn setStrAttribute(self: Initializer, attributeName: [:0]const u8, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            Self.setStrAttribute(self.ref, attributeName, arg);
            return self;
        }

        pub fn setIntAttribute(self: Initializer, attributeName: [:0]const u8, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            Self.setIntAttribute(self.ref, attributeName, arg);
            return self;
        }

        pub fn setBoolAttribute(self: Initializer, attributeName: [:0]const u8, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            Self.setBoolAttribute(self.ref, attributeName, arg);
            return self;
        }

        pub fn setPtrAttribute(self: Initializer, comptime T: type, attributeName: [:0]const u8, value: ?*T) Initializer {
            if (self.last_error) |_| return self;
            Self.setPtrAttribute(self.ref, T, attributeName, value);
            return self;
        }

        pub fn setHandle(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setHandle(self.ref, arg);
            return self;
        }

        pub fn setDrawTextLayoutCenter(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DRAWTEXTLAYOUTCENTER", .{}, arg);
            return self;
        }

        pub fn setDragTypes(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "DRAGTYPES", .{}, arg);
            return self;
        }

        pub fn setHiddenTextMarks(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "HIDDENTEXTMARKS", .{}, arg);
            return self;
        }

        pub fn setXMax(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "XMAX", .{}, arg);
            return self;
        }

        pub fn setFrameVertColor(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FRAMEVERTCOLOR", .{index}, arg);
            return self;
        }

        pub fn setAlign(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "ALIGN", .{index}, arg);
            return self;
        }

        pub fn setSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "SIZE", .{}, value);
            return self;
        }

        pub fn addCol(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "ADDCOL", .{}, arg);
            return self;
        }

        pub fn setFrameHorizColor(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FRAMEHORIZCOLOR", .{index}, arg);
            return self;
        }

        pub fn setValue(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "VALUE", .{}, arg);
            return self;
        }

        pub fn setNumEricFormatPrecision(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMERICFORMATPRECISION", .{index}, arg);
            return self;
        }

        pub fn setType(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TYPE", .{index}, arg);
            return self;
        }

        pub fn setSortImageDown(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SORTIMAGEDOWN", .{}, arg);
            return self;
        }

        pub fn moveCol(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MOVECOL", .{index}, arg);
            return self;
        }

        pub fn setTipFgColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "TIPFGCOLOR", .{}, rgb);
            return self;
        }

        pub fn setNumEricDecimalSymbol(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMERICDECIMALSYMBOL", .{}, arg);
            return self;
        }

        pub fn setExpand(self: Initializer, arg: ?Expand) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .Yes => interop.setStrAttribute(self.ref, "EXPAND", .{}, "YES"),
                .Horizontal => interop.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTAL"),
                .Vertical => interop.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICAL"),
                .HorizontalFree => interop.setStrAttribute(self.ref, "EXPAND", .{}, "HORIZONTALFREE"),
                .VerticalFree => interop.setStrAttribute(self.ref, "EXPAND", .{}, "VERTICALFREE"),
                .No => interop.setStrAttribute(self.ref, "EXPAND", .{}, "NO"),
            } else {
                interop.clearAttribute(self.ref, "EXPAND", .{});
            }
            return self;
        }

        pub fn setDrawTextOrientation(self: Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self;
            interop.setDoubleAttribute(self.ref, "DRAWTEXTORIENTATION", .{}, arg);
            return self;
        }

        pub fn setArea(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "AREA", .{}, arg);
            return self;
        }

        pub fn setMerged(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MERGED", .{index}, arg);
            return self;
        }

        pub fn setDrawTextAlignment(self: Initializer, arg: ?DrawTextAlignment) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .ACenter => interop.setStrAttribute(self.ref, "DRAWTEXTALIGNMENT", .{}, "ACENTER"),
                .ARight => interop.setStrAttribute(self.ref, "DRAWTEXTALIGNMENT", .{}, "ARIGHT"),
                .ALeft => interop.setStrAttribute(self.ref, "DRAWTEXTALIGNMENT", .{}, "ALEFT"),
            } else {
                interop.clearAttribute(self.ref, "DRAWTEXTALIGNMENT", .{});
            }
            return self;
        }

        pub fn setDragSource(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DRAGSOURCE", .{}, arg);
            return self;
        }

        pub fn setDrawColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "DRAWCOLOR", .{}, rgb);
            return self;
        }

        pub fn setArrowImages(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "ARROWIMAGES", .{}, arg);
            return self;
        }

        pub fn setOrigInOffset(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "ORIGINOFFSET", .{}, arg);
            return self;
        }

        pub fn setDrawLineWidth(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "DRAWLINEWIDTH", .{}, arg);
            return self;
        }

        pub fn setNumColNoScroll(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMCOL_NOSCROLL", .{}, arg);
            return self;
        }

        pub fn setFitMaxHeight(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FITMAXHEIGHT", .{index}, arg);
            return self;
        }

        pub fn mergeSplit(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MERGESPLIT", .{}, arg);
            return self;
        }

        pub fn setUserSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "USERSIZE", .{}, value);
            return self;
        }

        pub fn setMarked(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "MARKED", .{}, arg);
            return self;
        }

        pub fn setNumEricFormatDef(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMERICFORMATDEF", .{}, arg);
            return self;
        }

        pub fn clearValue(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "CLEARVALUE", .{index}, arg);
            return self;
        }

        pub fn setXMin(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "XMIN", .{}, arg);
            return self;
        }

        pub fn setDrawTextEllipsis(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DRAWTEXTELLIPSIS", .{}, arg);
            return self;
        }

        pub fn delLin(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "DELLIN", .{}, arg);
            return self;
        }

        pub fn setMaskInt(self: Initializer, index: i32, begin: i32, end: i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = iup.Range.intIntToString(&buffer, begin, end, ',');
            interop.setStrAttribute(self.ref, "MASKINT", .{index}, value);
            return self;
        }

        pub fn setResizeDrag(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "RESIZEDRAG", .{}, arg);
            return self;
        }

        pub fn setNumLinVisibleLast(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMLIN_VISIBLE_LAST", .{}, arg);
            return self;
        }

        pub fn sortColUmn(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SORTCOLUMN", .{index}, arg);
            return self;
        }

        pub fn setFrameColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "FRAMECOLOR", .{}, rgb);
            return self;
        }

        pub fn setIdValue(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "IDVALUE", .{index}, arg);
            return self;
        }

        pub fn show(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SHOW", .{}, arg);
            return self;
        }

        pub fn setSbImageBottomInactive(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGEBOTTOMINACTIVE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageBottomInactiveHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGEBOTTOMINACTIVE", .{}, arg);
            return self;
        }

        pub fn setMarkArea(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MARKAREA", .{}, arg);
            return self;
        }

        pub fn setFrameTitleHighlight(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FRAMETITLEHIGHLIGHT", .{}, arg);
            return self;
        }

        pub fn setSbImageTopPress(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGETOPPRESS", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageTopPressHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGETOPPRESS", .{}, arg);
            return self;
        }

        pub fn setBorder(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "BORDER", .{}, arg);
            return self;
        }

        pub fn setCanFocus(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "CANFOCUS", .{}, arg);
            return self;
        }

        pub fn setSbImageTop(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGETOP", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageTopHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGETOP", .{}, arg);
            return self;
        }

        pub fn setToggleImageOff(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TOGGLEIMAGEOFF", .{}, arg);
            return self;
        }

        pub fn setMerge(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MERGE", .{index}, arg);
            return self;
        }

        pub fn setSortSign(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SORTSIGN", .{index}, arg);
            return self;
        }

        pub fn setSbImageRightInactive(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGERIGHTINACTIVE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageRightInactiveHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGERIGHTINACTIVE", .{}, arg);
            return self;
        }

        pub fn setSortColUmnCaseSensitive(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SORTCOLUMNCASESENSITIVE", .{}, arg);
            return self;
        }

        pub fn setToggleImageOn(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TOGGLEIMAGEON", .{}, arg);
            return self;
        }

        pub fn setYAutoHide(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "YAUTOHIDE", .{}, arg);
            return self;
        }

        pub fn setDrawTextClip(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DRAWTEXTCLIP", .{}, arg);
            return self;
        }

        pub fn setTheme(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "THEME", .{}, arg);
            return self;
        }

        pub fn zOrder(self: Initializer, arg: ?ZOrder) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .Top => interop.setStrAttribute(self.ref, "ZORDER", .{}, "TOP"),
                .Bottom => interop.setStrAttribute(self.ref, "ZORDER", .{}, "BOTTOM"),
            } else {
                interop.clearAttribute(self.ref, "ZORDER", .{});
            }
            return self;
        }

        pub fn setRasterHeight(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "RASTERHEIGHT", .{index}, arg);
            return self;
        }

        pub fn setFocusCell(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FOCUSCELL", .{}, arg);
            return self;
        }

        pub fn setLineAlignment(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "LINEALIGNMENT", .{index}, arg);
            return self;
        }

        pub fn setWidthDef(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "WIDTHDEF", .{}, arg);
            return self;
        }

        pub fn setRasterWidth(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "RASTERWIDTH", .{index}, arg);
            return self;
        }

        pub fn setVisible(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "VISIBLE", .{}, arg);
            return self;
        }

        pub fn setNumLinNoScroll(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMLIN_NOSCROLL", .{}, arg);
            return self;
        }

        pub fn setBgColor(self: Initializer, index: i32, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "BGCOLOR", .{index}, rgb);
            return self;
        }

        pub fn addLin(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "ADDLIN", .{}, arg);
            return self;
        }

        pub fn setRasterSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "RASTERSIZE", .{}, value);
            return self;
        }

        pub fn setDrawStyle(self: Initializer, arg: ?DrawStyle) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .Fill => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "FILL"),
                .StrokeDash => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "STROKE_DASH"),
                .StrokeDot => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "STROKE_DOT"),
                .StrokeDashDot => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "STROKE_DASH_DOT"),
                .StrokeDashDotdot => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "STROKE_DASH_DOT_DOT"),
                .DrawStroke => interop.setStrAttribute(self.ref, "DRAWSTYLE", .{}, "DRAW_STROKE"),
            } else {
                interop.clearAttribute(self.ref, "DRAWSTYLE", .{});
            }
            return self;
        }

        pub fn setShowFillValue(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SHOWFILLVALUE", .{}, arg);
            return self;
        }

        pub fn setDropTarget(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DROPTARGET", .{}, arg);
            return self;
        }

        pub fn setMaskNoEmpty(self: Initializer, index: i32, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "MASKNOEMPTY", .{index}, arg);
            return self;
        }

        pub fn setHideFocus(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "HIDEFOCUS", .{}, arg);
            return self;
        }

        pub fn setNumCol(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "NUMCOL", .{}, arg);
            return self;
        }

        pub fn moveLin(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MOVELIN", .{index}, arg);
            return self;
        }

        pub fn setSortColUmNoRder(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SORTCOLUMNORDER", .{}, arg);
            return self;
        }

        pub fn setSbImageBottom(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGEBOTTOM", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageBottomHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGEBOTTOM", .{}, arg);
            return self;
        }

        pub fn setUndoRedo(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "UNDOREDO", .{}, arg);
            return self;
        }

        pub fn setDrawMakeInactive(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DRAWMAKEINACTIVE", .{}, arg);
            return self;
        }

        pub fn setDX(self: Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self;
            interop.setDoubleAttribute(self.ref, "DX", .{}, arg);
            return self;
        }

        pub fn setDY(self: Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self;
            interop.setDoubleAttribute(self.ref, "DY", .{}, arg);
            return self;
        }

        pub fn setTypeColorInactive(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TYPECOLORINACTIVE", .{}, arg);
            return self;
        }

        pub fn setMultiline(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "MULTILINE", .{}, arg);
            return self;
        }

        pub fn setCellFrameVertColor(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "CELLFRAMEVERTCOLOR", .{index}, arg);
            return self;
        }

        pub fn setCaret(self: Initializer, lin: i32, col: i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = iup.LinColPos.intIntToString(&buffer, lin, col, ',');
            interop.setStrAttribute(self.ref, "CARET", .{}, value);
            return self;
        }

        pub fn setNumColVisibleLast(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMCOL_VISIBLE_LAST", .{}, arg);
            return self;
        }

        pub fn setPosition(self: Initializer, x: i32, y: i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
            interop.setStrAttribute(self.ref, "POSITION", .{}, value);
            return self;
        }

        pub fn setMinSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "MINSIZE", .{}, value);
            return self;
        }

        pub fn setMinColWidthDef(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "MINCOLWIDTHDEF", .{}, arg);
            return self;
        }

        pub fn setResizeMatrixColor(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "RESIZEMATRIXCOLOR", .{}, arg);
            return self;
        }

        pub fn setLineX(self: Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self;
            interop.setDoubleAttribute(self.ref, "LINEX", .{}, arg);
            return self;
        }

        pub fn setLineY(self: Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self;
            interop.setDoubleAttribute(self.ref, "LINEY", .{}, arg);
            return self;
        }

        pub fn setDropTypes(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "DROPTYPES", .{}, arg);
            return self;
        }

        pub fn setHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "HANDLENAME", .{}, arg);
            return self;
        }

        pub fn setFontFace(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FONTFACE", .{}, arg);
            return self;
        }

        pub fn setSbImageTopInactive(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGETOPINACTIVE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageTopInactiveHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGETOPINACTIVE", .{}, arg);
            return self;
        }

        pub fn setMark(self: Initializer, index: i32, arg: ?Mark) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .BLock => interop.setStrAttribute(self.ref, "MARK", .{index}, "BLOCK"),
                .ClearAll => interop.setStrAttribute(self.ref, "MARK", .{index}, "CLEARALL"),
                .MarkAll => interop.setStrAttribute(self.ref, "MARK", .{index}, "MARKALL"),
                .InVertAll => interop.setStrAttribute(self.ref, "MARK", .{index}, "INVERTALL"),
                .InVert => interop.setStrAttribute(self.ref, "MARK", .{index}, "INVERT"),
            } else {
                interop.clearAttribute(self.ref, "MARK", .{index});
            }
            return self;
        }

        pub fn setMask(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MASK", .{index}, arg);
            return self;
        }

        pub fn setMaxSize(self: Initializer, width: ?i32, height: ?i32) Initializer {
            if (self.last_error) |_| return self;
            var buffer: [128]u8 = undefined;
            var value = Size.intIntToString(&buffer, width, height);
            interop.setStrAttribute(self.ref, "MAXSIZE", .{}, value);
            return self;
        }

        pub fn setFlat(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "FLAT", .{}, arg);
            return self;
        }

        pub fn setNoScrollAsTitle(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NOSCROLLASTITLE", .{}, arg);
            return self;
        }

        pub fn clearAttrib(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "CLEARATTRIB", .{index}, arg);
            return self;
        }

        pub fn setHeight(self: Initializer, index: i32, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "HEIGHT", .{index}, arg);
            return self;
        }

        pub fn setFontStyle(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FONTSTYLE", .{index}, arg);
            return self;
        }

        pub fn setFrameTitleVertColor(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FRAMETITLEVERTCOLOR", .{index}, arg);
            return self;
        }

        pub fn fitToSize(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FITTOSIZE", .{}, arg);
            return self;
        }

        pub fn setFont(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FONT", .{index}, arg);
            return self;
        }

        pub fn setMultiple(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "MULTIPLE", .{}, arg);
            return self;
        }

        pub fn setSbImageRightPress(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGERIGHTPRESS", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageRightPressHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGERIGHTPRESS", .{}, arg);
            return self;
        }

        pub fn setCursor(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "CURSOR", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setCursorHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "CURSOR", .{}, arg);
            return self;
        }

        pub fn setMinColWidth(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MINCOLWIDTH", .{index}, arg);
            return self;
        }

        pub fn setSortImageUp(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SORTIMAGEUP", .{}, arg);
            return self;
        }

        pub fn setWheelDropFocus(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "WHEELDROPFOCUS", .{}, arg);
            return self;
        }

        pub fn setFontSize(self: Initializer, index: i32, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "FONTSIZE", .{index}, arg);
            return self;
        }

        pub fn copyCol(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "COPYCOL", .{index}, arg);
            return self;
        }

        pub fn setTipMarkup(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TIPMARKUP", .{}, arg);
            return self;
        }

        pub fn setSbImageLeftHighlight(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGELEFTHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageLeftHighlightHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGELEFTHIGHLIGHT", .{}, arg);
            return self;
        }

        pub fn setCellFrameHorizColor(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "CELLFRAMEHORIZCOLOR", .{index}, arg);
            return self;
        }

        pub fn setYMax(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "YMAX", .{}, arg);
            return self;
        }

        pub fn setSbImageLeft(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGELEFT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageLeftHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGELEFT", .{}, arg);
            return self;
        }

        pub fn setNTheme(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NTHEME", .{}, arg);
            return self;
        }

        pub fn setFitMaxWidth(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FITMAXWIDTH", .{index}, arg);
            return self;
        }

        pub fn setDragSourceMove(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DRAGSOURCEMOVE", .{}, arg);
            return self;
        }

        pub fn setNumLin(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "NUMLIN", .{}, arg);
            return self;
        }

        pub fn setResizeMatrix(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "RESIZEMATRIX", .{}, arg);
            return self;
        }

        pub fn setActive(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "ACTIVE", .{}, arg);
            return self;
        }

        pub fn setSbImageTopHighlight(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGETOPHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageTopHighlightHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGETOPHIGHLIGHT", .{}, arg);
            return self;
        }

        pub fn setFgColor(self: Initializer, index: i32, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "FGCOLOR", .{index}, rgb);
            return self;
        }

        pub fn setHlColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "HLCOLOR", .{}, rgb);
            return self;
        }

        pub fn setTipIcon(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TIPICON", .{}, arg);
            return self;
        }

        pub fn setMaskCasei(self: Initializer, index: i32, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "MASKCASEI", .{index}, arg);
            return self;
        }

        pub fn fitToText(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FITTOTEXT", .{}, arg);
            return self;
        }

        pub fn setLimitExpand(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "LIMITEXPAND", .{}, arg);
            return self;
        }

        pub fn setPosX(self: Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self;
            interop.setDoubleAttribute(self.ref, "POSX", .{}, arg);
            return self;
        }

        pub fn setPosY(self: Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self;
            interop.setDoubleAttribute(self.ref, "POSY", .{}, arg);
            return self;
        }

        pub fn setNumEricQuantitYIndex(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMERICQUANTITYINDEX", .{index}, arg);
            return self;
        }

        pub fn setXAutoHide(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "XAUTOHIDE", .{}, arg);
            return self;
        }

        pub fn setTipVisible(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "TIPVISIBLE", .{}, arg);
            return self;
        }

        pub fn setMarkMode(self: Initializer, arg: ?MarkMode) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .SInGle => interop.setStrAttribute(self.ref, "MARKMODE", .{}, "SINGLE"),
                .Multiple => interop.setStrAttribute(self.ref, "MARKMODE", .{}, "MULTIPLE"),
                .Cell => interop.setStrAttribute(self.ref, "MARKMODE", .{}, "CELL"),
            } else {
                interop.clearAttribute(self.ref, "MARKMODE", .{});
            }
            return self;
        }

        pub fn setDrawFont(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "DRAWFONT", .{}, arg);
            return self;
        }

        pub fn setHeightDef(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "HEIGHTDEF", .{}, arg);
            return self;
        }

        pub fn setExpandWeight(self: Initializer, arg: f64) Initializer {
            if (self.last_error) |_| return self;
            interop.setDoubleAttribute(self.ref, "EXPANDWEIGHT", .{}, arg);
            return self;
        }

        pub fn setTipBgColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "TIPBGCOLOR", .{}, rgb);
            return self;
        }

        pub fn setOrigIn(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "ORIGIN", .{}, arg);
            return self;
        }

        pub fn setDrawBgColor(self: Initializer, rgb: iup.Rgb) Initializer {
            if (self.last_error) |_| return self;
            interop.setRgb(self.ref, "DRAWBGCOLOR", .{}, rgb);
            return self;
        }

        pub fn setEditMode(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "EDITMODE", .{}, arg);
            return self;
        }

        pub fn setEditNext(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "EDITNEXT", .{}, arg);
            return self;
        }

        pub fn setYMin(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "YMIN", .{}, arg);
            return self;
        }

        pub fn setToggleCenterEd(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TOGGLECENTERED", .{}, arg);
            return self;
        }

        pub fn setNormalizerGroup(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NORMALIZERGROUP", .{}, arg);
            return self;
        }

        pub fn setScrollBar(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "SCROLLBAR", .{}, arg);
            return self;
        }

        pub fn setUseTitleSize(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "USETITLESIZE", .{}, arg);
            return self;
        }

        pub fn setDropFilesTarget(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DROPFILESTARGET", .{}, arg);
            return self;
        }

        pub fn setAlignmentLin0(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "ALIGNMENTLIN0", .{}, arg);
            return self;
        }

        pub fn setFrameBorder(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FRAMEBORDER", .{}, arg);
            return self;
        }

        pub fn setNumEricUnitShowNIndex(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMERICUNITSHOWNINDEX", .{index}, arg);
            return self;
        }

        pub fn setFrameTitleHorizColor(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "FRAMETITLEHORIZCOLOR", .{index}, arg);
            return self;
        }

        pub fn setMarkAtTitle(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MARKATTITLE", .{}, arg);
            return self;
        }

        pub fn setEditHideOnFocus(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "EDITHIDEONFOCUS", .{}, arg);
            return self;
        }

        pub fn setSbImageRightHighlight(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGERIGHTHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageRightHighlightHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGERIGHTHIGHLIGHT", .{}, arg);
            return self;
        }

        pub fn setNumEricUnitIndex(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMERICUNITINDEX", .{index}, arg);
            return self;
        }

        pub fn setSbImageLeftPress(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGELEFTPRESS", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageLeftPressHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGELEFTPRESS", .{}, arg);
            return self;
        }

        pub fn setHlColorAlpha(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "HLCOLORALPHA", .{}, arg);
            return self;
        }

        pub fn setSbImageBottomHighlight(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGEBOTTOMHIGHLIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageBottomHighlightHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGEBOTTOMHIGHLIGHT", .{}, arg);
            return self;
        }

        pub fn setDrawTextWrap(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DRAWTEXTWRAP", .{}, arg);
            return self;
        }

        pub fn delCol(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "DELCOL", .{}, arg);
            return self;
        }

        pub fn setTip(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TIP", .{}, arg);
            return self;
        }

        pub fn setDragDrop(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "DRAGDROP", .{}, arg);
            return self;
        }

        pub fn setTipDelay(self: Initializer, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "TIPDELAY", .{}, arg);
            return self;
        }

        pub fn setToggleValue(self: Initializer, index: i32, arg: ?ToggleValue) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .On => interop.setStrAttribute(self.ref, "TOGGLEVALUE", .{index}, "ON"),
                .Off => interop.setStrAttribute(self.ref, "TOGGLEVALUE", .{index}, "OFF"),
                .NotDef => interop.setStrAttribute(self.ref, "TOGGLEVALUE", .{index}, "NOTDEF"),
            } else {
                interop.clearAttribute(self.ref, "TOGGLEVALUE", .{index});
            }
            return self;
        }

        pub fn copyLin(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "COPYLIN", .{index}, arg);
            return self;
        }

        pub fn setNumColVisible(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMCOL_VISIBLE", .{}, arg);
            return self;
        }

        pub fn setSbImageRight(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGERIGHT", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageRightHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGERIGHT", .{}, arg);
            return self;
        }

        pub fn setNumEricFormatTitle(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMERICFORMATTITLE", .{index}, arg);
            return self;
        }

        pub fn setSbImageLeftInactive(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGELEFTINACTIVE", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageLeftInactiveHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGELEFTINACTIVE", .{}, arg);
            return self;
        }

        pub fn setMarkMultiple(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "MARKMULTIPLE", .{}, arg);
            return self;
        }

        pub fn setFloating(self: Initializer, arg: ?Floating) Initializer {
            if (self.last_error) |_| return self;
            if (arg) |value| switch (value) {
                .Yes => interop.setStrAttribute(self.ref, "FLOATING", .{}, "YES"),
                .Ignore => interop.setStrAttribute(self.ref, "FLOATING", .{}, "IGNORE"),
                .No => interop.setStrAttribute(self.ref, "FLOATING", .{}, "NO"),
            } else {
                interop.clearAttribute(self.ref, "FLOATING", .{});
            }
            return self;
        }

        pub fn setNumEricFormat(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMERICFORMAT", .{index}, arg);
            return self;
        }

        pub fn setWidth(self: Initializer, index: i32, arg: i32) Initializer {
            if (self.last_error) |_| return self;
            interop.setIntAttribute(self.ref, "WIDTH", .{index}, arg);
            return self;
        }

        pub fn setTouch(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "TOUCH", .{}, arg);
            return self;
        }

        pub fn setName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NAME", .{}, arg);
            return self;
        }

        pub fn setReadonly(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "READONLY", .{}, arg);
            return self;
        }

        pub fn setNumLinVisible(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "NUMLIN_VISIBLE", .{}, arg);
            return self;
        }

        pub fn setPropagateFocus(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "PROPAGATEFOCUS", .{}, arg);
            return self;
        }

        pub fn setBackingStore(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "BACKINGSTORE", .{}, arg);
            return self;
        }

        pub fn setSbImageBottomPress(self: Initializer, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "SB_IMAGEBOTTOMPRESS", .{}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setSbImageBottomPressHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "SB_IMAGEBOTTOMPRESS", .{}, arg);
            return self;
        }

        pub fn setMdiClient(self: Initializer, arg: bool) Initializer {
            if (self.last_error) |_| return self;
            interop.setBoolAttribute(self.ref, "MDICLIENT", .{}, arg);
            return self;
        }

        pub fn setMdiMenu(self: Initializer, arg: *iup.Menu) Initializer {
            if (self.last_error) |_| return self;
            interop.setHandleAttribute(self.ref, "MDIMENU", .{}, arg);
            return self;
        }

        pub fn setMdiMenuHandleName(self: Initializer, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "MDIMENU", .{}, arg);
            return self;
        }

        ///
        /// TABIMAGEn (non inheritable): image name to be used in the respective tab.
        /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
        /// n starts at 0.
        /// See also IupImage.
        /// In Motif, the image is shown only if TABTITLEn is NULL.
        /// In Windows and Motif set the BGCOLOR attribute before setting the image.
        /// When set after map will update the TABIMAGE attribute on the respective
        /// child (since 3.10).
        /// (since 3.0).
        /// TABIMAGE (non inheritable) (at children only): Same as TABIMAGEn but set in
        /// each child.
        /// Works only if set before the child is added to the tabs.
        pub fn setTabImage(self: Initializer, index: i32, arg: anytype) Initializer {
            if (self.last_error) |_| return self;
            if (interop.validateHandle(.Image, arg)) {
                interop.setHandleAttribute(self.ref, "TABIMAGE", .{index}, arg);
            } else |err| {
                self.last_error = err;
            }
            return self;
        }

        pub fn setTabImageHandleName(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TABIMAGE", .{index}, arg);
            return self;
        }

        ///
        /// TABTITLEn (non inheritable): Contains the text to be shown in the
        /// respective tab title.
        /// n starts at 0.
        /// If this value is NULL, it will remain empty.
        /// The "&" character can be used to define a mnemonic, the next character will
        /// be used as key.
        /// Use "&&" to show the "&" character instead on defining a mnemonic.
        /// The button can be activated from any control in the dialog using the
        /// "Alt+key" combination.
        /// (mnemonic support since 3.3).
        /// When set after map will update the TABTITLE attribute on the respective
        /// child (since 3.10).
        /// (since 3.0).
        /// TABTITLE (non inheritable) (at children only): Same as TABTITLEn but set in
        /// each child.
        /// Works only if set before the child is added to the tabs.
        pub fn setTabTitle(self: Initializer, index: i32, arg: [:0]const u8) Initializer {
            if (self.last_error) |_| return self;
            interop.setStrAttribute(self.ref, "TABTITLE", .{index}, arg);
            return self;
        }

        pub fn setColResizeCallback(self: Initializer, callback: ?*const OnColResizeFn) Initializer {
            const Handler = CallbackHandler(Self, OnColResizeFn, "COLRESIZE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setWheelCallback(self: Initializer, callback: ?*const OnWheelFn) Initializer {
            const Handler = CallbackHandler(Self, OnWheelFn, "WHEEL_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setEditMouseMoveCallback(self: Initializer, callback: ?*const OnEditMouseMoveFn) Initializer {
            const Handler = CallbackHandler(Self, OnEditMouseMoveFn, "EDITMOUSEMOVE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDropCheckCallback(self: Initializer, callback: ?*const OnDropCheckFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropCheckFn, "DROPCHECK_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDestroyCallback(self: Initializer, callback: ?*const OnDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setNumEricSetValueCallback(self: Initializer, callback: ?*const OnNumEricSetValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnNumEricSetValueFn, "NUMERICSETVALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setKillFocusCallback(self: Initializer, callback: ?*const OnKillFocusFn) Initializer {
            const Handler = CallbackHandler(Self, OnKillFocusFn, "KILLFOCUS_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setMotionCallback(self: Initializer, callback: ?*const OnMotionFn) Initializer {
            const Handler = CallbackHandler(Self, OnMotionFn, "MOTION_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDragEndCallback(self: Initializer, callback: ?*const OnDragEndFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragEndFn, "DRAGEND_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setSortColUmncompareCallback(self: Initializer, callback: ?*const OnSortColUmncompareFn) Initializer {
            const Handler = CallbackHandler(Self, OnSortColUmncompareFn, "SORTCOLUMNCOMPARE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setPostMessageCallback(self: Initializer, callback: ?*const OnPostMessageFn) Initializer {
            const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setTranslateValueCallback(self: Initializer, callback: ?*const OnTranslateValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnTranslateValueFn, "TRANSLATEVALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setScrollCallback(self: Initializer, callback: ?*const OnScrollFn) Initializer {
            const Handler = CallbackHandler(Self, OnScrollFn, "SCROLL_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setMouseMoveCallback(self: Initializer, callback: ?*const OnMouseMoveFn) Initializer {
            const Handler = CallbackHandler(Self, OnMouseMoveFn, "MOUSEMOVE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setActionCallback(self: Initializer, callback: ?*const OnActionFn) Initializer {
            const Handler = CallbackHandler(Self, OnActionFn, "ACTION_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setWomCallback(self: Initializer, callback: ?*const OnWomFn) Initializer {
            const Handler = CallbackHandler(Self, OnWomFn, "WOM_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDropDataCallback(self: Initializer, callback: ?*const OnDropDataFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropDataFn, "DROPDATA_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setKAnyCallback(self: Initializer, callback: ?*const OnKAnyFn) Initializer {
            const Handler = CallbackHandler(Self, OnKAnyFn, "K_ANY");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setScrollTopCallback(self: Initializer, callback: ?*const OnScrollTopFn) Initializer {
            const Handler = CallbackHandler(Self, OnScrollTopFn, "SCROLLTOP_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDropCallback(self: Initializer, callback: ?*const OnDropFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropFn, "DROP_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setMarkCallback(self: Initializer, callback: ?*const OnMarkFn) Initializer {
            const Handler = CallbackHandler(Self, OnMarkFn, "MARK_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setEnterItemCallback(self: Initializer, callback: ?*const OnEnterItemFn) Initializer {
            const Handler = CallbackHandler(Self, OnEnterItemFn, "ENTERITEM_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setUnmapCallback(self: Initializer, callback: ?*const OnUnmapFn) Initializer {
            const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setEnterWindowCallback(self: Initializer, callback: ?*const OnEnterWindowFn) Initializer {
            const Handler = CallbackHandler(Self, OnEnterWindowFn, "ENTERWINDOW_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setLeaveWindowCallback(self: Initializer, callback: ?*const OnLeaveWindowFn) Initializer {
            const Handler = CallbackHandler(Self, OnLeaveWindowFn, "LEAVEWINDOW_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setClickCallback(self: Initializer, callback: ?*const OnClickFn) Initializer {
            const Handler = CallbackHandler(Self, OnClickFn, "CLICK_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setMarkedItCallback(self: Initializer, callback: ?*const OnMarkedItFn) Initializer {
            const Handler = CallbackHandler(Self, OnMarkedItFn, "MARKEDIT_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDragBeginCallback(self: Initializer, callback: ?*const OnDragBeginFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragBeginFn, "DRAGBEGIN_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setTypeCallback(self: Initializer, callback: ?*const OnTypeFn) Initializer {
            const Handler = CallbackHandler(Self, OnTypeFn, "TYPE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDragDataSizeCallback(self: Initializer, callback: ?*const OnDragDataSizeFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragDataSizeFn, "DRAGDATASIZE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setEditReleaseCallback(self: Initializer, callback: ?*const OnEditReleaseFn) Initializer {
            const Handler = CallbackHandler(Self, OnEditReleaseFn, "EDITRELEASE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setLDestroyCallback(self: Initializer, callback: ?*const OnLDestroyFn) Initializer {
            const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setCanvasActionCallback(self: Initializer, callback: ?*const OnCanvasActionFn) Initializer {
            const Handler = CallbackHandler(Self, OnCanvasActionFn, "ACTION");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setEditClickCallback(self: Initializer, callback: ?*const OnEditClickFn) Initializer {
            const Handler = CallbackHandler(Self, OnEditClickFn, "EDITCLICK_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setValueEditCallback(self: Initializer, callback: ?*const OnValueEditFn) Initializer {
            const Handler = CallbackHandler(Self, OnValueEditFn, "VALUE_EDIT_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setFontCallback(self: Initializer, callback: ?*const OnFontFn) Initializer {
            const Handler = CallbackHandler(Self, OnFontFn, "FONT_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDropMotionCallback(self: Initializer, callback: ?*const OnDropMotionFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropMotionFn, "DROPMOTION_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setKeyPressCallback(self: Initializer, callback: ?*const OnKeyPressFn) Initializer {
            const Handler = CallbackHandler(Self, OnKeyPressFn, "KEYPRESS_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setToggleValueCallback(self: Initializer, callback: ?*const OnToggleValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnToggleValueFn, "TOGGLEVALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setResizeCallback(self: Initializer, callback: ?*const OnResizeFn) Initializer {
            const Handler = CallbackHandler(Self, OnResizeFn, "RESIZE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setGetFocusCallback(self: Initializer, callback: ?*const OnGetFocusFn) Initializer {
            const Handler = CallbackHandler(Self, OnGetFocusFn, "GETFOCUS_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setHelpCallback(self: Initializer, callback: ?*const OnHelpFn) Initializer {
            const Handler = CallbackHandler(Self, OnHelpFn, "HELP_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setFocusCallback(self: Initializer, callback: ?*const OnFocusFn) Initializer {
            const Handler = CallbackHandler(Self, OnFocusFn, "FOCUS_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDropSelectCallback(self: Initializer, callback: ?*const OnDropSelectFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropSelectFn, "DROPSELECT_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDropFilesCallback(self: Initializer, callback: ?*const OnDropFilesFn) Initializer {
            const Handler = CallbackHandler(Self, OnDropFilesFn, "DROPFILES_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setEditIOnCallback(self: Initializer, callback: ?*const OnEditIOnFn) Initializer {
            const Handler = CallbackHandler(Self, OnEditIOnFn, "EDITION_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setMenuDropCallback(self: Initializer, callback: ?*const OnMenuDropFn) Initializer {
            const Handler = CallbackHandler(Self, OnMenuDropFn, "MENUDROP_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDrawCallback(self: Initializer, callback: ?*const OnDrawFn) Initializer {
            const Handler = CallbackHandler(Self, OnDrawFn, "DRAW_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setValueCallback(self: Initializer, callback: ?*const OnValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnValueFn, "VALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setValueChangedCallback(self: Initializer, callback: ?*const OnValueChangedFn) Initializer {
            const Handler = CallbackHandler(Self, OnValueChangedFn, "VALUECHANGED_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setReleaseCallback(self: Initializer, callback: ?*const OnReleaseFn) Initializer {
            const Handler = CallbackHandler(Self, OnReleaseFn, "RELEASE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setDragDataCallback(self: Initializer, callback: ?*const OnDragDataFn) Initializer {
            const Handler = CallbackHandler(Self, OnDragDataFn, "DRAGDATA_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setButtonCallback(self: Initializer, callback: ?*const OnButtonFn) Initializer {
            const Handler = CallbackHandler(Self, OnButtonFn, "BUTTON_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setMapCallback(self: Initializer, callback: ?*const OnMapFn) Initializer {
            const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setFgColorCallback(self: Initializer, callback: ?*const OnFgColorFn) Initializer {
            const Handler = CallbackHandler(Self, OnFgColorFn, "FGCOLOR_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setNumEricGetValueCallback(self: Initializer, callback: ?*const OnNumEricGetValueFn) Initializer {
            const Handler = CallbackHandler(Self, OnNumEricGetValueFn, "NUMERICGETVALUE_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setBgColorCallback(self: Initializer, callback: ?*const OnBgColorFn) Initializer {
            const Handler = CallbackHandler(Self, OnBgColorFn, "BGCOLOR_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setLeaveItemCallback(self: Initializer, callback: ?*const OnLeaveItemFn) Initializer {
            const Handler = CallbackHandler(Self, OnLeaveItemFn, "LEAVEITEM_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }

        pub fn setResizeMatrixCallback(self: Initializer, callback: ?*const OnResizeMatrixFn) Initializer {
            const Handler = CallbackHandler(Self, OnResizeMatrixFn, "RESIZEMATRIX_CB");
            Handler.setCallback(self.ref, callback);
            return self;
        }
    };

    pub fn setStrAttribute(self: *Self, attribute: [:0]const u8, arg: [:0]const u8) void {
        interop.setStrAttribute(self, attribute, .{}, arg);
    }

    pub fn getStrAttribute(self: *Self, attribute: [:0]const u8) [:0]const u8 {
        return interop.getStrAttribute(self, attribute, .{});
    }

    pub fn setIntAttribute(self: *Self, attribute: [:0]const u8, arg: i32) void {
        interop.setIntAttribute(self, attribute, .{}, arg);
    }

    pub fn getIntAttribute(self: *Self, attribute: [:0]const u8) i32 {
        return interop.getIntAttribute(self, attribute, .{});
    }

    pub fn setBoolAttribute(self: *Self, attribute: [:0]const u8, arg: bool) void {
        interop.setBoolAttribute(self, attribute, .{}, arg);
    }

    pub fn getBoolAttribute(self: *Self, attribute: [:0]const u8) bool {
        return interop.getBoolAttribute(self, attribute, .{});
    }

    pub fn getPtrAttribute(self: *Self, comptime T: type, attribute: [:0]const u8) ?*T {
        return interop.getPtrAttribute(T, self, attribute, .{});
    }

    pub fn setPtrAttribute(self: *Self, comptime T: type, attribute: [:0]const u8, value: ?*T) void {
        interop.setPtrAttribute(T, self, attribute, .{}, value);
    }

    pub fn setHandle(self: *Self, arg: [:0]const u8) void {
        interop.setHandle(self, arg);
    }

    pub fn fromHandleName(handle_name: [:0]const u8) ?*Self {
        return interop.fromHandleName(Self, handle_name);
    }

    pub fn postMessage(self: *Self, s: [:0]const u8, i: i32, f: f64, p: ?*anyopaque) void {
        return interop.postMessage(self, s, i, f, p);
    }

    ///
    /// Creates an interface element given its class name and parameters.
    /// After creation the element still needs to be attached to a container and mapped to the native system so it can be visible.
    pub fn init() Initializer {
        var handle = interop.create(Self);

        if (handle) |valid| {
            return .{
                .ref = @ptrCast(valid),
            };
        } else {
            return .{ .ref = undefined, .last_error = Error.NotInitialized };
        }
    }

    ///
    /// Destroys an interface element and all its children.
    /// Only dialogs, timers, popup menus and images should be normally destroyed, but detached elements can also be destroyed.
    pub fn deinit(self: *Self) void {
        interop.destroy(self);
    }

    ///
    /// Creates (maps) the native interface objects corresponding to the given IUP interface elements.
    /// It will also called recursively to create the native element of all the children in the element's tree.
    /// The element must be already attached to a mapped container, except the dialog. A child can only be mapped if its parent is already mapped.
    /// This function is automatically called before the dialog is shown in IupShow, IupShowXY or IupPopup.
    /// If the element is a dialog then the abstract layout will be updated even if the dialog is already mapped. If the dialog is visible the elements will be immediately repositioned. Calling IupMap for an already mapped dialog is the same as only calling IupRefresh for the dialog.
    /// Calling IupMap for an already mapped element that is not a dialog does nothing.
    /// If you add new elements to an already mapped dialog you must call IupMap for that elements. And then call IupRefresh to update the dialog layout.
    /// If the WID attribute of an element is NULL, it means the element was not already mapped. Some containers do not have a native element associated, like VBOX and HBOX. In this case their WID is a fake value (void*)(-1).
    /// It is useful for the application to call IupMap when the value of the WID attribute must be known, i.e. the native element must exist, before a dialog is made visible.
    /// The MAP_CB callback is called at the end of the IupMap function, after all processing, so it can also be used to create other things that depend on the WID attribute. But notice that for non dialog elements it will be called before the dialog layout has been updated, so the element current size will still be 0x0 (since 3.14).
    pub fn map(self: *Self) !void {
        try interop.map(self);
    }

    ///
    ///
    pub fn getDialog(self: *Self) ?*iup.Dialog {
        return interop.getDialog(self);
    }

    ///
    /// Returns the the child element that has the NAME attribute equals to the given value on the same dialog hierarchy.
    /// Works also for children of a menu that is associated with a dialog.
    pub fn getDialogChild(self: *Self, byName: [:0]const u8) ?Element {
        return interop.getDialogChild(self, byName);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog.
    /// To be used after changing size attributes, or attributes that affect the size of the control. Can be used for any element inside a dialog, but the layout of the dialog and all controls will be updated. It can change the layout of all the controls inside the dialog because of the dynamic layout positioning.
    pub fn refresh(self: *Self) void {
        Impl(Self).refresh(self);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog.
    pub fn update(self: *Self) void {
        Impl(Self).update(self);
    }

    ///
    /// Updates the size and layout of all controls in the same dialog.
    pub fn updateChildren(self: *Self) void {
        Impl(Self).updateChildren(self);
    }

    ///
    /// Force the element and its children to be redrawn immediately.
    pub fn redraw(self: *Self, redraw_children: bool) void {
        Impl(Self).redraw(self, redraw_children);
    }

    pub fn getIntId(self: *Self, attribute: [:0]const u8, index: i32) i32 {
        return interop.getIntAttribute(self, attribute, .{index});
    }

    pub fn setIntId(self: *Self, attribute: [:0]const u8, index: i32, value: i32) void {
        interop.setIntAttribute(self, attribute, .{index}, value);
    }

    pub fn getFloatId(self: *Self, attribute: [:0]const u8, index: i32) f32 {
        return interop.getFloatAttribute(self, attribute, .{index});
    }

    pub fn setFloatId(self: *Self, attribute: [:0]const u8, index: i32, value: f32) void {
        interop.setFloatAttribute(self, attribute, .{index}, value);
    }

    pub fn getDoubleId(self: *Self, attribute: [:0]const u8, index: i32) f64 {
        return interop.getDoubleAttribute(self, attribute, .{index});
    }

    pub fn setDoubleId(self: *Self, attribute: [:0]const u8, index: i32, value: f64) void {
        interop.setFloatAttribute(self, attribute, .{index}, value);
    }

    pub fn getStrId(self: *Self, attribute: [:0]const u8, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, attribute, .{index});
    }

    pub fn setStrId(self: *Self, attribute: [:0]const u8, index: i32, value: [:0]const u8) void {
        interop.setStrAttribute(self, attribute, .{index}, value);
    }

    pub fn getPtrId(self: *Self, comptime T: type, attribute: [:0]const u8, index: i32) ?*T {
        return interop.getPtrAttribute(type, self, attribute, .{index});
    }

    pub fn setPtrId(self: *Self, comptime T: type, attribute: [:0]const u8, index: i32, value: ?*T) void {
        interop.setPtrAttribute(type, self, attribute, .{index}, value);
    }

    pub fn getDrawTextLayoutCenter(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWTEXTLAYOUTCENTER", .{});
    }

    pub fn setDrawTextLayoutCenter(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWTEXTLAYOUTCENTER", .{}, arg);
    }

    pub fn getDragTypes(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "DRAGTYPES", .{});
    }

    pub fn setDragTypes(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DRAGTYPES", .{}, arg);
    }

    pub fn getHiddenTextMarks(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HIDDENTEXTMARKS", .{});
    }

    pub fn setHiddenTextMarks(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HIDDENTEXTMARKS", .{}, arg);
    }

    pub fn getXMax(self: *Self) i32 {
        return interop.getIntAttribute(self, "XMAX", .{});
    }

    pub fn setXMax(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "XMAX", .{}, arg);
    }

    pub fn getFrameVertColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMEVERTCOLOR", .{index});
    }

    pub fn setFrameVertColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMEVERTCOLOR", .{index}, arg);
    }

    pub fn getAlign(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "ALIGN", .{index});
    }

    pub fn setAlign(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ALIGN", .{index}, arg);
    }

    pub fn getSortColUmnInterval(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTCOLUMNINTERVAL", .{});
    }

    pub fn getSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "SIZE", .{});
        return Size.parse(str);
    }

    pub fn setSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "SIZE", .{}, value);
    }

    pub fn getScreenPosition(self: *Self) iup.XYPos {
        var str = interop.getStrAttribute(self, "SCREENPOSITION", .{});
        return iup.XYPos.parse(str, ',');
    }

    pub fn addCol(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ADDCOL", .{}, arg);
    }

    pub fn getX(self: *Self) i32 {
        return interop.getIntAttribute(self, "X", .{});
    }

    pub fn getY(self: *Self) i32 {
        return interop.getIntAttribute(self, "Y", .{});
    }

    pub fn getFrameHorizColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMEHORIZCOLOR", .{index});
    }

    pub fn setFrameHorizColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMEHORIZCOLOR", .{index}, arg);
    }

    pub fn getValue(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "VALUE", .{});
    }

    pub fn setValue(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "VALUE", .{}, arg);
    }

    pub fn getNumEricFormatPrecision(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFORMATPRECISION", .{index});
    }

    pub fn setNumEricFormatPrecision(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICFORMATPRECISION", .{index}, arg);
    }

    pub fn getMergedend(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MERGEDEND", .{index});
    }

    pub fn getType(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "TYPE", .{index});
    }

    pub fn setType(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TYPE", .{index}, arg);
    }

    pub fn getSortImageDown(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTIMAGEDOWN", .{});
    }

    pub fn setSortImageDown(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTIMAGEDOWN", .{}, arg);
    }

    pub fn moveCol(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MOVECOL", .{index}, arg);
    }

    pub fn getTipFgColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "TIPFGCOLOR", .{});
    }

    pub fn setTipFgColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "TIPFGCOLOR", .{}, rgb);
    }

    pub fn getNumEricDecimalSymbol(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICDECIMALSYMBOL", .{});
    }

    pub fn setNumEricDecimalSymbol(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICDECIMALSYMBOL", .{}, arg);
    }

    pub fn getExpand(self: *Self) ?Expand {
        var ret = interop.getStrAttribute(self, "EXPAND", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("HORIZONTAL", ret)) return .Horizontal;
        if (std.ascii.eqlIgnoreCase("VERTICAL", ret)) return .Vertical;
        if (std.ascii.eqlIgnoreCase("HORIZONTALFREE", ret)) return .HorizontalFree;
        if (std.ascii.eqlIgnoreCase("VERTICALFREE", ret)) return .VerticalFree;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }

    pub fn setExpand(self: *Self, arg: ?Expand) void {
        if (arg) |value| switch (value) {
            .Yes => interop.setStrAttribute(self, "EXPAND", .{}, "YES"),
            .Horizontal => interop.setStrAttribute(self, "EXPAND", .{}, "HORIZONTAL"),
            .Vertical => interop.setStrAttribute(self, "EXPAND", .{}, "VERTICAL"),
            .HorizontalFree => interop.setStrAttribute(self, "EXPAND", .{}, "HORIZONTALFREE"),
            .VerticalFree => interop.setStrAttribute(self, "EXPAND", .{}, "VERTICALFREE"),
            .No => interop.setStrAttribute(self, "EXPAND", .{}, "NO"),
        } else {
            interop.clearAttribute(self, "EXPAND", .{});
        }
    }

    pub fn getDrawTextOrientation(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "DRAWTEXTORIENTATION", .{});
    }

    pub fn setDrawTextOrientation(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "DRAWTEXTORIENTATION", .{}, arg);
    }

    pub fn getArea(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "AREA", .{});
    }

    pub fn setArea(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "AREA", .{}, arg);
    }

    pub fn getMerged(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MERGED", .{index});
    }

    pub fn setMerged(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MERGED", .{index}, arg);
    }

    pub fn getSortLineIndex(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTLINEINDEX", .{index});
    }

    pub fn getDrawTextAlignment(self: *Self) ?DrawTextAlignment {
        var ret = interop.getStrAttribute(self, "DRAWTEXTALIGNMENT", .{});

        if (std.ascii.eqlIgnoreCase("ACENTER", ret)) return .ACenter;
        if (std.ascii.eqlIgnoreCase("ARIGHT", ret)) return .ARight;
        if (std.ascii.eqlIgnoreCase("ALEFT", ret)) return .ALeft;
        return null;
    }

    pub fn setDrawTextAlignment(self: *Self, arg: ?DrawTextAlignment) void {
        if (arg) |value| switch (value) {
            .ACenter => interop.setStrAttribute(self, "DRAWTEXTALIGNMENT", .{}, "ACENTER"),
            .ARight => interop.setStrAttribute(self, "DRAWTEXTALIGNMENT", .{}, "ARIGHT"),
            .ALeft => interop.setStrAttribute(self, "DRAWTEXTALIGNMENT", .{}, "ALEFT"),
        } else {
            interop.clearAttribute(self, "DRAWTEXTALIGNMENT", .{});
        }
    }

    pub fn getDragSource(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAGSOURCE", .{});
    }

    pub fn setDragSource(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAGSOURCE", .{}, arg);
    }

    pub fn getDrawColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "DRAWCOLOR", .{});
    }

    pub fn setDrawColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "DRAWCOLOR", .{}, rgb);
    }

    pub fn getArrowImages(self: *Self) i32 {
        return interop.getIntAttribute(self, "ARROWIMAGES", .{});
    }

    pub fn setArrowImages(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "ARROWIMAGES", .{}, arg);
    }

    pub fn getOrigInOffset(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "ORIGINOFFSET", .{});
    }

    pub fn setOrigInOffset(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ORIGINOFFSET", .{}, arg);
    }

    pub fn getDrawLineWidth(self: *Self) i32 {
        return interop.getIntAttribute(self, "DRAWLINEWIDTH", .{});
    }

    pub fn setDrawLineWidth(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "DRAWLINEWIDTH", .{}, arg);
    }

    pub fn getCellFont(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLFONT", .{index});
    }

    pub fn getNumColNoScroll(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMCOL_NOSCROLL", .{});
    }

    pub fn setNumColNoScroll(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMCOL_NOSCROLL", .{}, arg);
    }

    pub fn getFitMaxHeight(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FITMAXHEIGHT", .{index});
    }

    pub fn setFitMaxHeight(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FITMAXHEIGHT", .{index}, arg);
    }

    pub fn mergeSplit(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MERGESPLIT", .{}, arg);
    }

    pub fn getUserSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "USERSIZE", .{});
        return Size.parse(str);
    }

    pub fn setUserSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "USERSIZE", .{}, value);
    }

    pub fn getMarked(self: *Self) bool {
        return interop.getBoolAttribute(self, "MARKED", .{});
    }

    pub fn setMarked(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MARKED", .{}, arg);
    }

    pub fn getNumEricFormatDef(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFORMATDEF", .{});
    }

    pub fn setNumEricFormatDef(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICFORMATDEF", .{}, arg);
    }

    pub fn clearValue(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CLEARVALUE", .{index}, arg);
    }

    pub fn getXMin(self: *Self) i32 {
        return interop.getIntAttribute(self, "XMIN", .{});
    }

    pub fn setXMin(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "XMIN", .{}, arg);
    }

    pub fn getDrawTextEllipsis(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWTEXTELLIPSIS", .{});
    }

    pub fn setDrawTextEllipsis(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWTEXTELLIPSIS", .{}, arg);
    }

    pub fn delLin(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DELLIN", .{}, arg);
    }

    pub fn getMaskInt(self: *Self, index: i32) iup.Range {
        var str = interop.getStrAttribute(self, "MASKINT", .{index});
        return iup.Range.parse(str, ',');
    }

    pub fn setMaskInt(self: *Self, index: i32, begin: i32, end: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.Range.intIntToString(&buffer, begin, end, ',');
        interop.setStrAttribute(self, "MASKINT", .{index}, value);
    }

    pub fn getResizeDrag(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "RESIZEDRAG", .{});
    }

    pub fn setResizeDrag(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "RESIZEDRAG", .{}, arg);
    }

    pub fn getNumLinVisibleLast(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMLIN_VISIBLE_LAST", .{});
    }

    pub fn setNumLinVisibleLast(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMLIN_VISIBLE_LAST", .{}, arg);
    }

    pub fn sortColUmn(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTCOLUMN", .{index}, arg);
    }

    pub fn getFrameColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "FRAMECOLOR", .{});
    }

    pub fn setFrameColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "FRAMECOLOR", .{}, rgb);
    }

    pub fn getIdValue(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "IDVALUE", .{index});
    }

    pub fn setIdValue(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "IDVALUE", .{index}, arg);
    }

    pub fn show(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SHOW", .{}, arg);
    }

    pub fn getSbImageBottomInactive(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGEBOTTOMINACTIVE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageBottomInactive(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGEBOTTOMINACTIVE", .{}, arg);
    }

    pub fn setSbImageBottomInactiveHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGEBOTTOMINACTIVE", .{}, arg);
    }

    pub fn getDrawSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "DRAWSIZE", .{});
        return Size.parse(str);
    }

    pub fn getMarkArea(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "MARKAREA", .{});
    }

    pub fn setMarkArea(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MARKAREA", .{}, arg);
    }

    pub fn getFrameTitleHighlight(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMETITLEHIGHLIGHT", .{});
    }

    pub fn setFrameTitleHighlight(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMETITLEHIGHLIGHT", .{}, arg);
    }

    pub fn getSbImageTopPress(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGETOPPRESS", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageTopPress(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGETOPPRESS", .{}, arg);
    }

    pub fn setSbImageTopPressHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGETOPPRESS", .{}, arg);
    }

    pub fn getBorder(self: *Self) bool {
        return interop.getBoolAttribute(self, "BORDER", .{});
    }

    pub fn setBorder(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "BORDER", .{}, arg);
    }

    pub fn getCanFocus(self: *Self) bool {
        return interop.getBoolAttribute(self, "CANFOCUS", .{});
    }

    pub fn setCanFocus(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "CANFOCUS", .{}, arg);
    }

    pub fn getSbImageTop(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGETOP", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageTop(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGETOP", .{}, arg);
    }

    pub fn setSbImageTopHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGETOP", .{}, arg);
    }

    pub fn getToggleImageOff(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TOGGLEIMAGEOFF", .{});
    }

    pub fn setToggleImageOff(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TOGGLEIMAGEOFF", .{}, arg);
    }

    pub fn getMerge(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MERGE", .{index});
    }

    pub fn setMerge(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MERGE", .{index}, arg);
    }

    pub fn getSortSign(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTSIGN", .{index});
    }

    pub fn setSortSign(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTSIGN", .{index}, arg);
    }

    pub fn getSbImageRightInactive(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGERIGHTINACTIVE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageRightInactive(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGERIGHTINACTIVE", .{}, arg);
    }

    pub fn setSbImageRightInactiveHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGERIGHTINACTIVE", .{}, arg);
    }

    pub fn getSortColUmnCaseSensitive(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTCOLUMNCASESENSITIVE", .{});
    }

    pub fn setSortColUmnCaseSensitive(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTCOLUMNCASESENSITIVE", .{}, arg);
    }

    pub fn getToggleImageOn(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TOGGLEIMAGEON", .{});
    }

    pub fn setToggleImageOn(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TOGGLEIMAGEON", .{}, arg);
    }

    pub fn getYAutoHide(self: *Self) bool {
        return interop.getBoolAttribute(self, "YAUTOHIDE", .{});
    }

    pub fn setYAutoHide(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "YAUTOHIDE", .{}, arg);
    }

    pub fn getDrawTextClip(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWTEXTCLIP", .{});
    }

    pub fn setDrawTextClip(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWTEXTCLIP", .{}, arg);
    }

    pub fn getTheme(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "THEME", .{});
    }

    pub fn setTheme(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "THEME", .{}, arg);
    }

    pub fn zOrder(self: *Self, arg: ?ZOrder) void {
        if (arg) |value| switch (value) {
            .Top => interop.setStrAttribute(self, "ZORDER", .{}, "TOP"),
            .Bottom => interop.setStrAttribute(self, "ZORDER", .{}, "BOTTOM"),
        } else {
            interop.clearAttribute(self, "ZORDER", .{});
        }
    }

    pub fn getRasterHeight(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "RASTERHEIGHT", .{index});
    }

    pub fn setRasterHeight(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "RASTERHEIGHT", .{index}, arg);
    }

    pub fn getFocusCell(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FOCUSCELL", .{});
    }

    pub fn setFocusCell(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FOCUSCELL", .{}, arg);
    }

    pub fn getLineAlignment(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "LINEALIGNMENT", .{index});
    }

    pub fn setLineAlignment(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "LINEALIGNMENT", .{index}, arg);
    }

    pub fn getWidthDef(self: *Self) i32 {
        return interop.getIntAttribute(self, "WIDTHDEF", .{});
    }

    pub fn setWidthDef(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "WIDTHDEF", .{}, arg);
    }

    pub fn getRasterWidth(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "RASTERWIDTH", .{index});
    }

    pub fn setRasterWidth(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "RASTERWIDTH", .{index}, arg);
    }

    pub fn getVisible(self: *Self) bool {
        return interop.getBoolAttribute(self, "VISIBLE", .{});
    }

    pub fn setVisible(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "VISIBLE", .{}, arg);
    }

    pub fn getNumLinNoScroll(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMLIN_NOSCROLL", .{});
    }

    pub fn setNumLinNoScroll(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMLIN_NOSCROLL", .{}, arg);
    }

    pub fn getBgColor(self: *Self, index: i32) ?iup.Rgb {
        return interop.getRgb(self, "BGCOLOR", .{index});
    }

    pub fn setBgColor(self: *Self, index: i32, rgb: iup.Rgb) void {
        interop.setRgb(self, "BGCOLOR", .{index}, rgb);
    }

    pub fn addLin(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ADDLIN", .{}, arg);
    }

    pub fn getRasterSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "RASTERSIZE", .{});
        return Size.parse(str);
    }

    pub fn setRasterSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "RASTERSIZE", .{}, value);
    }

    pub fn getDrawStyle(self: *Self) ?DrawStyle {
        var ret = interop.getStrAttribute(self, "DRAWSTYLE", .{});

        if (std.ascii.eqlIgnoreCase("FILL", ret)) return .Fill;
        if (std.ascii.eqlIgnoreCase("STROKE_DASH", ret)) return .StrokeDash;
        if (std.ascii.eqlIgnoreCase("STROKE_DOT", ret)) return .StrokeDot;
        if (std.ascii.eqlIgnoreCase("STROKE_DASH_DOT", ret)) return .StrokeDashDot;
        if (std.ascii.eqlIgnoreCase("STROKE_DASH_DOT_DOT", ret)) return .StrokeDashDotdot;
        if (std.ascii.eqlIgnoreCase("DRAW_STROKE", ret)) return .DrawStroke;
        return null;
    }

    pub fn setDrawStyle(self: *Self, arg: ?DrawStyle) void {
        if (arg) |value| switch (value) {
            .Fill => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "FILL"),
            .StrokeDash => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "STROKE_DASH"),
            .StrokeDot => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "STROKE_DOT"),
            .StrokeDashDot => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "STROKE_DASH_DOT"),
            .StrokeDashDotdot => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "STROKE_DASH_DOT_DOT"),
            .DrawStroke => interop.setStrAttribute(self, "DRAWSTYLE", .{}, "DRAW_STROKE"),
        } else {
            interop.clearAttribute(self, "DRAWSTYLE", .{});
        }
    }

    pub fn getShowFillValue(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SHOWFILLVALUE", .{});
    }

    pub fn setShowFillValue(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SHOWFILLVALUE", .{}, arg);
    }

    pub fn getDropTarget(self: *Self) bool {
        return interop.getBoolAttribute(self, "DROPTARGET", .{});
    }

    pub fn setDropTarget(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DROPTARGET", .{}, arg);
    }

    pub fn getMaskNoEmpty(self: *Self, index: i32) bool {
        return interop.getBoolAttribute(self, "MASKNOEMPTY", .{index});
    }

    pub fn setMaskNoEmpty(self: *Self, index: i32, arg: bool) void {
        interop.setBoolAttribute(self, "MASKNOEMPTY", .{index}, arg);
    }

    pub fn getHideFocus(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HIDEFOCUS", .{});
    }

    pub fn setHideFocus(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HIDEFOCUS", .{}, arg);
    }

    pub fn getCharSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "CHARSIZE", .{});
        return Size.parse(str);
    }

    pub fn getNumCol(self: *Self) i32 {
        return interop.getIntAttribute(self, "NUMCOL", .{});
    }

    pub fn setNumCol(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "NUMCOL", .{}, arg);
    }

    pub fn moveLin(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MOVELIN", .{index}, arg);
    }

    pub fn getSortColUmNoRder(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTCOLUMNORDER", .{});
    }

    pub fn setSortColUmNoRder(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTCOLUMNORDER", .{}, arg);
    }

    pub fn getSbImageBottom(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGEBOTTOM", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageBottom(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGEBOTTOM", .{}, arg);
    }

    pub fn setSbImageBottomHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGEBOTTOM", .{}, arg);
    }

    pub fn getUndoRedo(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "UNDOREDO", .{});
    }

    pub fn setUndoRedo(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "UNDOREDO", .{}, arg);
    }

    pub fn getDrawMakeInactive(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWMAKEINACTIVE", .{});
    }

    pub fn setDrawMakeInactive(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWMAKEINACTIVE", .{}, arg);
    }

    pub fn getDX(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "DX", .{});
    }

    pub fn setDX(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "DX", .{}, arg);
    }

    pub fn getDY(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "DY", .{});
    }

    pub fn setDY(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "DY", .{}, arg);
    }

    pub fn getCellFgColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLFGCOLOR", .{index});
    }

    pub fn getTypeColorInactive(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TYPECOLORINACTIVE", .{});
    }

    pub fn setTypeColorInactive(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TYPECOLORINACTIVE", .{}, arg);
    }

    pub fn getMultiline(self: *Self) bool {
        return interop.getBoolAttribute(self, "MULTILINE", .{});
    }

    pub fn setMultiline(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MULTILINE", .{}, arg);
    }

    pub fn getCellFrameVertColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLFRAMEVERTCOLOR", .{index});
    }

    pub fn setCellFrameVertColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CELLFRAMEVERTCOLOR", .{index}, arg);
    }

    pub fn getCaret(self: *Self) iup.LinColPos {
        var str = interop.getStrAttribute(self, "CARET", .{});
        return iup.LinColPos.parse(str, ',');
    }

    pub fn setCaret(self: *Self, lin: i32, col: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.LinColPos.intIntToString(&buffer, lin, col, ',');
        interop.setStrAttribute(self, "CARET", .{}, value);
    }

    pub fn getNumColVisibleLast(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMCOL_VISIBLE_LAST", .{});
    }

    pub fn setNumColVisibleLast(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMCOL_VISIBLE_LAST", .{}, arg);
    }

    pub fn getPosition(self: *Self) iup.XYPos {
        var str = interop.getStrAttribute(self, "POSITION", .{});
        return iup.XYPos.parse(str, ',');
    }

    pub fn setPosition(self: *Self, x: i32, y: i32) void {
        var buffer: [128]u8 = undefined;
        var value = iup.XYPos.intIntToString(&buffer, x, y, ',');
        interop.setStrAttribute(self, "POSITION", .{}, value);
    }

    pub fn getMinSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "MINSIZE", .{});
        return Size.parse(str);
    }

    pub fn setMinSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "MINSIZE", .{}, value);
    }

    pub fn getMinColWidthDef(self: *Self) i32 {
        return interop.getIntAttribute(self, "MINCOLWIDTHDEF", .{});
    }

    pub fn setMinColWidthDef(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "MINCOLWIDTHDEF", .{}, arg);
    }

    pub fn getEditText(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITTEXT", .{});
    }

    pub fn getLastSortColUmn(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "LASTSORTCOLUMN", .{});
    }

    pub fn getResizeMatrixColor(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "RESIZEMATRIXCOLOR", .{});
    }

    pub fn setResizeMatrixColor(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "RESIZEMATRIXCOLOR", .{}, arg);
    }

    pub fn getLineX(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "LINEX", .{});
    }

    pub fn setLineX(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "LINEX", .{}, arg);
    }

    pub fn getNaturalSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "NATURALSIZE", .{});
        return Size.parse(str);
    }

    pub fn getLineY(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "LINEY", .{});
    }

    pub fn setLineY(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "LINEY", .{}, arg);
    }

    pub fn getDropTypes(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "DROPTYPES", .{});
    }

    pub fn setDropTypes(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DROPTYPES", .{}, arg);
    }

    pub fn getHandleName(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "HANDLENAME", .{});
    }

    pub fn setHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "HANDLENAME", .{}, arg);
    }

    pub fn getFontFace(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FONTFACE", .{});
    }

    pub fn setFontFace(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FONTFACE", .{}, arg);
    }

    pub fn getSbImageTopInactive(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGETOPINACTIVE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageTopInactive(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGETOPINACTIVE", .{}, arg);
    }

    pub fn setSbImageTopInactiveHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGETOPINACTIVE", .{}, arg);
    }

    pub fn getMark(self: *Self, index: i32) ?Mark {
        var ret = interop.getStrAttribute(self, "MARK", .{index});

        if (std.ascii.eqlIgnoreCase("BLOCK", ret)) return .BLock;
        if (std.ascii.eqlIgnoreCase("CLEARALL", ret)) return .ClearAll;
        if (std.ascii.eqlIgnoreCase("MARKALL", ret)) return .MarkAll;
        if (std.ascii.eqlIgnoreCase("INVERTALL", ret)) return .InVertAll;
        if (std.ascii.eqlIgnoreCase("INVERT", ret)) return .InVert;
        return null;
    }

    pub fn setMark(self: *Self, index: i32, arg: ?Mark) void {
        if (arg) |value| switch (value) {
            .BLock => interop.setStrAttribute(self, "MARK", .{index}, "BLOCK"),
            .ClearAll => interop.setStrAttribute(self, "MARK", .{index}, "CLEARALL"),
            .MarkAll => interop.setStrAttribute(self, "MARK", .{index}, "MARKALL"),
            .InVertAll => interop.setStrAttribute(self, "MARK", .{index}, "INVERTALL"),
            .InVert => interop.setStrAttribute(self, "MARK", .{index}, "INVERT"),
        } else {
            interop.clearAttribute(self, "MARK", .{index});
        }
    }

    pub fn getEditIng(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITING", .{});
    }

    pub fn getMask(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MASK", .{index});
    }

    pub fn setMask(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MASK", .{index}, arg);
    }

    pub fn getMaxSize(self: *Self) Size {
        var str = interop.getStrAttribute(self, "MAXSIZE", .{});
        return Size.parse(str);
    }

    pub fn setMaxSize(self: *Self, width: ?i32, height: ?i32) void {
        var buffer: [128]u8 = undefined;
        var value = Size.intIntToString(&buffer, width, height);
        interop.setStrAttribute(self, "MAXSIZE", .{}, value);
    }

    pub fn getFlat(self: *Self) bool {
        return interop.getBoolAttribute(self, "FLAT", .{});
    }

    pub fn setFlat(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "FLAT", .{}, arg);
    }

    pub fn getNoScrollAsTitle(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NOSCROLLASTITLE", .{});
    }

    pub fn setNoScrollAsTitle(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NOSCROLLASTITLE", .{}, arg);
    }

    pub fn clearAttrib(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CLEARATTRIB", .{index}, arg);
    }

    pub fn getHeight(self: *Self, index: i32) i32 {
        return interop.getIntAttribute(self, "HEIGHT", .{index});
    }

    pub fn setHeight(self: *Self, index: i32, arg: i32) void {
        interop.setIntAttribute(self, "HEIGHT", .{index}, arg);
    }

    pub fn getFontStyle(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FONTSTYLE", .{index});
    }

    pub fn setFontStyle(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FONTSTYLE", .{index}, arg);
    }

    pub fn getFrameTitleVertColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMETITLEVERTCOLOR", .{index});
    }

    pub fn setFrameTitleVertColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMETITLEVERTCOLOR", .{index}, arg);
    }

    pub fn fitToSize(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FITTOSIZE", .{}, arg);
    }

    pub fn getFont(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FONT", .{index});
    }

    pub fn setFont(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FONT", .{index}, arg);
    }

    pub fn getMultiple(self: *Self) bool {
        return interop.getBoolAttribute(self, "MULTIPLE", .{});
    }

    pub fn setMultiple(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MULTIPLE", .{}, arg);
    }

    pub fn getSbImageRightPress(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGERIGHTPRESS", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageRightPress(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGERIGHTPRESS", .{}, arg);
    }

    pub fn setSbImageRightPressHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGERIGHTPRESS", .{}, arg);
    }

    pub fn getCursor(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "CURSOR", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setCursor(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "CURSOR", .{}, arg);
    }

    pub fn setCursorHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CURSOR", .{}, arg);
    }

    pub fn getMinColWidth(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MINCOLWIDTH", .{index});
    }

    pub fn setMinColWidth(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MINCOLWIDTH", .{index}, arg);
    }

    pub fn getSortImageUp(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "SORTIMAGEUP", .{});
    }

    pub fn setSortImageUp(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SORTIMAGEUP", .{}, arg);
    }

    pub fn getWheelDropFocus(self: *Self) bool {
        return interop.getBoolAttribute(self, "WHEELDROPFOCUS", .{});
    }

    pub fn setWheelDropFocus(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "WHEELDROPFOCUS", .{}, arg);
    }

    pub fn getXHidden(self: *Self) bool {
        return interop.getBoolAttribute(self, "XHIDDEN", .{});
    }

    pub fn getFontSize(self: *Self, index: i32) i32 {
        return interop.getIntAttribute(self, "FONTSIZE", .{index});
    }

    pub fn setFontSize(self: *Self, index: i32, arg: i32) void {
        interop.setIntAttribute(self, "FONTSIZE", .{index}, arg);
    }

    pub fn copyCol(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPYCOL", .{index}, arg);
    }

    pub fn getTipMarkup(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TIPMARKUP", .{});
    }

    pub fn setTipMarkup(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TIPMARKUP", .{}, arg);
    }

    pub fn getSbImageLeftHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGELEFTHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageLeftHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGELEFTHIGHLIGHT", .{}, arg);
    }

    pub fn setSbImageLeftHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGELEFTHIGHLIGHT", .{}, arg);
    }

    pub fn getCellFrameHorizColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLFRAMEHORIZCOLOR", .{index});
    }

    pub fn setCellFrameHorizColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "CELLFRAMEHORIZCOLOR", .{index}, arg);
    }

    pub fn getYMax(self: *Self) i32 {
        return interop.getIntAttribute(self, "YMAX", .{});
    }

    pub fn setYMax(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "YMAX", .{}, arg);
    }

    pub fn getMergedStart(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "MERGEDSTART", .{index});
    }

    pub fn getSbImageLeft(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGELEFT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageLeft(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGELEFT", .{}, arg);
    }

    pub fn setSbImageLeftHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGELEFT", .{}, arg);
    }

    pub fn getNTheme(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NTHEME", .{});
    }

    pub fn setNTheme(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NTHEME", .{}, arg);
    }

    pub fn getFitMaxWidth(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FITMAXWIDTH", .{index});
    }

    pub fn setFitMaxWidth(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FITMAXWIDTH", .{index}, arg);
    }

    pub fn getDragSourceMove(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAGSOURCEMOVE", .{});
    }

    pub fn setDragSourceMove(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAGSOURCEMOVE", .{}, arg);
    }

    pub fn getNumLin(self: *Self) i32 {
        return interop.getIntAttribute(self, "NUMLIN", .{});
    }

    pub fn setNumLin(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "NUMLIN", .{}, arg);
    }

    pub fn getCell(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELL", .{index});
    }

    pub fn getResizeMatrix(self: *Self) bool {
        return interop.getBoolAttribute(self, "RESIZEMATRIX", .{});
    }

    pub fn setResizeMatrix(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "RESIZEMATRIX", .{}, arg);
    }

    pub fn getActive(self: *Self) bool {
        return interop.getBoolAttribute(self, "ACTIVE", .{});
    }

    pub fn setActive(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "ACTIVE", .{}, arg);
    }

    pub fn getSbImageTopHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGETOPHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageTopHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGETOPHIGHLIGHT", .{}, arg);
    }

    pub fn setSbImageTopHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGETOPHIGHLIGHT", .{}, arg);
    }

    pub fn getCellsIZe(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLSIZE", .{index});
    }

    pub fn getFgColor(self: *Self, index: i32) ?iup.Rgb {
        return interop.getRgb(self, "FGCOLOR", .{index});
    }

    pub fn setFgColor(self: *Self, index: i32, rgb: iup.Rgb) void {
        interop.setRgb(self, "FGCOLOR", .{index}, rgb);
    }

    pub fn getHlColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "HLCOLOR", .{});
    }

    pub fn setHlColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "HLCOLOR", .{}, rgb);
    }

    pub fn getTipIcon(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TIPICON", .{});
    }

    pub fn setTipIcon(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TIPICON", .{}, arg);
    }

    pub fn getMaskCasei(self: *Self, index: i32) bool {
        return interop.getBoolAttribute(self, "MASKCASEI", .{index});
    }

    pub fn setMaskCasei(self: *Self, index: i32, arg: bool) void {
        interop.setBoolAttribute(self, "MASKCASEI", .{index}, arg);
    }

    pub fn getWId(self: *Self) i32 {
        return interop.getIntAttribute(self, "WID", .{});
    }

    pub fn getCellType(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLTYPE", .{index});
    }

    pub fn fitToText(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FITTOTEXT", .{}, arg);
    }

    pub fn getLimitExpand(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "LIMITEXPAND", .{});
    }

    pub fn setLimitExpand(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "LIMITEXPAND", .{}, arg);
    }

    pub fn getPosX(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "POSX", .{});
    }

    pub fn setPosX(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "POSX", .{}, arg);
    }

    pub fn getPosY(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "POSY", .{});
    }

    pub fn setPosY(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "POSY", .{}, arg);
    }

    pub fn getNumEricQuantitYIndex(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICQUANTITYINDEX", .{index});
    }

    pub fn setNumEricQuantitYIndex(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICQUANTITYINDEX", .{index}, arg);
    }

    pub fn getXAutoHide(self: *Self) bool {
        return interop.getBoolAttribute(self, "XAUTOHIDE", .{});
    }

    pub fn setXAutoHide(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "XAUTOHIDE", .{}, arg);
    }

    pub fn getTipVisible(self: *Self) bool {
        return interop.getBoolAttribute(self, "TIPVISIBLE", .{});
    }

    pub fn setTipVisible(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "TIPVISIBLE", .{}, arg);
    }

    pub fn getMarkMode(self: *Self) ?MarkMode {
        var ret = interop.getStrAttribute(self, "MARKMODE", .{});

        if (std.ascii.eqlIgnoreCase("SINGLE", ret)) return .SInGle;
        if (std.ascii.eqlIgnoreCase("MULTIPLE", ret)) return .Multiple;
        if (std.ascii.eqlIgnoreCase("CELL", ret)) return .Cell;
        return null;
    }

    pub fn setMarkMode(self: *Self, arg: ?MarkMode) void {
        if (arg) |value| switch (value) {
            .SInGle => interop.setStrAttribute(self, "MARKMODE", .{}, "SINGLE"),
            .Multiple => interop.setStrAttribute(self, "MARKMODE", .{}, "MULTIPLE"),
            .Cell => interop.setStrAttribute(self, "MARKMODE", .{}, "CELL"),
        } else {
            interop.clearAttribute(self, "MARKMODE", .{});
        }
    }

    pub fn getDrawFont(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "DRAWFONT", .{});
    }

    pub fn setDrawFont(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DRAWFONT", .{}, arg);
    }

    pub fn getHeightDef(self: *Self) i32 {
        return interop.getIntAttribute(self, "HEIGHTDEF", .{});
    }

    pub fn setHeightDef(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "HEIGHTDEF", .{}, arg);
    }

    pub fn getExpandWeight(self: *Self) f64 {
        return interop.getDoubleAttribute(self, "EXPANDWEIGHT", .{});
    }

    pub fn setExpandWeight(self: *Self, arg: f64) void {
        interop.setDoubleAttribute(self, "EXPANDWEIGHT", .{}, arg);
    }

    pub fn getTipBgColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "TIPBGCOLOR", .{});
    }

    pub fn setTipBgColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "TIPBGCOLOR", .{}, rgb);
    }

    pub fn getOrigIn(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "ORIGIN", .{});
    }

    pub fn setOrigIn(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ORIGIN", .{}, arg);
    }

    pub fn getDrawBgColor(self: *Self) ?iup.Rgb {
        return interop.getRgb(self, "DRAWBGCOLOR", .{});
    }

    pub fn setDrawBgColor(self: *Self, rgb: iup.Rgb) void {
        interop.setRgb(self, "DRAWBGCOLOR", .{}, rgb);
    }

    pub fn getEditMode(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITMODE", .{});
    }

    pub fn setEditMode(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "EDITMODE", .{}, arg);
    }

    pub fn getEditNext(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITNEXT", .{});
    }

    pub fn setEditNext(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "EDITNEXT", .{}, arg);
    }

    pub fn getYMin(self: *Self) i32 {
        return interop.getIntAttribute(self, "YMIN", .{});
    }

    pub fn setYMin(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "YMIN", .{}, arg);
    }

    pub fn getToggleCenterEd(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TOGGLECENTERED", .{});
    }

    pub fn setToggleCenterEd(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TOGGLECENTERED", .{}, arg);
    }

    pub fn getNormalizerGroup(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NORMALIZERGROUP", .{});
    }

    pub fn setNormalizerGroup(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NORMALIZERGROUP", .{}, arg);
    }

    pub fn getScrollBar(self: *Self) bool {
        return interop.getBoolAttribute(self, "SCROLLBAR", .{});
    }

    pub fn setScrollBar(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "SCROLLBAR", .{}, arg);
    }

    pub fn getUseTitleSize(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "USETITLESIZE", .{});
    }

    pub fn setUseTitleSize(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "USETITLESIZE", .{}, arg);
    }

    pub fn getDropFilesTarget(self: *Self) bool {
        return interop.getBoolAttribute(self, "DROPFILESTARGET", .{});
    }

    pub fn setDropFilesTarget(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DROPFILESTARGET", .{}, arg);
    }

    pub fn getAlignmentLin0(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "ALIGNMENTLIN0", .{});
    }

    pub fn setAlignmentLin0(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "ALIGNMENTLIN0", .{}, arg);
    }

    pub fn getFrameBorder(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMEBORDER", .{});
    }

    pub fn setFrameBorder(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMEBORDER", .{}, arg);
    }

    pub fn getNumEricUnitShowNIndex(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNITSHOWNINDEX", .{index});
    }

    pub fn setNumEricUnitShowNIndex(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITSHOWNINDEX", .{index}, arg);
    }

    pub fn getFrameTitleHorizColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "FRAMETITLEHORIZCOLOR", .{index});
    }

    pub fn setFrameTitleHorizColor(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "FRAMETITLEHORIZCOLOR", .{index}, arg);
    }

    pub fn getMarkAtTitle(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "MARKATTITLE", .{});
    }

    pub fn setMarkAtTitle(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MARKATTITLE", .{}, arg);
    }

    pub fn getEditHideOnFocus(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITHIDEONFOCUS", .{});
    }

    pub fn setEditHideOnFocus(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "EDITHIDEONFOCUS", .{}, arg);
    }

    pub fn getSbImageRightHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGERIGHTHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageRightHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGERIGHTHIGHLIGHT", .{}, arg);
    }

    pub fn setSbImageRightHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGERIGHTHIGHLIGHT", .{}, arg);
    }

    pub fn getEditCell(self: *Self) ?iup.LinColPos {
        if (interop.getNullableStrAttribute(self, "EDITCELL", .{})) |str| {
            return iup.LinColPos.parse(str, ':');
        } else {
            return null;
        }
    }

    pub fn getNumEricUnitIndex(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICUNITINDEX", .{index});
    }

    pub fn setNumEricUnitIndex(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICUNITINDEX", .{index}, arg);
    }

    pub fn getSbImageLeftPress(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGELEFTPRESS", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageLeftPress(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGELEFTPRESS", .{}, arg);
    }

    pub fn setSbImageLeftPressHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGELEFTPRESS", .{}, arg);
    }

    pub fn getHlColorAlpha(self: *Self) i32 {
        return interop.getIntAttribute(self, "HLCOLORALPHA", .{});
    }

    pub fn setHlColorAlpha(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "HLCOLORALPHA", .{}, arg);
    }

    pub fn getSbImageBottomHighlight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGEBOTTOMHIGHLIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageBottomHighlight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGEBOTTOMHIGHLIGHT", .{}, arg);
    }

    pub fn setSbImageBottomHighlightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGEBOTTOMHIGHLIGHT", .{}, arg);
    }

    pub fn getDrawTextWrap(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAWTEXTWRAP", .{});
    }

    pub fn setDrawTextWrap(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAWTEXTWRAP", .{}, arg);
    }

    pub fn getCellAlignment(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLALIGNMENT", .{index});
    }

    pub fn delCol(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "DELCOL", .{}, arg);
    }

    pub fn getCount(self: *Self) i32 {
        return interop.getIntAttribute(self, "COUNT", .{});
    }

    pub fn getTip(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "TIP", .{});
    }

    pub fn setTip(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TIP", .{}, arg);
    }

    pub fn getDragDrop(self: *Self) bool {
        return interop.getBoolAttribute(self, "DRAGDROP", .{});
    }

    pub fn setDragDrop(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "DRAGDROP", .{}, arg);
    }

    pub fn getTipDelay(self: *Self) i32 {
        return interop.getIntAttribute(self, "TIPDELAY", .{});
    }

    pub fn setTipDelay(self: *Self, arg: i32) void {
        interop.setIntAttribute(self, "TIPDELAY", .{}, arg);
    }

    pub fn getToggleValue(self: *Self, index: i32) ?ToggleValue {
        var ret = interop.getStrAttribute(self, "TOGGLEVALUE", .{index});

        if (std.ascii.eqlIgnoreCase("ON", ret)) return .On;
        if (std.ascii.eqlIgnoreCase("OFF", ret)) return .Off;
        if (std.ascii.eqlIgnoreCase("NOTDEF", ret)) return .NotDef;
        return null;
    }

    pub fn setToggleValue(self: *Self, index: i32, arg: ?ToggleValue) void {
        if (arg) |value| switch (value) {
            .On => interop.setStrAttribute(self, "TOGGLEVALUE", .{index}, "ON"),
            .Off => interop.setStrAttribute(self, "TOGGLEVALUE", .{index}, "OFF"),
            .NotDef => interop.setStrAttribute(self, "TOGGLEVALUE", .{index}, "NOTDEF"),
        } else {
            interop.clearAttribute(self, "TOGGLEVALUE", .{index});
        }
    }

    pub fn copyLin(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "COPYLIN", .{index}, arg);
    }

    pub fn getNumColVisible(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMCOL_VISIBLE", .{});
    }

    pub fn setNumColVisible(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMCOL_VISIBLE", .{}, arg);
    }

    pub fn getSbImageRight(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGERIGHT", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageRight(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGERIGHT", .{}, arg);
    }

    pub fn setSbImageRightHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGERIGHT", .{}, arg);
    }

    pub fn getYHidden(self: *Self) bool {
        return interop.getBoolAttribute(self, "YHIDDEN", .{});
    }

    pub fn getCellBgColor(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLBGCOLOR", .{index});
    }

    pub fn getNumEricFormatTitle(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFORMATTITLE", .{index});
    }

    pub fn setNumEricFormatTitle(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICFORMATTITLE", .{index}, arg);
    }

    pub fn getSbImageLeftInactive(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGELEFTINACTIVE", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageLeftInactive(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGELEFTINACTIVE", .{}, arg);
    }

    pub fn setSbImageLeftInactiveHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGELEFTINACTIVE", .{}, arg);
    }

    pub fn getMarkMultiple(self: *Self) bool {
        return interop.getBoolAttribute(self, "MARKMULTIPLE", .{});
    }

    pub fn setMarkMultiple(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MARKMULTIPLE", .{}, arg);
    }

    pub fn getFloating(self: *Self) ?Floating {
        var ret = interop.getStrAttribute(self, "FLOATING", .{});

        if (std.ascii.eqlIgnoreCase("YES", ret)) return .Yes;
        if (std.ascii.eqlIgnoreCase("IGNORE", ret)) return .Ignore;
        if (std.ascii.eqlIgnoreCase("NO", ret)) return .No;
        return null;
    }

    pub fn setFloating(self: *Self, arg: ?Floating) void {
        if (arg) |value| switch (value) {
            .Yes => interop.setStrAttribute(self, "FLOATING", .{}, "YES"),
            .Ignore => interop.setStrAttribute(self, "FLOATING", .{}, "IGNORE"),
            .No => interop.setStrAttribute(self, "FLOATING", .{}, "NO"),
        } else {
            interop.clearAttribute(self, "FLOATING", .{});
        }
    }

    pub fn getNumEricFormat(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMERICFORMAT", .{index});
    }

    pub fn setNumEricFormat(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMERICFORMAT", .{index}, arg);
    }

    pub fn getCellOffset(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "CELLOFFSET", .{index});
    }

    pub fn getWidth(self: *Self, index: i32) i32 {
        return interop.getIntAttribute(self, "WIDTH", .{index});
    }

    pub fn setWidth(self: *Self, index: i32, arg: i32) void {
        interop.setIntAttribute(self, "WIDTH", .{index}, arg);
    }

    pub fn getTouch(self: *Self) bool {
        return interop.getBoolAttribute(self, "TOUCH", .{});
    }

    pub fn setTouch(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "TOUCH", .{}, arg);
    }

    pub fn getName(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NAME", .{});
    }

    pub fn setName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NAME", .{}, arg);
    }

    pub fn getEditValue(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "EDITVALUE", .{});
    }

    pub fn getReadonly(self: *Self) bool {
        return interop.getBoolAttribute(self, "READONLY", .{});
    }

    pub fn setReadonly(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "READONLY", .{}, arg);
    }

    pub fn getNumLinVisible(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "NUMLIN_VISIBLE", .{});
    }

    pub fn setNumLinVisible(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "NUMLIN_VISIBLE", .{}, arg);
    }

    pub fn getPropagateFocus(self: *Self) bool {
        return interop.getBoolAttribute(self, "PROPAGATEFOCUS", .{});
    }

    pub fn setPropagateFocus(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "PROPAGATEFOCUS", .{}, arg);
    }

    pub fn getBackingStore(self: *Self) bool {
        return interop.getBoolAttribute(self, "BACKINGSTORE", .{});
    }

    pub fn setBackingStore(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "BACKINGSTORE", .{}, arg);
    }

    pub fn getDrawDriver(self: *Self) [:0]const u8 {
        return interop.getStrAttribute(self, "DRAWDRIVER", .{});
    }

    pub fn getSbImageBottomPress(self: *Self) ?iup.Element {
        if (interop.getHandleAttribute(self, "SB_IMAGEBOTTOMPRESS", .{})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    pub fn setSbImageBottomPress(self: *Self, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "SB_IMAGEBOTTOMPRESS", .{}, arg);
    }

    pub fn setSbImageBottomPressHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "SB_IMAGEBOTTOMPRESS", .{}, arg);
    }

    pub fn getMdiClient(self: *Self) bool {
        return interop.getBoolAttribute(self, "MDICLIENT", .{});
    }

    pub fn setMdiClient(self: *Self, arg: bool) void {
        interop.setBoolAttribute(self, "MDICLIENT", .{}, arg);
    }

    pub fn getMdiMenu(self: *Self) ?*iup.Menu {
        if (interop.getHandleAttribute(self, "MDIMENU", .{})) |handle| {
            return @ptrCast(handle);
        } else {
            return null;
        }
    }

    pub fn setMdiMenu(self: *Self, arg: *iup.Menu) void {
        interop.setHandleAttribute(self, "MDIMENU", .{}, arg);
    }

    pub fn setMdiMenuHandleName(self: *Self, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "MDIMENU", .{}, arg);
    }

    ///
    /// TABIMAGEn (non inheritable): image name to be used in the respective tab.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// n starts at 0.
    /// See also IupImage.
    /// In Motif, the image is shown only if TABTITLEn is NULL.
    /// In Windows and Motif set the BGCOLOR attribute before setting the image.
    /// When set after map will update the TABIMAGE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABIMAGE (non inheritable) (at children only): Same as TABIMAGEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn getTabImage(self: *Self, index: i32) ?iup.Element {
        if (interop.getHandleAttribute(self, "TABIMAGE", .{index})) |handle| {
            return iup.Element.fromHandle(handle);
        } else {
            return null;
        }
    }

    ///
    /// TABIMAGEn (non inheritable): image name to be used in the respective tab.
    /// Use IupSetHandle or IupSetAttributeHandle to associate an image to a name.
    /// n starts at 0.
    /// See also IupImage.
    /// In Motif, the image is shown only if TABTITLEn is NULL.
    /// In Windows and Motif set the BGCOLOR attribute before setting the image.
    /// When set after map will update the TABIMAGE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABIMAGE (non inheritable) (at children only): Same as TABIMAGEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn setTabImage(self: *Self, index: i32, arg: anytype) !void {
        try interop.validateHandle(.Image, arg);
        interop.setHandleAttribute(self, "TABIMAGE", .{index}, arg);
    }

    pub fn setTabImageHandleName(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TABIMAGE", .{index}, arg);
    }

    ///
    /// TABTITLEn (non inheritable): Contains the text to be shown in the
    /// respective tab title.
    /// n starts at 0.
    /// If this value is NULL, it will remain empty.
    /// The "&" character can be used to define a mnemonic, the next character will
    /// be used as key.
    /// Use "&&" to show the "&" character instead on defining a mnemonic.
    /// The button can be activated from any control in the dialog using the
    /// "Alt+key" combination.
    /// (mnemonic support since 3.3).
    /// When set after map will update the TABTITLE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABTITLE (non inheritable) (at children only): Same as TABTITLEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn getTabTitle(self: *Self, index: i32) [:0]const u8 {
        return interop.getStrAttribute(self, "TABTITLE", .{index});
    }

    ///
    /// TABTITLEn (non inheritable): Contains the text to be shown in the
    /// respective tab title.
    /// n starts at 0.
    /// If this value is NULL, it will remain empty.
    /// The "&" character can be used to define a mnemonic, the next character will
    /// be used as key.
    /// Use "&&" to show the "&" character instead on defining a mnemonic.
    /// The button can be activated from any control in the dialog using the
    /// "Alt+key" combination.
    /// (mnemonic support since 3.3).
    /// When set after map will update the TABTITLE attribute on the respective
    /// child (since 3.10).
    /// (since 3.0).
    /// TABTITLE (non inheritable) (at children only): Same as TABTITLEn but set in
    /// each child.
    /// Works only if set before the child is added to the tabs.
    pub fn setTabTitle(self: *Self, index: i32, arg: [:0]const u8) void {
        interop.setStrAttribute(self, "TABTITLE", .{index}, arg);
    }

    pub fn setColResizeCallback(self: *Self, callback: ?*const OnColResizeFn) void {
        const Handler = CallbackHandler(Self, OnColResizeFn, "COLRESIZE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setWheelCallback(self: *Self, callback: ?*const OnWheelFn) void {
        const Handler = CallbackHandler(Self, OnWheelFn, "WHEEL_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEditMouseMoveCallback(self: *Self, callback: ?*const OnEditMouseMoveFn) void {
        const Handler = CallbackHandler(Self, OnEditMouseMoveFn, "EDITMOUSEMOVE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropCheckCallback(self: *Self, callback: ?*const OnDropCheckFn) void {
        const Handler = CallbackHandler(Self, OnDropCheckFn, "DROPCHECK_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDestroyCallback(self: *Self, callback: ?*const OnDestroyFn) void {
        const Handler = CallbackHandler(Self, OnDestroyFn, "DESTROY_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setNumEricSetValueCallback(self: *Self, callback: ?*const OnNumEricSetValueFn) void {
        const Handler = CallbackHandler(Self, OnNumEricSetValueFn, "NUMERICSETVALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setKillFocusCallback(self: *Self, callback: ?*const OnKillFocusFn) void {
        const Handler = CallbackHandler(Self, OnKillFocusFn, "KILLFOCUS_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMotionCallback(self: *Self, callback: ?*const OnMotionFn) void {
        const Handler = CallbackHandler(Self, OnMotionFn, "MOTION_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragEndCallback(self: *Self, callback: ?*const OnDragEndFn) void {
        const Handler = CallbackHandler(Self, OnDragEndFn, "DRAGEND_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setSortColUmncompareCallback(self: *Self, callback: ?*const OnSortColUmncompareFn) void {
        const Handler = CallbackHandler(Self, OnSortColUmncompareFn, "SORTCOLUMNCOMPARE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setPostMessageCallback(self: *Self, callback: ?*const OnPostMessageFn) void {
        const Handler = CallbackHandler(Self, OnPostMessageFn, "POSTMESSAGE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setTranslateValueCallback(self: *Self, callback: ?*const OnTranslateValueFn) void {
        const Handler = CallbackHandler(Self, OnTranslateValueFn, "TRANSLATEVALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setScrollCallback(self: *Self, callback: ?*const OnScrollFn) void {
        const Handler = CallbackHandler(Self, OnScrollFn, "SCROLL_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMouseMoveCallback(self: *Self, callback: ?*const OnMouseMoveFn) void {
        const Handler = CallbackHandler(Self, OnMouseMoveFn, "MOUSEMOVE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setActionCallback(self: *Self, callback: ?*const OnActionFn) void {
        const Handler = CallbackHandler(Self, OnActionFn, "ACTION_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setWomCallback(self: *Self, callback: ?*const OnWomFn) void {
        const Handler = CallbackHandler(Self, OnWomFn, "WOM_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropDataCallback(self: *Self, callback: ?*const OnDropDataFn) void {
        const Handler = CallbackHandler(Self, OnDropDataFn, "DROPDATA_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setKAnyCallback(self: *Self, callback: ?*const OnKAnyFn) void {
        const Handler = CallbackHandler(Self, OnKAnyFn, "K_ANY");
        Handler.setCallback(self, callback);
    }

    pub fn setScrollTopCallback(self: *Self, callback: ?*const OnScrollTopFn) void {
        const Handler = CallbackHandler(Self, OnScrollTopFn, "SCROLLTOP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropCallback(self: *Self, callback: ?*const OnDropFn) void {
        const Handler = CallbackHandler(Self, OnDropFn, "DROP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMarkCallback(self: *Self, callback: ?*const OnMarkFn) void {
        const Handler = CallbackHandler(Self, OnMarkFn, "MARK_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEnterItemCallback(self: *Self, callback: ?*const OnEnterItemFn) void {
        const Handler = CallbackHandler(Self, OnEnterItemFn, "ENTERITEM_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setUnmapCallback(self: *Self, callback: ?*const OnUnmapFn) void {
        const Handler = CallbackHandler(Self, OnUnmapFn, "UNMAP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEnterWindowCallback(self: *Self, callback: ?*const OnEnterWindowFn) void {
        const Handler = CallbackHandler(Self, OnEnterWindowFn, "ENTERWINDOW_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setLeaveWindowCallback(self: *Self, callback: ?*const OnLeaveWindowFn) void {
        const Handler = CallbackHandler(Self, OnLeaveWindowFn, "LEAVEWINDOW_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setClickCallback(self: *Self, callback: ?*const OnClickFn) void {
        const Handler = CallbackHandler(Self, OnClickFn, "CLICK_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMarkedItCallback(self: *Self, callback: ?*const OnMarkedItFn) void {
        const Handler = CallbackHandler(Self, OnMarkedItFn, "MARKEDIT_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragBeginCallback(self: *Self, callback: ?*const OnDragBeginFn) void {
        const Handler = CallbackHandler(Self, OnDragBeginFn, "DRAGBEGIN_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setTypeCallback(self: *Self, callback: ?*const OnTypeFn) void {
        const Handler = CallbackHandler(Self, OnTypeFn, "TYPE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragDataSizeCallback(self: *Self, callback: ?*const OnDragDataSizeFn) void {
        const Handler = CallbackHandler(Self, OnDragDataSizeFn, "DRAGDATASIZE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEditReleaseCallback(self: *Self, callback: ?*const OnEditReleaseFn) void {
        const Handler = CallbackHandler(Self, OnEditReleaseFn, "EDITRELEASE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setLDestroyCallback(self: *Self, callback: ?*const OnLDestroyFn) void {
        const Handler = CallbackHandler(Self, OnLDestroyFn, "LDESTROY_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setCanvasActionCallback(self: *Self, callback: ?*const OnCanvasActionFn) void {
        const Handler = CallbackHandler(Self, OnCanvasActionFn, "ACTION");
        Handler.setCallback(self, callback);
    }

    pub fn setEditClickCallback(self: *Self, callback: ?*const OnEditClickFn) void {
        const Handler = CallbackHandler(Self, OnEditClickFn, "EDITCLICK_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setValueEditCallback(self: *Self, callback: ?*const OnValueEditFn) void {
        const Handler = CallbackHandler(Self, OnValueEditFn, "VALUE_EDIT_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setFontCallback(self: *Self, callback: ?*const OnFontFn) void {
        const Handler = CallbackHandler(Self, OnFontFn, "FONT_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropMotionCallback(self: *Self, callback: ?*const OnDropMotionFn) void {
        const Handler = CallbackHandler(Self, OnDropMotionFn, "DROPMOTION_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setKeyPressCallback(self: *Self, callback: ?*const OnKeyPressFn) void {
        const Handler = CallbackHandler(Self, OnKeyPressFn, "KEYPRESS_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setToggleValueCallback(self: *Self, callback: ?*const OnToggleValueFn) void {
        const Handler = CallbackHandler(Self, OnToggleValueFn, "TOGGLEVALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setResizeCallback(self: *Self, callback: ?*const OnResizeFn) void {
        const Handler = CallbackHandler(Self, OnResizeFn, "RESIZE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setGetFocusCallback(self: *Self, callback: ?*const OnGetFocusFn) void {
        const Handler = CallbackHandler(Self, OnGetFocusFn, "GETFOCUS_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setHelpCallback(self: *Self, callback: ?*const OnHelpFn) void {
        const Handler = CallbackHandler(Self, OnHelpFn, "HELP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setFocusCallback(self: *Self, callback: ?*const OnFocusFn) void {
        const Handler = CallbackHandler(Self, OnFocusFn, "FOCUS_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropSelectCallback(self: *Self, callback: ?*const OnDropSelectFn) void {
        const Handler = CallbackHandler(Self, OnDropSelectFn, "DROPSELECT_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDropFilesCallback(self: *Self, callback: ?*const OnDropFilesFn) void {
        const Handler = CallbackHandler(Self, OnDropFilesFn, "DROPFILES_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setEditIOnCallback(self: *Self, callback: ?*const OnEditIOnFn) void {
        const Handler = CallbackHandler(Self, OnEditIOnFn, "EDITION_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMenuDropCallback(self: *Self, callback: ?*const OnMenuDropFn) void {
        const Handler = CallbackHandler(Self, OnMenuDropFn, "MENUDROP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDrawCallback(self: *Self, callback: ?*const OnDrawFn) void {
        const Handler = CallbackHandler(Self, OnDrawFn, "DRAW_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setValueCallback(self: *Self, callback: ?*const OnValueFn) void {
        const Handler = CallbackHandler(Self, OnValueFn, "VALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setValueChangedCallback(self: *Self, callback: ?*const OnValueChangedFn) void {
        const Handler = CallbackHandler(Self, OnValueChangedFn, "VALUECHANGED_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setReleaseCallback(self: *Self, callback: ?*const OnReleaseFn) void {
        const Handler = CallbackHandler(Self, OnReleaseFn, "RELEASE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setDragDataCallback(self: *Self, callback: ?*const OnDragDataFn) void {
        const Handler = CallbackHandler(Self, OnDragDataFn, "DRAGDATA_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setButtonCallback(self: *Self, callback: ?*const OnButtonFn) void {
        const Handler = CallbackHandler(Self, OnButtonFn, "BUTTON_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setMapCallback(self: *Self, callback: ?*const OnMapFn) void {
        const Handler = CallbackHandler(Self, OnMapFn, "MAP_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setFgColorCallback(self: *Self, callback: ?*const OnFgColorFn) void {
        const Handler = CallbackHandler(Self, OnFgColorFn, "FGCOLOR_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setNumEricGetValueCallback(self: *Self, callback: ?*const OnNumEricGetValueFn) void {
        const Handler = CallbackHandler(Self, OnNumEricGetValueFn, "NUMERICGETVALUE_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setBgColorCallback(self: *Self, callback: ?*const OnBgColorFn) void {
        const Handler = CallbackHandler(Self, OnBgColorFn, "BGCOLOR_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setLeaveItemCallback(self: *Self, callback: ?*const OnLeaveItemFn) void {
        const Handler = CallbackHandler(Self, OnLeaveItemFn, "LEAVEITEM_CB");
        Handler.setCallback(self, callback);
    }

    pub fn setResizeMatrixCallback(self: *Self, callback: ?*const OnResizeMatrixFn) void {
        const Handler = CallbackHandler(Self, OnResizeMatrixFn, "RESIZEMATRIX_CB");
        Handler.setCallback(self, callback);
    }
};

test "Matrix DrawTextLayoutCenter" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawTextLayoutCenter(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextLayoutCenter();

    try std.testing.expect(ret == true);
}

test "Matrix DragTypes" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDragTypes("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDragTypes();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix HiddenTextMarks" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setHiddenTextMarks("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHiddenTextMarks();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix XMax" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setXMax(42).unwrap());
    defer item.deinit();

    var ret = item.getXMax();

    try std.testing.expect(ret == 42);
}

test "Matrix FrameVertColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFrameVertColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameVertColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Align" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setAlign(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getAlign(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Size" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Matrix FrameHorizColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFrameHorizColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameHorizColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Value" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setValue("Hello").unwrap());
    defer item.deinit();

    var ret = item.getValue();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix NumEricFormatPrecision" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumEricFormatPrecision(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricFormatPrecision(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Type" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setType(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getType(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix SortImageDown" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setSortImageDown("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortImageDown();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix TipFgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTipFgColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getTipFgColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Matrix NumEricDecimalSymbol" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumEricDecimalSymbol("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricDecimalSymbol();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Expand" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setExpand(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getExpand();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "Matrix DrawTextOrientation" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawTextOrientation(3.14).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextOrientation();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Matrix Area" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setArea("Hello").unwrap());
    defer item.deinit();

    var ret = item.getArea();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Merged" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMerged(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getMerged(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix DrawTextAlignment" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawTextAlignment(.ACenter).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextAlignment();

    try std.testing.expect(ret != null and ret.? == .ACenter);
}

test "Matrix DragSource" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDragSource(true).unwrap());
    defer item.deinit();

    var ret = item.getDragSource();

    try std.testing.expect(ret == true);
}

test "Matrix DrawColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getDrawColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Matrix ArrowImages" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setArrowImages(42).unwrap());
    defer item.deinit();

    var ret = item.getArrowImages();

    try std.testing.expect(ret == 42);
}

test "Matrix OrigInOffset" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setOrigInOffset("Hello").unwrap());
    defer item.deinit();

    var ret = item.getOrigInOffset();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix DrawLineWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawLineWidth(42).unwrap());
    defer item.deinit();

    var ret = item.getDrawLineWidth();

    try std.testing.expect(ret == 42);
}

test "Matrix NumColNoScroll" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumColNoScroll("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumColNoScroll();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix FitMaxHeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFitMaxHeight(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFitMaxHeight(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix UserSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setUserSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getUserSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Matrix Marked" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMarked(true).unwrap());
    defer item.deinit();

    var ret = item.getMarked();

    try std.testing.expect(ret == true);
}

test "Matrix NumEricFormatDef" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumEricFormatDef("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricFormatDef();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix XMin" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setXMin(42).unwrap());
    defer item.deinit();

    var ret = item.getXMin();

    try std.testing.expect(ret == 42);
}

test "Matrix DrawTextEllipsis" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawTextEllipsis(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextEllipsis();

    try std.testing.expect(ret == true);
}

test "Matrix MaskInt" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMaskInt(0, 9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMaskInt(0);

    try std.testing.expect(ret.begin == 9 and ret.end == 10);
}

test "Matrix ResizeDrag" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setResizeDrag("Hello").unwrap());
    defer item.deinit();

    var ret = item.getResizeDrag();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix NumLinVisibleLast" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumLinVisibleLast("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumLinVisibleLast();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix FrameColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFrameColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getFrameColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Matrix IdValue" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setIdValue(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getIdValue(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix MarkArea" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMarkArea("Hello").unwrap());
    defer item.deinit();

    var ret = item.getMarkArea();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix FrameTitleHighlight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFrameTitleHighlight("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameTitleHighlight();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Border" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setBorder(true).unwrap());
    defer item.deinit();

    var ret = item.getBorder();

    try std.testing.expect(ret == true);
}

test "Matrix CanFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setCanFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getCanFocus();

    try std.testing.expect(ret == true);
}

test "Matrix ToggleImageOff" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setToggleImageOff("Hello").unwrap());
    defer item.deinit();

    var ret = item.getToggleImageOff();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Merge" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMerge(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getMerge(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix SortSign" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setSortSign(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortSign(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix SortColUmnCaseSensitive" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setSortColUmnCaseSensitive("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortColUmnCaseSensitive();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix ToggleImageOn" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setToggleImageOn("Hello").unwrap());
    defer item.deinit();

    var ret = item.getToggleImageOn();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix YAutoHide" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setYAutoHide(true).unwrap());
    defer item.deinit();

    var ret = item.getYAutoHide();

    try std.testing.expect(ret == true);
}

test "Matrix DrawTextClip" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawTextClip(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextClip();

    try std.testing.expect(ret == true);
}

test "Matrix Theme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix RasterHeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setRasterHeight(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getRasterHeight(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix FocusCell" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFocusCell("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFocusCell();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix LineAlignment" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setLineAlignment(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getLineAlignment(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix WidthDef" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setWidthDef(42).unwrap());
    defer item.deinit();

    var ret = item.getWidthDef();

    try std.testing.expect(ret == 42);
}

test "Matrix RasterWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setRasterWidth(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getRasterWidth(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Visible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setVisible(true).unwrap());
    defer item.deinit();

    var ret = item.getVisible();

    try std.testing.expect(ret == true);
}

test "Matrix NumLinNoScroll" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumLinNoScroll("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumLinNoScroll();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix BgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setBgColor(0, .{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getBgColor(0);

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Matrix RasterSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setRasterSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getRasterSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Matrix DrawStyle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawStyle(.Fill).unwrap());
    defer item.deinit();

    var ret = item.getDrawStyle();

    try std.testing.expect(ret != null and ret.? == .Fill);
}

test "Matrix ShowFillValue" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setShowFillValue("Hello").unwrap());
    defer item.deinit();

    var ret = item.getShowFillValue();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix DropTarget" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDropTarget(true).unwrap());
    defer item.deinit();

    var ret = item.getDropTarget();

    try std.testing.expect(ret == true);
}

test "Matrix MaskNoEmpty" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMaskNoEmpty(0, true).unwrap());
    defer item.deinit();

    var ret = item.getMaskNoEmpty(0);

    try std.testing.expect(ret == true);
}

test "Matrix HideFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setHideFocus("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHideFocus();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix NumCol" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumCol(42).unwrap());
    defer item.deinit();

    var ret = item.getNumCol();

    try std.testing.expect(ret == 42);
}

test "Matrix SortColUmNoRder" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setSortColUmNoRder("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortColUmNoRder();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix UndoRedo" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setUndoRedo("Hello").unwrap());
    defer item.deinit();

    var ret = item.getUndoRedo();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix DrawMakeInactive" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawMakeInactive(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawMakeInactive();

    try std.testing.expect(ret == true);
}

test "Matrix DX" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDX(3.14).unwrap());
    defer item.deinit();

    var ret = item.getDX();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Matrix DY" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDY(3.14).unwrap());
    defer item.deinit();

    var ret = item.getDY();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Matrix TypeColorInactive" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTypeColorInactive("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTypeColorInactive();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Multiline" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMultiline(true).unwrap());
    defer item.deinit();

    var ret = item.getMultiline();

    try std.testing.expect(ret == true);
}

test "Matrix CellFrameVertColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setCellFrameVertColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getCellFrameVertColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Caret" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setCaret(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getCaret();

    try std.testing.expect(ret.lin == 9 and ret.col == 10);
}

test "Matrix NumColVisibleLast" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumColVisibleLast("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumColVisibleLast();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Position" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setPosition(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getPosition();

    try std.testing.expect(ret.x == 9 and ret.y == 10);
}

test "Matrix MinSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMinSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMinSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Matrix MinColWidthDef" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMinColWidthDef(42).unwrap());
    defer item.deinit();

    var ret = item.getMinColWidthDef();

    try std.testing.expect(ret == 42);
}

test "Matrix ResizeMatrixColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setResizeMatrixColor("Hello").unwrap());
    defer item.deinit();

    var ret = item.getResizeMatrixColor();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix LineX" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setLineX(3.14).unwrap());
    defer item.deinit();

    var ret = item.getLineX();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Matrix LineY" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setLineY(3.14).unwrap());
    defer item.deinit();

    var ret = item.getLineY();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Matrix DropTypes" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDropTypes("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDropTypes();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix HandleName" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setHandleName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getHandleName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix FontFace" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFontFace("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontFace();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Mark" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMark(0, .BLock).unwrap());
    defer item.deinit();

    var ret = item.getMark(0);

    try std.testing.expect(ret != null and ret.? == .BLock);
}

test "Matrix Mask" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMask(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getMask(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix MaxSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMaxSize(9, 10).unwrap());
    defer item.deinit();

    var ret = item.getMaxSize();

    try std.testing.expect(ret.width != null and ret.width.? == 9 and ret.height != null and ret.height.? == 10);
}

test "Matrix Flat" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFlat(true).unwrap());
    defer item.deinit();

    var ret = item.getFlat();

    try std.testing.expect(ret == true);
}

test "Matrix NoScrollAsTitle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNoScrollAsTitle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNoScrollAsTitle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Height" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setHeight(0, 42).unwrap());
    defer item.deinit();

    var ret = item.getHeight(0);

    try std.testing.expect(ret == 42);
}

test "Matrix FontStyle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFontStyle(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFontStyle(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix FrameTitleVertColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFrameTitleVertColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameTitleVertColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Font" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFont(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFont(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Multiple" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMultiple(true).unwrap());
    defer item.deinit();

    var ret = item.getMultiple();

    try std.testing.expect(ret == true);
}

test "Matrix MinColWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMinColWidth(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getMinColWidth(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix SortImageUp" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setSortImageUp("Hello").unwrap());
    defer item.deinit();

    var ret = item.getSortImageUp();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix WheelDropFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setWheelDropFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getWheelDropFocus();

    try std.testing.expect(ret == true);
}

test "Matrix FontSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFontSize(0, 42).unwrap());
    defer item.deinit();

    var ret = item.getFontSize(0);

    try std.testing.expect(ret == 42);
}

test "Matrix TipMarkup" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTipMarkup("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTipMarkup();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix CellFrameHorizColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setCellFrameHorizColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getCellFrameHorizColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix YMax" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setYMax(42).unwrap());
    defer item.deinit();

    var ret = item.getYMax();

    try std.testing.expect(ret == 42);
}

test "Matrix NTheme" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNTheme("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNTheme();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix FitMaxWidth" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFitMaxWidth(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFitMaxWidth(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix DragSourceMove" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDragSourceMove(true).unwrap());
    defer item.deinit();

    var ret = item.getDragSourceMove();

    try std.testing.expect(ret == true);
}

test "Matrix NumLin" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumLin(42).unwrap());
    defer item.deinit();

    var ret = item.getNumLin();

    try std.testing.expect(ret == 42);
}

test "Matrix ResizeMatrix" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setResizeMatrix(true).unwrap());
    defer item.deinit();

    var ret = item.getResizeMatrix();

    try std.testing.expect(ret == true);
}

test "Matrix Active" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setActive(true).unwrap());
    defer item.deinit();

    var ret = item.getActive();

    try std.testing.expect(ret == true);
}

test "Matrix FgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFgColor(0, .{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getFgColor(0);

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Matrix HlColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setHlColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getHlColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Matrix TipIcon" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTipIcon("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTipIcon();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix MaskCasei" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMaskCasei(0, true).unwrap());
    defer item.deinit();

    var ret = item.getMaskCasei(0);

    try std.testing.expect(ret == true);
}

test "Matrix LimitExpand" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setLimitExpand("Hello").unwrap());
    defer item.deinit();

    var ret = item.getLimitExpand();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix PosX" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setPosX(3.14).unwrap());
    defer item.deinit();

    var ret = item.getPosX();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Matrix PosY" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setPosY(3.14).unwrap());
    defer item.deinit();

    var ret = item.getPosY();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Matrix NumEricQuantitYIndex" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumEricQuantitYIndex(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricQuantitYIndex(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix XAutoHide" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setXAutoHide(true).unwrap());
    defer item.deinit();

    var ret = item.getXAutoHide();

    try std.testing.expect(ret == true);
}

test "Matrix TipVisible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTipVisible(true).unwrap());
    defer item.deinit();

    var ret = item.getTipVisible();

    try std.testing.expect(ret == true);
}

test "Matrix MarkMode" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMarkMode(.SInGle).unwrap());
    defer item.deinit();

    var ret = item.getMarkMode();

    try std.testing.expect(ret != null and ret.? == .SInGle);
}

test "Matrix DrawFont" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawFont("Hello").unwrap());
    defer item.deinit();

    var ret = item.getDrawFont();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix HeightDef" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setHeightDef(42).unwrap());
    defer item.deinit();

    var ret = item.getHeightDef();

    try std.testing.expect(ret == 42);
}

test "Matrix ExpandWeight" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setExpandWeight(3.14).unwrap());
    defer item.deinit();

    var ret = item.getExpandWeight();

    try std.testing.expect(ret == @as(f64, 3.14));
}

test "Matrix TipBgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTipBgColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getTipBgColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Matrix OrigIn" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setOrigIn("Hello").unwrap());
    defer item.deinit();

    var ret = item.getOrigIn();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix DrawBgColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawBgColor(.{ .r = 9, .g = 10, .b = 11 }).unwrap());
    defer item.deinit();

    var ret = item.getDrawBgColor();

    try std.testing.expect(ret != null and ret.?.r == 9 and ret.?.g == 10 and ret.?.b == 11);
}

test "Matrix EditMode" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setEditMode("Hello").unwrap());
    defer item.deinit();

    var ret = item.getEditMode();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix EditNext" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setEditNext("Hello").unwrap());
    defer item.deinit();

    var ret = item.getEditNext();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix YMin" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setYMin(42).unwrap());
    defer item.deinit();

    var ret = item.getYMin();

    try std.testing.expect(ret == 42);
}

test "Matrix ToggleCenterEd" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setToggleCenterEd("Hello").unwrap());
    defer item.deinit();

    var ret = item.getToggleCenterEd();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix NormalizerGroup" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNormalizerGroup("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNormalizerGroup();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix ScrollBar" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setScrollBar(true).unwrap());
    defer item.deinit();

    var ret = item.getScrollBar();

    try std.testing.expect(ret == true);
}

test "Matrix UseTitleSize" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setUseTitleSize("Hello").unwrap());
    defer item.deinit();

    var ret = item.getUseTitleSize();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix DropFilesTarget" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDropFilesTarget(true).unwrap());
    defer item.deinit();

    var ret = item.getDropFilesTarget();

    try std.testing.expect(ret == true);
}

test "Matrix AlignmentLin0" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setAlignmentLin0("Hello").unwrap());
    defer item.deinit();

    var ret = item.getAlignmentLin0();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix FrameBorder" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFrameBorder("Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameBorder();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix NumEricUnitShowNIndex" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumEricUnitShowNIndex(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricUnitShowNIndex(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix FrameTitleHorizColor" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFrameTitleHorizColor(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getFrameTitleHorizColor(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix MarkAtTitle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMarkAtTitle("Hello").unwrap());
    defer item.deinit();

    var ret = item.getMarkAtTitle();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix EditHideOnFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setEditHideOnFocus("Hello").unwrap());
    defer item.deinit();

    var ret = item.getEditHideOnFocus();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix NumEricUnitIndex" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumEricUnitIndex(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricUnitIndex(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix HlColorAlpha" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setHlColorAlpha(42).unwrap());
    defer item.deinit();

    var ret = item.getHlColorAlpha();

    try std.testing.expect(ret == 42);
}

test "Matrix DrawTextWrap" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDrawTextWrap(true).unwrap());
    defer item.deinit();

    var ret = item.getDrawTextWrap();

    try std.testing.expect(ret == true);
}

test "Matrix Tip" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTip("Hello").unwrap());
    defer item.deinit();

    var ret = item.getTip();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix DragDrop" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setDragDrop(true).unwrap());
    defer item.deinit();

    var ret = item.getDragDrop();

    try std.testing.expect(ret == true);
}

test "Matrix TipDelay" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTipDelay(42).unwrap());
    defer item.deinit();

    var ret = item.getTipDelay();

    try std.testing.expect(ret == 42);
}

test "Matrix ToggleValue" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setToggleValue(0, .On).unwrap());
    defer item.deinit();

    var ret = item.getToggleValue(0);

    try std.testing.expect(ret != null and ret.? == .On);
}

test "Matrix NumColVisible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumColVisible("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumColVisible();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix NumEricFormatTitle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumEricFormatTitle(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricFormatTitle(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix MarkMultiple" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setMarkMultiple(true).unwrap());
    defer item.deinit();

    var ret = item.getMarkMultiple();

    try std.testing.expect(ret == true);
}

test "Matrix Floating" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setFloating(.Yes).unwrap());
    defer item.deinit();

    var ret = item.getFloating();

    try std.testing.expect(ret != null and ret.? == .Yes);
}

test "Matrix NumEricFormat" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumEricFormat(0, "Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumEricFormat(0);

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Width" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setWidth(0, 42).unwrap());
    defer item.deinit();

    var ret = item.getWidth(0);

    try std.testing.expect(ret == 42);
}

test "Matrix Touch" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setTouch(true).unwrap());
    defer item.deinit();

    var ret = item.getTouch();

    try std.testing.expect(ret == true);
}

test "Matrix Name" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setName("Hello").unwrap());
    defer item.deinit();

    var ret = item.getName();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix Readonly" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setReadonly(true).unwrap());
    defer item.deinit();

    var ret = item.getReadonly();

    try std.testing.expect(ret == true);
}

test "Matrix NumLinVisible" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setNumLinVisible("Hello").unwrap());
    defer item.deinit();

    var ret = item.getNumLinVisible();

    try std.testing.expect(std.mem.eql(u8, ret, "Hello"));
}

test "Matrix PropagateFocus" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setPropagateFocus(true).unwrap());
    defer item.deinit();

    var ret = item.getPropagateFocus();

    try std.testing.expect(ret == true);
}

test "Matrix BackingStore" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var item = try (iup.Matrix.init().setBackingStore(true).unwrap());
    defer item.deinit();

    var ret = item.getBackingStore();

    try std.testing.expect(ret == true);
}
