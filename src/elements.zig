// This code was generated by a tool.
// IUP Metadata Code Generator
// https://github.com/batiati/IUPMetadata
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.

const std = @import("std");
const ascii = std.ascii;
const testing = std.testing;

const Impl = @import("../impl.zig").Impl;
const CallbackHandler = @import("../callback_handler.zig").CallbackHandler;

const iup = @import("iup.zig");
const interop = @import("interop.zig");
const ChildrenIterator = iup.ChildrenIterator;

pub const Handle = interop.Handle;
pub const Fill = @import("elements/fill.zig").Fill;
pub const DetachBox = @import("elements/detach_box.zig").DetachBox;
pub const Split = @import("elements/split.zig").Split;
pub const HBox = @import("elements/h_box.zig").HBox;
pub const Label = @import("elements/label.zig").Label;
pub const Tree = @import("elements/tree.zig").Tree;
pub const BackgroundBox = @import("elements/background_box.zig").BackgroundBox;
pub const Normalizer = @import("elements/normalizer.zig").Normalizer;
pub const FontDlg = @import("elements/font_dlg.zig").FontDlg;
pub const FlatList = @import("elements/flat_list.zig").FlatList;
pub const Thread = @import("elements/thread.zig").Thread;
pub const AnimatedLabel = @import("elements/animated_label.zig").AnimatedLabel;
pub const ColorDlg = @import("elements/color_dlg.zig").ColorDlg;
pub const Timer = @import("elements/timer.zig").Timer;
pub const VBox = @import("elements/v_box.zig").VBox;
pub const Tabs = @import("elements/tabs.zig").Tabs;
pub const Multiline = @import("elements/multiline.zig").Multiline;
pub const FlatFrame = @import("elements/flat_frame.zig").FlatFrame;
pub const Image = @import("elements/image.zig").Image;
pub const DropButton = @import("elements/drop_button.zig").DropButton;
pub const Space = @import("elements/space.zig").Space;
pub const FlatSeparator = @import("elements/flat_separator.zig").FlatSeparator;
pub const SBox = @import("elements/s_box.zig").SBox;
pub const FlatLabel = @import("elements/flat_label.zig").FlatLabel;
pub const Param = @import("elements/param.zig").Param;
pub const Button = @import("elements/button.zig").Button;
pub const FileDlg = @import("elements/file_dlg.zig").FileDlg;
pub const List = @import("elements/list.zig").List;
pub const ZBox = @import("elements/z_box.zig").ZBox;
pub const ScrollBox = @import("elements/scroll_box.zig").ScrollBox;
pub const DatePick = @import("elements/date_pick.zig").DatePick;
pub const Spin = @import("elements/spin.zig").Spin;
pub const Clipboard = @import("elements/clipboard.zig").Clipboard;
pub const SubMenu = @import("elements/sub_menu.zig").SubMenu;
pub const Cells = @import("elements/cells.zig").Cells;
pub const MatrixEx = @import("elements/matrix_ex.zig").MatrixEx;
pub const GridBox = @import("elements/grid_box.zig").GridBox;
pub const ImageRgba = @import("elements/image_rgba.zig").ImageRgba;
pub const MatrixList = @import("elements/matrix_list.zig").MatrixList;
pub const Text = @import("elements/text.zig").Text;
pub const Radio = @import("elements/radio.zig").Radio;
pub const Matrix = @import("elements/matrix.zig").Matrix;
pub const Gauge = @import("elements/gauge.zig").Gauge;
pub const ColorBar = @import("elements/color_bar.zig").ColorBar;
pub const ProgressDlg = @import("elements/progress_dlg.zig").ProgressDlg;
pub const Val = @import("elements/val.zig").Val;
pub const Dial = @import("elements/dial.zig").Dial;
pub const MultiBox = @import("elements/multi_box.zig").MultiBox;
pub const Expander = @import("elements/expander.zig").Expander;
pub const CBox = @import("elements/c_box.zig").CBox;
pub const Separator = @import("elements/separator.zig").Separator;
pub const Menu = @import("elements/menu.zig").Menu;
pub const FlatVal = @import("elements/flat_val.zig").FlatVal;
pub const FlatToggle = @import("elements/flat_toggle.zig").FlatToggle;
pub const Calendar = @import("elements/calendar.zig").Calendar;
pub const Item = @import("elements/item.zig").Item;
pub const ParamBox = @import("elements/param_box.zig").ParamBox;
pub const FlatButton = @import("elements/flat_button.zig").FlatButton;
pub const Canvas = @import("elements/canvas.zig").Canvas;
pub const Dialog = @import("elements/dialog.zig").Dialog;
pub const User = @import("elements/user.zig").User;
pub const ColorBrowser = @import("elements/color_browser.zig").ColorBrowser;
pub const Toggle = @import("elements/toggle.zig").Toggle;
pub const SpinBox = @import("elements/spin_box.zig").SpinBox;
pub const Link = @import("elements/link.zig").Link;
pub const ImageRgb = @import("elements/image_rgb.zig").ImageRgb;
pub const FlatTree = @import("elements/flat_tree.zig").FlatTree;
pub const ProgressBar = @import("elements/progress_bar.zig").ProgressBar;
pub const FlatScrollBox = @import("elements/flat_scroll_box.zig").FlatScrollBox;
pub const MessageDlg = @import("elements/message_dlg.zig").MessageDlg;
pub const Frame = @import("elements/frame.zig").Frame;
pub const FlatTabs = @import("elements/flat_tabs.zig").FlatTabs;

///
/// IUP contains several user interface elements.
/// The library’s main characteristic is the use of native elements.
/// This means that the drawing and management of a button or text box is done by the native interface system, not by IUP.
/// This makes the application’s appearance more similar to other applications in that system. On the other hand, the application’s appearance can vary from one system to another.
///
/// But this is valid only for the standard elements, many additional elements are drawn by IUP.
/// Composition elements are not visible, so they are independent from the native system.
///
/// Each element has an unique creation function, and all of its management is done by means of attributes and callbacks, using functions common to all the elements. This simple but powerful approach is one of the advantages of using IUP.
/// Elements are automatically destroyed when the dialog is destroyed.
pub const Element = union(enum) {
    Fill: *Fill,
    DetachBox: *DetachBox,
    Split: *Split,
    HBox: *HBox,
    Label: *Label,
    Tree: *Tree,
    BackgroundBox: *BackgroundBox,
    Normalizer: *Normalizer,
    FontDlg: *FontDlg,
    FlatList: *FlatList,
    Thread: *Thread,
    AnimatedLabel: *AnimatedLabel,
    ColorDlg: *ColorDlg,
    Timer: *Timer,
    VBox: *VBox,
    Tabs: *Tabs,
    Multiline: *Multiline,
    FlatFrame: *FlatFrame,
    Image: *Image,
    DropButton: *DropButton,
    Space: *Space,
    FlatSeparator: *FlatSeparator,
    SBox: *SBox,
    FlatLabel: *FlatLabel,
    Param: *Param,
    Button: *Button,
    FileDlg: *FileDlg,
    List: *List,
    ZBox: *ZBox,
    ScrollBox: *ScrollBox,
    DatePick: *DatePick,
    Spin: *Spin,
    Clipboard: *Clipboard,
    SubMenu: *SubMenu,
    Cells: *Cells,
    MatrixEx: *MatrixEx,
    GridBox: *GridBox,
    ImageRgba: *ImageRgba,
    MatrixList: *MatrixList,
    Text: *Text,
    Radio: *Radio,
    Matrix: *Matrix,
    Gauge: *Gauge,
    ColorBar: *ColorBar,
    ProgressDlg: *ProgressDlg,
    Val: *Val,
    Dial: *Dial,
    MultiBox: *MultiBox,
    Expander: *Expander,
    CBox: *CBox,
    Separator: *Separator,
    Menu: *Menu,
    FlatVal: *FlatVal,
    FlatToggle: *FlatToggle,
    Calendar: *Calendar,
    Item: *Item,
    ParamBox: *ParamBox,
    FlatButton: *FlatButton,
    Canvas: *Canvas,
    Dialog: *Dialog,
    User: *User,
    ColorBrowser: *ColorBrowser,
    Toggle: *Toggle,
    SpinBox: *SpinBox,
    Link: *Link,
    ImageRgb: *ImageRgb,
    FlatTree: *FlatTree,
    ProgressBar: *ProgressBar,
    FlatScrollBox: *FlatScrollBox,
    MessageDlg: *MessageDlg,
    Frame: *Frame,
    FlatTabs: *FlatTabs,

    Unknown: *Handle,

    pub fn fromType(comptime T: type, handle: anytype) Element {
        switch (T) {
            Fill, *Fill => return .{ .Fill = @as(*Fill, @ptrCast(handle)) },
            DetachBox, *DetachBox => return .{ .DetachBox = @as(*DetachBox, @ptrCast(handle)) },
            Split, *Split => return .{ .Split = @as(*Split, @ptrCast(handle)) },
            HBox, *HBox => return .{ .HBox = @as(*HBox, @ptrCast(handle)) },
            Label, *Label => return .{ .Label = @as(*Label, @ptrCast(handle)) },
            Tree, *Tree => return .{ .Tree = @as(*Tree, @ptrCast(handle)) },
            BackgroundBox, *BackgroundBox => return .{ .BackgroundBox = @as(*BackgroundBox, @ptrCast(handle)) },
            Normalizer, *Normalizer => return .{ .Normalizer = @as(*Normalizer, @ptrCast(handle)) },
            FontDlg, *FontDlg => return .{ .FontDlg = @as(*FontDlg, @ptrCast(handle)) },
            FlatList, *FlatList => return .{ .FlatList = @as(*FlatList, @ptrCast(handle)) },
            Thread, *Thread => return .{ .Thread = @as(*Thread, @ptrCast(handle)) },
            AnimatedLabel, *AnimatedLabel => return .{ .AnimatedLabel = @as(*AnimatedLabel, @ptrCast(handle)) },
            ColorDlg, *ColorDlg => return .{ .ColorDlg = @as(*ColorDlg, @ptrCast(handle)) },
            Timer, *Timer => return .{ .Timer = @as(*Timer, @ptrCast(handle)) },
            VBox, *VBox => return .{ .VBox = @as(*VBox, @ptrCast(handle)) },
            Tabs, *Tabs => return .{ .Tabs = @as(*Tabs, @ptrCast(handle)) },
            Multiline, *Multiline => return .{ .Multiline = @as(*Multiline, @ptrCast(handle)) },
            FlatFrame, *FlatFrame => return .{ .FlatFrame = @as(*FlatFrame, @ptrCast(handle)) },
            Image, *Image => return .{ .Image = @as(*Image, @ptrCast(handle)) },
            DropButton, *DropButton => return .{ .DropButton = @as(*DropButton, @ptrCast(handle)) },
            Space, *Space => return .{ .Space = @as(*Space, @ptrCast(handle)) },
            FlatSeparator, *FlatSeparator => return .{ .FlatSeparator = @as(*FlatSeparator, @ptrCast(handle)) },
            SBox, *SBox => return .{ .SBox = @as(*SBox, @ptrCast(handle)) },
            FlatLabel, *FlatLabel => return .{ .FlatLabel = @as(*FlatLabel, @ptrCast(handle)) },
            Param, *Param => return .{ .Param = @as(*Param, @ptrCast(handle)) },
            Button, *Button => return .{ .Button = @as(*Button, @ptrCast(handle)) },
            FileDlg, *FileDlg => return .{ .FileDlg = @as(*FileDlg, @ptrCast(handle)) },
            List, *List => return .{ .List = @as(*List, @ptrCast(handle)) },
            ZBox, *ZBox => return .{ .ZBox = @as(*ZBox, @ptrCast(handle)) },
            ScrollBox, *ScrollBox => return .{ .ScrollBox = @as(*ScrollBox, @ptrCast(handle)) },
            DatePick, *DatePick => return .{ .DatePick = @as(*DatePick, @ptrCast(handle)) },
            Spin, *Spin => return .{ .Spin = @as(*Spin, @ptrCast(handle)) },
            Clipboard, *Clipboard => return .{ .Clipboard = @as(*Clipboard, @ptrCast(handle)) },
            SubMenu, *SubMenu => return .{ .SubMenu = @as(*SubMenu, @ptrCast(handle)) },
            Cells, *Cells => return .{ .Cells = @as(*Cells, @ptrCast(handle)) },
            MatrixEx, *MatrixEx => return .{ .MatrixEx = @as(*MatrixEx, @ptrCast(handle)) },
            GridBox, *GridBox => return .{ .GridBox = @as(*GridBox, @ptrCast(handle)) },
            ImageRgba, *ImageRgba => return .{ .ImageRgba = @as(*ImageRgba, @ptrCast(handle)) },
            MatrixList, *MatrixList => return .{ .MatrixList = @as(*MatrixList, @ptrCast(handle)) },
            Text, *Text => return .{ .Text = @as(*Text, @ptrCast(handle)) },
            Radio, *Radio => return .{ .Radio = @as(*Radio, @ptrCast(handle)) },
            Matrix, *Matrix => return .{ .Matrix = @as(*Matrix, @ptrCast(handle)) },
            Gauge, *Gauge => return .{ .Gauge = @as(*Gauge, @ptrCast(handle)) },
            ColorBar, *ColorBar => return .{ .ColorBar = @as(*ColorBar, @ptrCast(handle)) },
            ProgressDlg, *ProgressDlg => return .{ .ProgressDlg = @as(*ProgressDlg, @ptrCast(handle)) },
            Val, *Val => return .{ .Val = @as(*Val, @ptrCast(handle)) },
            Dial, *Dial => return .{ .Dial = @as(*Dial, @ptrCast(handle)) },
            MultiBox, *MultiBox => return .{ .MultiBox = @as(*MultiBox, @ptrCast(handle)) },
            Expander, *Expander => return .{ .Expander = @as(*Expander, @ptrCast(handle)) },
            CBox, *CBox => return .{ .CBox = @as(*CBox, @ptrCast(handle)) },
            Separator, *Separator => return .{ .Separator = @as(*Separator, @ptrCast(handle)) },
            Menu, *Menu => return .{ .Menu = @as(*Menu, @ptrCast(handle)) },
            FlatVal, *FlatVal => return .{ .FlatVal = @as(*FlatVal, @ptrCast(handle)) },
            FlatToggle, *FlatToggle => return .{ .FlatToggle = @as(*FlatToggle, @ptrCast(handle)) },
            Calendar, *Calendar => return .{ .Calendar = @as(*Calendar, @ptrCast(handle)) },
            Item, *Item => return .{ .Item = @as(*Item, @ptrCast(handle)) },
            ParamBox, *ParamBox => return .{ .ParamBox = @as(*ParamBox, @ptrCast(handle)) },
            FlatButton, *FlatButton => return .{ .FlatButton = @as(*FlatButton, @ptrCast(handle)) },
            Canvas, *Canvas => return .{ .Canvas = @as(*Canvas, @ptrCast(handle)) },
            Dialog, *Dialog => return .{ .Dialog = @as(*Dialog, @ptrCast(handle)) },
            User, *User => return .{ .User = @as(*User, @ptrCast(handle)) },
            ColorBrowser, *ColorBrowser => return .{ .ColorBrowser = @as(*ColorBrowser, @ptrCast(handle)) },
            Toggle, *Toggle => return .{ .Toggle = @as(*Toggle, @ptrCast(handle)) },
            SpinBox, *SpinBox => return .{ .SpinBox = @as(*SpinBox, @ptrCast(handle)) },
            Link, *Link => return .{ .Link = @as(*Link, @ptrCast(handle)) },
            ImageRgb, *ImageRgb => return .{ .ImageRgb = @as(*ImageRgb, @ptrCast(handle)) },
            FlatTree, *FlatTree => return .{ .FlatTree = @as(*FlatTree, @ptrCast(handle)) },
            ProgressBar, *ProgressBar => return .{ .ProgressBar = @as(*ProgressBar, @ptrCast(handle)) },
            FlatScrollBox, *FlatScrollBox => return .{ .FlatScrollBox = @as(*FlatScrollBox, @ptrCast(handle)) },
            MessageDlg, *MessageDlg => return .{ .MessageDlg = @as(*MessageDlg, @ptrCast(handle)) },
            Frame, *Frame => return .{ .Frame = @as(*Frame, @ptrCast(handle)) },
            FlatTabs, *FlatTabs => return .{ .FlatTabs = @as(*FlatTabs, @ptrCast(handle)) },

            else => @compileError("Type " ++ @typeName(T) ++ " cannot be converted to a Element"),
        }
    }

    pub fn fromRef(reference: anytype) Element {
        const referenceType = @TypeOf(reference);
        const typeInfo = @typeInfo(referenceType);

        if (comptime typeInfo == .Pointer) {
            const childType = typeInfo.Pointer.child;
            switch (childType) {
                Fill => return .{ .Fill = reference },
                DetachBox => return .{ .DetachBox = reference },
                Split => return .{ .Split = reference },
                HBox => return .{ .HBox = reference },
                Label => return .{ .Label = reference },
                Tree => return .{ .Tree = reference },
                BackgroundBox => return .{ .BackgroundBox = reference },
                Normalizer => return .{ .Normalizer = reference },
                FontDlg => return .{ .FontDlg = reference },
                FlatList => return .{ .FlatList = reference },
                Thread => return .{ .Thread = reference },
                AnimatedLabel => return .{ .AnimatedLabel = reference },
                ColorDlg => return .{ .ColorDlg = reference },
                Timer => return .{ .Timer = reference },
                VBox => return .{ .VBox = reference },
                Tabs => return .{ .Tabs = reference },
                Multiline => return .{ .Multiline = reference },
                FlatFrame => return .{ .FlatFrame = reference },
                Image => return .{ .Image = reference },
                DropButton => return .{ .DropButton = reference },
                Space => return .{ .Space = reference },
                FlatSeparator => return .{ .FlatSeparator = reference },
                SBox => return .{ .SBox = reference },
                FlatLabel => return .{ .FlatLabel = reference },
                Param => return .{ .Param = reference },
                Button => return .{ .Button = reference },
                FileDlg => return .{ .FileDlg = reference },
                List => return .{ .List = reference },
                ZBox => return .{ .ZBox = reference },
                ScrollBox => return .{ .ScrollBox = reference },
                DatePick => return .{ .DatePick = reference },
                Spin => return .{ .Spin = reference },
                Clipboard => return .{ .Clipboard = reference },
                SubMenu => return .{ .SubMenu = reference },
                Cells => return .{ .Cells = reference },
                MatrixEx => return .{ .MatrixEx = reference },
                GridBox => return .{ .GridBox = reference },
                ImageRgba => return .{ .ImageRgba = reference },
                MatrixList => return .{ .MatrixList = reference },
                Text => return .{ .Text = reference },
                Radio => return .{ .Radio = reference },
                Matrix => return .{ .Matrix = reference },
                Gauge => return .{ .Gauge = reference },
                ColorBar => return .{ .ColorBar = reference },
                ProgressDlg => return .{ .ProgressDlg = reference },
                Val => return .{ .Val = reference },
                Dial => return .{ .Dial = reference },
                MultiBox => return .{ .MultiBox = reference },
                Expander => return .{ .Expander = reference },
                CBox => return .{ .CBox = reference },
                Separator => return .{ .Separator = reference },
                Menu => return .{ .Menu = reference },
                FlatVal => return .{ .FlatVal = reference },
                FlatToggle => return .{ .FlatToggle = reference },
                Calendar => return .{ .Calendar = reference },
                Item => return .{ .Item = reference },
                ParamBox => return .{ .ParamBox = reference },
                FlatButton => return .{ .FlatButton = reference },
                Canvas => return .{ .Canvas = reference },
                Dialog => return .{ .Dialog = reference },
                User => return .{ .User = reference },
                ColorBrowser => return .{ .ColorBrowser = reference },
                Toggle => return .{ .Toggle = reference },
                SpinBox => return .{ .SpinBox = reference },
                Link => return .{ .Link = reference },
                ImageRgb => return .{ .ImageRgb = reference },
                FlatTree => return .{ .FlatTree = reference },
                ProgressBar => return .{ .ProgressBar = reference },
                FlatScrollBox => return .{ .FlatScrollBox = reference },
                MessageDlg => return .{ .MessageDlg = reference },
                Frame => return .{ .Frame = reference },
                FlatTabs => return .{ .FlatTabs = reference },

                else => @compileError("Type " ++ @typeName(referenceType) ++ " cannot be converted to a Element"),
            }
        } else {
            @compileError("Reference to a element expected");
        }
    }

    pub fn fromClassName(className: []const u8, handle: anytype) Element {
        if (ascii.eqlIgnoreCase(className, Fill.CLASS_NAME)) return .{ .Fill = @as(*Fill, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, DetachBox.CLASS_NAME)) return .{ .DetachBox = @as(*DetachBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Split.CLASS_NAME)) return .{ .Split = @as(*Split, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, HBox.CLASS_NAME)) return .{ .HBox = @as(*HBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Label.CLASS_NAME)) return .{ .Label = @as(*Label, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Tree.CLASS_NAME)) return .{ .Tree = @as(*Tree, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, BackgroundBox.CLASS_NAME)) return .{ .BackgroundBox = @as(*BackgroundBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Normalizer.CLASS_NAME)) return .{ .Normalizer = @as(*Normalizer, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FontDlg.CLASS_NAME)) return .{ .FontDlg = @as(*FontDlg, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatList.CLASS_NAME)) return .{ .FlatList = @as(*FlatList, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Thread.CLASS_NAME)) return .{ .Thread = @as(*Thread, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, AnimatedLabel.CLASS_NAME)) return .{ .AnimatedLabel = @as(*AnimatedLabel, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ColorDlg.CLASS_NAME)) return .{ .ColorDlg = @as(*ColorDlg, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Timer.CLASS_NAME)) return .{ .Timer = @as(*Timer, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, VBox.CLASS_NAME)) return .{ .VBox = @as(*VBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Tabs.CLASS_NAME)) return .{ .Tabs = @as(*Tabs, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Multiline.CLASS_NAME)) return .{ .Multiline = @as(*Multiline, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatFrame.CLASS_NAME)) return .{ .FlatFrame = @as(*FlatFrame, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Image.CLASS_NAME)) return .{ .Image = @as(*Image, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, DropButton.CLASS_NAME)) return .{ .DropButton = @as(*DropButton, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Space.CLASS_NAME)) return .{ .Space = @as(*Space, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatSeparator.CLASS_NAME)) return .{ .FlatSeparator = @as(*FlatSeparator, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, SBox.CLASS_NAME)) return .{ .SBox = @as(*SBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatLabel.CLASS_NAME)) return .{ .FlatLabel = @as(*FlatLabel, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Param.CLASS_NAME)) return .{ .Param = @as(*Param, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Button.CLASS_NAME)) return .{ .Button = @as(*Button, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FileDlg.CLASS_NAME)) return .{ .FileDlg = @as(*FileDlg, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, List.CLASS_NAME)) return .{ .List = @as(*List, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ZBox.CLASS_NAME)) return .{ .ZBox = @as(*ZBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ScrollBox.CLASS_NAME)) return .{ .ScrollBox = @as(*ScrollBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, DatePick.CLASS_NAME)) return .{ .DatePick = @as(*DatePick, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Spin.CLASS_NAME)) return .{ .Spin = @as(*Spin, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Clipboard.CLASS_NAME)) return .{ .Clipboard = @as(*Clipboard, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, SubMenu.CLASS_NAME)) return .{ .SubMenu = @as(*SubMenu, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Cells.CLASS_NAME)) return .{ .Cells = @as(*Cells, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, MatrixEx.CLASS_NAME)) return .{ .MatrixEx = @as(*MatrixEx, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, GridBox.CLASS_NAME)) return .{ .GridBox = @as(*GridBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ImageRgba.CLASS_NAME)) return .{ .ImageRgba = @as(*ImageRgba, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, MatrixList.CLASS_NAME)) return .{ .MatrixList = @as(*MatrixList, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Text.CLASS_NAME)) return .{ .Text = @as(*Text, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Radio.CLASS_NAME)) return .{ .Radio = @as(*Radio, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Matrix.CLASS_NAME)) return .{ .Matrix = @as(*Matrix, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Gauge.CLASS_NAME)) return .{ .Gauge = @as(*Gauge, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ColorBar.CLASS_NAME)) return .{ .ColorBar = @as(*ColorBar, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ProgressDlg.CLASS_NAME)) return .{ .ProgressDlg = @as(*ProgressDlg, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Val.CLASS_NAME)) return .{ .Val = @as(*Val, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Dial.CLASS_NAME)) return .{ .Dial = @as(*Dial, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, MultiBox.CLASS_NAME)) return .{ .MultiBox = @as(*MultiBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Expander.CLASS_NAME)) return .{ .Expander = @as(*Expander, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, CBox.CLASS_NAME)) return .{ .CBox = @as(*CBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Separator.CLASS_NAME)) return .{ .Separator = @as(*Separator, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Menu.CLASS_NAME)) return .{ .Menu = @as(*Menu, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatVal.CLASS_NAME)) return .{ .FlatVal = @as(*FlatVal, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatToggle.CLASS_NAME)) return .{ .FlatToggle = @as(*FlatToggle, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Calendar.CLASS_NAME)) return .{ .Calendar = @as(*Calendar, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Item.CLASS_NAME)) return .{ .Item = @as(*Item, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ParamBox.CLASS_NAME)) return .{ .ParamBox = @as(*ParamBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatButton.CLASS_NAME)) return .{ .FlatButton = @as(*FlatButton, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Canvas.CLASS_NAME)) return .{ .Canvas = @as(*Canvas, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Dialog.CLASS_NAME)) return .{ .Dialog = @as(*Dialog, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, User.CLASS_NAME)) return .{ .User = @as(*User, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ColorBrowser.CLASS_NAME)) return .{ .ColorBrowser = @as(*ColorBrowser, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Toggle.CLASS_NAME)) return .{ .Toggle = @as(*Toggle, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, SpinBox.CLASS_NAME)) return .{ .SpinBox = @as(*SpinBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Link.CLASS_NAME)) return .{ .Link = @as(*Link, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ImageRgb.CLASS_NAME)) return .{ .ImageRgb = @as(*ImageRgb, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatTree.CLASS_NAME)) return .{ .FlatTree = @as(*FlatTree, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, ProgressBar.CLASS_NAME)) return .{ .ProgressBar = @as(*ProgressBar, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatScrollBox.CLASS_NAME)) return .{ .FlatScrollBox = @as(*FlatScrollBox, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, MessageDlg.CLASS_NAME)) return .{ .MessageDlg = @as(*MessageDlg, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, Frame.CLASS_NAME)) return .{ .Frame = @as(*Frame, @ptrCast(handle)) };
        if (ascii.eqlIgnoreCase(className, FlatTabs.CLASS_NAME)) return .{ .FlatTabs = @as(*FlatTabs, @ptrCast(handle)) };

        return .{ .Unknown = @as(*Handle, @ptrCast(handle)) };
    }

    pub fn getHandle(self: Element) *Handle {
        switch (self) {
            .Fill => |value| return @as(*Handle, @ptrCast(value)),
            .DetachBox => |value| return @as(*Handle, @ptrCast(value)),
            .Split => |value| return @as(*Handle, @ptrCast(value)),
            .HBox => |value| return @as(*Handle, @ptrCast(value)),
            .Label => |value| return @as(*Handle, @ptrCast(value)),
            .Tree => |value| return @as(*Handle, @ptrCast(value)),
            .BackgroundBox => |value| return @as(*Handle, @ptrCast(value)),
            .Normalizer => |value| return @as(*Handle, @ptrCast(value)),
            .FontDlg => |value| return @as(*Handle, @ptrCast(value)),
            .FlatList => |value| return @as(*Handle, @ptrCast(value)),
            .Thread => |value| return @as(*Handle, @ptrCast(value)),
            .AnimatedLabel => |value| return @as(*Handle, @ptrCast(value)),
            .ColorDlg => |value| return @as(*Handle, @ptrCast(value)),
            .Timer => |value| return @as(*Handle, @ptrCast(value)),
            .VBox => |value| return @as(*Handle, @ptrCast(value)),
            .Tabs => |value| return @as(*Handle, @ptrCast(value)),
            .Multiline => |value| return @as(*Handle, @ptrCast(value)),
            .FlatFrame => |value| return @as(*Handle, @ptrCast(value)),
            .Image => |value| return @as(*Handle, @ptrCast(value)),
            .DropButton => |value| return @as(*Handle, @ptrCast(value)),
            .Space => |value| return @as(*Handle, @ptrCast(value)),
            .FlatSeparator => |value| return @as(*Handle, @ptrCast(value)),
            .SBox => |value| return @as(*Handle, @ptrCast(value)),
            .FlatLabel => |value| return @as(*Handle, @ptrCast(value)),
            .Param => |value| return @as(*Handle, @ptrCast(value)),
            .Button => |value| return @as(*Handle, @ptrCast(value)),
            .FileDlg => |value| return @as(*Handle, @ptrCast(value)),
            .List => |value| return @as(*Handle, @ptrCast(value)),
            .ZBox => |value| return @as(*Handle, @ptrCast(value)),
            .ScrollBox => |value| return @as(*Handle, @ptrCast(value)),
            .DatePick => |value| return @as(*Handle, @ptrCast(value)),
            .Spin => |value| return @as(*Handle, @ptrCast(value)),
            .Clipboard => |value| return @as(*Handle, @ptrCast(value)),
            .SubMenu => |value| return @as(*Handle, @ptrCast(value)),
            .Cells => |value| return @as(*Handle, @ptrCast(value)),
            .MatrixEx => |value| return @as(*Handle, @ptrCast(value)),
            .GridBox => |value| return @as(*Handle, @ptrCast(value)),
            .ImageRgba => |value| return @as(*Handle, @ptrCast(value)),
            .MatrixList => |value| return @as(*Handle, @ptrCast(value)),
            .Text => |value| return @as(*Handle, @ptrCast(value)),
            .Radio => |value| return @as(*Handle, @ptrCast(value)),
            .Matrix => |value| return @as(*Handle, @ptrCast(value)),
            .Gauge => |value| return @as(*Handle, @ptrCast(value)),
            .ColorBar => |value| return @as(*Handle, @ptrCast(value)),
            .ProgressDlg => |value| return @as(*Handle, @ptrCast(value)),
            .Val => |value| return @as(*Handle, @ptrCast(value)),
            .Dial => |value| return @as(*Handle, @ptrCast(value)),
            .MultiBox => |value| return @as(*Handle, @ptrCast(value)),
            .Expander => |value| return @as(*Handle, @ptrCast(value)),
            .CBox => |value| return @as(*Handle, @ptrCast(value)),
            .Separator => |value| return @as(*Handle, @ptrCast(value)),
            .Menu => |value| return @as(*Handle, @ptrCast(value)),
            .FlatVal => |value| return @as(*Handle, @ptrCast(value)),
            .FlatToggle => |value| return @as(*Handle, @ptrCast(value)),
            .Calendar => |value| return @as(*Handle, @ptrCast(value)),
            .Item => |value| return @as(*Handle, @ptrCast(value)),
            .ParamBox => |value| return @as(*Handle, @ptrCast(value)),
            .FlatButton => |value| return @as(*Handle, @ptrCast(value)),
            .Canvas => |value| return @as(*Handle, @ptrCast(value)),
            .Dialog => |value| return @as(*Handle, @ptrCast(value)),
            .User => |value| return @as(*Handle, @ptrCast(value)),
            .ColorBrowser => |value| return @as(*Handle, @ptrCast(value)),
            .Toggle => |value| return @as(*Handle, @ptrCast(value)),
            .SpinBox => |value| return @as(*Handle, @ptrCast(value)),
            .Link => |value| return @as(*Handle, @ptrCast(value)),
            .ImageRgb => |value| return @as(*Handle, @ptrCast(value)),
            .FlatTree => |value| return @as(*Handle, @ptrCast(value)),
            .ProgressBar => |value| return @as(*Handle, @ptrCast(value)),
            .FlatScrollBox => |value| return @as(*Handle, @ptrCast(value)),
            .MessageDlg => |value| return @as(*Handle, @ptrCast(value)),
            .Frame => |value| return @as(*Handle, @ptrCast(value)),
            .FlatTabs => |value| return @as(*Handle, @ptrCast(value)),

            .Unknown => |value| return @as(*Handle, @ptrCast(value)),
        }
    }

    pub fn children(self: Element) ChildrenIterator {
        switch (self) {
            .DetachBox => |value| return value.children(),
            .Split => |value| return value.children(),
            .HBox => |value| return value.children(),
            .BackgroundBox => |value| return value.children(),
            .VBox => |value| return value.children(),
            .Tabs => |value| return value.children(),
            .FlatFrame => |value| return value.children(),
            .SBox => |value| return value.children(),
            .ZBox => |value| return value.children(),
            .ScrollBox => |value| return value.children(),
            .SubMenu => |value| return value.children(),
            .GridBox => |value| return value.children(),
            .Radio => |value| return value.children(),
            .MultiBox => |value| return value.children(),
            .Expander => |value| return value.children(),
            .CBox => |value| return value.children(),
            .Menu => |value| return value.children(),
            .ParamBox => |value| return value.children(),
            .Dialog => |value| return value.children(),
            .User => |value| return value.children(),
            .SpinBox => |value| return value.children(),
            .FlatScrollBox => |value| return value.children(),
            .Frame => |value| return value.children(),
            .FlatTabs => |value| return value.children(),

            else => return ChildrenIterator.NoChildren,
        }
    }

    pub fn eql(self: Element, other: Element) bool {
        return @intFromPtr(self.getHandle()) == @intFromPtr(other.getHandle());
    }

    pub fn deinit(self: Element) void {
        switch (self) {
            .Fill => |element| element.deinit(),
            .DetachBox => |element| element.deinit(),
            .Split => |element| element.deinit(),
            .HBox => |element| element.deinit(),
            .Label => |element| element.deinit(),
            .Tree => |element| element.deinit(),
            .BackgroundBox => |element| element.deinit(),
            .Normalizer => |element| element.deinit(),
            .FontDlg => |element| element.deinit(),
            .FlatList => |element| element.deinit(),
            .Thread => |element| element.deinit(),
            .AnimatedLabel => |element| element.deinit(),
            .ColorDlg => |element| element.deinit(),
            .Timer => |element| element.deinit(),
            .VBox => |element| element.deinit(),
            .Tabs => |element| element.deinit(),
            .Multiline => |element| element.deinit(),
            .FlatFrame => |element| element.deinit(),
            .Image => |element| element.deinit(),
            .DropButton => |element| element.deinit(),
            .Space => |element| element.deinit(),
            .FlatSeparator => |element| element.deinit(),
            .SBox => |element| element.deinit(),
            .FlatLabel => |element| element.deinit(),
            .Param => |element| element.deinit(),
            .Button => |element| element.deinit(),
            .FileDlg => |element| element.deinit(),
            .List => |element| element.deinit(),
            .ZBox => |element| element.deinit(),
            .ScrollBox => |element| element.deinit(),
            .DatePick => |element| element.deinit(),
            .Spin => |element| element.deinit(),
            .Clipboard => |element| element.deinit(),
            .SubMenu => |element| element.deinit(),
            .Cells => |element| element.deinit(),
            .MatrixEx => |element| element.deinit(),
            .GridBox => |element| element.deinit(),
            .ImageRgba => |element| element.deinit(),
            .MatrixList => |element| element.deinit(),
            .Text => |element| element.deinit(),
            .Radio => |element| element.deinit(),
            .Matrix => |element| element.deinit(),
            .Gauge => |element| element.deinit(),
            .ColorBar => |element| element.deinit(),
            .ProgressDlg => |element| element.deinit(),
            .Val => |element| element.deinit(),
            .Dial => |element| element.deinit(),
            .MultiBox => |element| element.deinit(),
            .Expander => |element| element.deinit(),
            .CBox => |element| element.deinit(),
            .Separator => |element| element.deinit(),
            .Menu => |element| element.deinit(),
            .FlatVal => |element| element.deinit(),
            .FlatToggle => |element| element.deinit(),
            .Calendar => |element| element.deinit(),
            .Item => |element| element.deinit(),
            .ParamBox => |element| element.deinit(),
            .FlatButton => |element| element.deinit(),
            .Canvas => |element| element.deinit(),
            .Dialog => |element| element.deinit(),
            .User => |element| element.deinit(),
            .ColorBrowser => |element| element.deinit(),
            .Toggle => |element| element.deinit(),
            .SpinBox => |element| element.deinit(),
            .Link => |element| element.deinit(),
            .ImageRgb => |element| element.deinit(),
            .FlatTree => |element| element.deinit(),
            .ProgressBar => |element| element.deinit(),
            .FlatScrollBox => |element| element.deinit(),
            .MessageDlg => |element| element.deinit(),
            .Frame => |element| element.deinit(),
            .FlatTabs => |element| element.deinit(),

            else => unreachable,
        }
    }

    pub fn setAttribute(self: Element, attribute: [:0]const u8, value: [:0]const u8) void {
        interop.setStrAttribute(self.getHandle(), attribute, .{}, value);
    }

    pub fn getAttribute(self: Element, attribute: [:0]const u8) [:0]const u8 {
        return interop.getStrAttribute(self.getHandle(), attribute, .{});
    }

    pub fn setTag(self: Element, comptime T: type, attribute: [:0]const u8, value: ?*T) void {
        interop.setPtrAttribute(T, self.getHandle(), attribute, .{}, value);
    }

    pub fn getTag(self: Element, comptime T: type, attribute: [:0]const u8) ?*T {
        return interop.getPtrAttribute(T, self.getHandle(), attribute, .{});
    }
};

test "retrieve element fromType" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var handle = try iup.Label.init().unwrap();
    defer handle.deinit();

    var fromType = Element.fromType(iup.Label, handle);
    try testing.expect(fromType == .Label);
    try testing.expect(@intFromPtr(fromType.Label) == @intFromPtr(handle));
}

test "retrieve element fromRef" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var handle = try iup.Label.init().unwrap();
    defer handle.deinit();

    var fromRef = Element.fromRef(handle);
    try testing.expect(fromRef == .Label);
    try testing.expect(@intFromPtr(fromRef.Label) == @intFromPtr(handle));
}

test "retrieve element fromClassName" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var handle = try iup.Label.init().unwrap();
    defer handle.deinit();

    var fromClassName = Element.fromClassName(Label.CLASS_NAME, handle);
    try testing.expect(fromClassName == .Label);
    try testing.expect(@intFromPtr(fromClassName.Label) == @intFromPtr(handle));
}

test "getHandle" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var handle = try iup.Label.init().unwrap();
    defer handle.deinit();

    var element = Element{ .Label = handle };
    var value = element.getHandle();
    try testing.expect(@intFromPtr(handle) == @intFromPtr(value));
}

test "children" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var parent = try iup.HBox.init().unwrap();
    var child1 = try iup.HBox.init().unwrap();
    var child2 = try iup.HBox.init().unwrap();

    try parent.appendChild(child1);
    try parent.appendChild(child2);

    var element = Element{ .HBox = parent };
    var children = element.children();

    if (children.next()) |ret1| {
        try testing.expect(ret1 == .HBox);
        try testing.expect(ret1.HBox == child1);
    } else {
        try testing.expect(false);
    }

    if (children.next()) |ret2| {
        try testing.expect(ret2 == .HBox);
        try testing.expect(ret2.HBox == child2);
    } else {
        try testing.expect(false);
    }

    var ret3 = children.next();
    try testing.expect(ret3 == null);
}

test "eql" {
    try iup.MainLoop.open();
    defer iup.MainLoop.close();

    var l1 = Element.fromRef(try iup.Label.init().unwrap());
    defer l1.deinit();

    var l2 = Element.fromRef(try iup.Label.init().unwrap());
    defer l2.deinit();

    var l1_copy = l1;

    try testing.expect(l1.eql(l1));
    try testing.expect(l2.eql(l2));
    try testing.expect(l1.eql(l1_copy));
    try testing.expect(!l1.eql(l2));
    try testing.expect(!l2.eql(l1));
}
